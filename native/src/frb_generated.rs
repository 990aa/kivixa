// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1959240715;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__add_graph_edge_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    source: impl CstDecode<String>,
    target: impl CstDecode<String>,
    weight: impl CstDecode<f32>,
    edge_type: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_graph_edge",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_source = source.cst_decode();
            let api_target = target.cst_decode();
            let api_weight = weight.cst_decode();
            let api_edge_type = edge_type.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_graph_edge(
                            api_source,
                            api_target,
                            api_weight,
                            api_edge_type,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_graph_edges_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    edges: impl CstDecode<Vec<crate::graph::GraphEdge>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_graph_edges",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_edges = edges.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_graph_edges(api_edges)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_graph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    label: impl CstDecode<String>,
    node_type: impl CstDecode<String>,
    x: impl CstDecode<f32>,
    y: impl CstDecode<f32>,
    color: impl CstDecode<Option<String>>,
    metadata: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_graph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_label = label.cst_decode();
            let api_node_type = node_type.cst_decode();
            let api_x = x.cst_decode();
            let api_y = y.cst_decode();
            let api_color = color.cst_decode();
            let api_metadata = metadata.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_graph_node(
                            api_id,
                            api_label,
                            api_node_type,
                            api_x,
                            api_y,
                            api_color,
                            api_metadata,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_graph_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    nodes: impl CstDecode<Vec<crate::graph::GraphNode>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_graph_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_nodes = nodes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_graph_nodes(api_nodes)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_stream_edge_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    from_id: impl CstDecode<String>,
    to_id: impl CstDecode<String>,
    strength: impl CstDecode<f32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_stream_edge",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_from_id = from_id.cst_decode();
            let api_to_id = to_id.cst_decode();
            let api_strength = strength.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::add_stream_edge(api_from_id, api_to_id, api_strength)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_stream_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    x: impl CstDecode<f32>,
    y: impl CstDecode<f32>,
    radius: impl CstDecode<f32>,
    color: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_stream_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_x = x.cst_decode();
            let api_y = y.cst_decode();
            let api_radius = radius.cst_decode();
            let api_color = color.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_stream_node(
                            api_id, api_x, api_y, api_radius, api_color,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__analyze_knowledge_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entries: impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>,
    k: impl CstDecode<Option<usize>>,
    similarity_threshold: impl CstDecode<Option<f32>>,
    existing_links: impl CstDecode<Option<Vec<(String, String)>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "analyze_knowledge_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entries = entries.cst_decode();
            let api_k = k.cst_decode();
            let api_similarity_threshold = similarity_threshold.cst_decode();
            let api_existing_links = existing_links.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::analyze_knowledge_graph(
                            api_entries,
                            api_k,
                            api_similarity_threshold,
                            api_existing_links,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__batch_embed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    texts: impl CstDecode<Vec<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "batch_embed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_texts = texts.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::batch_embed(api_texts)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__chat_completion_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    messages: impl CstDecode<Vec<(String, String)>>,
    max_tokens: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chat_completion",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_messages = messages.cst_decode();
            let api_max_tokens = max_tokens.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::chat_completion(api_messages, api_max_tokens)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__clear_graph_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco
{
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_graph",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::clear_graph();
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__clear_stream_graph_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_stream_graph",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::clear_stream_graph();
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__cluster_embeddings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entries: impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>,
    threshold: impl CstDecode<f32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cluster_embeddings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entries = entries.cst_decode();
            let api_threshold = threshold.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::cluster_embeddings(
                        api_entries,
                        api_threshold,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__cluster_notes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entries: impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>,
    k: impl CstDecode<Option<usize>>,
    max_iterations: impl CstDecode<Option<usize>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cluster_notes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entries = entries.cst_decode();
            let api_k = k.cst_decode();
            let api_max_iterations = max_iterations.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::cluster_notes(api_entries, api_k, api_max_iterations)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__compute_graph_layout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    iterations: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "compute_graph_layout",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_iterations = iterations.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::compute_graph_layout(api_iterations)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__connect_note_to_topics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    note_id: impl CstDecode<String>,
    topic_ids: impl CstDecode<Vec<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "connect_note_to_topics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_note_id = note_id.cst_decode();
            let api_topic_ids = topic_ids.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::connect_note_to_topics(api_note_id, api_topic_ids)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__cosine_similarity_impl(
    a: impl CstDecode<Vec<f32>>,
    b: impl CstDecode<Vec<f32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cosine_similarity",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::cosine_similarity(api_a, api_b))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__discover_semantic_edges_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entries: impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>,
    threshold: impl CstDecode<Option<f32>>,
    existing_links: impl CstDecode<Option<Vec<(String, String)>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "discover_semantic_edges",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entries = entries.cst_decode();
            let api_threshold = threshold.cst_decode();
            let api_existing_links = existing_links.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::discover_semantic_edges(
                        api_entries,
                        api_threshold,
                        api_existing_links,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__extract_topics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    text: impl CstDecode<String>,
    num_topics: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "extract_topics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_text = text.cst_decode();
            let api_num_topics = num_topics.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::extract_topics(api_text, api_num_topics)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__find_similar_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    query: impl CstDecode<Vec<f32>>,
    entries: impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>,
    top_k: impl CstDecode<usize>,
    threshold: impl CstDecode<f32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_similar",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_query = query.cst_decode();
            let api_entries = entries.cst_decode();
            let api_top_k = top_k.cst_decode();
            let api_threshold = threshold.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::find_similar(
                        api_query,
                        api_entries,
                        api_top_k,
                        api_threshold,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__generate_text_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    prompt: impl CstDecode<String>,
    max_tokens: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_text",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_prompt = prompt.cst_decode();
            let api_max_tokens = max_tokens.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::generate_text(api_prompt, api_max_tokens)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_embedding_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    text: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_embedding",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_text = text.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_embedding(api_text)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_embedding_dimension_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_embedding_dimension",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::get_embedding_dimension()?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__get_graph_state_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_graph_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_graph_state()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_model_type_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_model_type",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::get_model_type())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_or_create_topic_hub_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    topic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_or_create_topic_hub",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_topic = topic.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_or_create_topic_hub(api_topic)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_stream_graph_stats_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_stream_graph_stats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::get_stream_graph_stats())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_version_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco
{
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_version",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::get_version())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_visible_graph_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_visible_graph_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_visible_graph_nodes())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__health_check_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco
{
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "health_check",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::health_check())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__init_graph_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_graph",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::init_graph();
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__init_mcp_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    base_path: impl CstDecode<String>,
    max_file_size: impl CstDecode<Option<usize>>,
    allowed_extensions: impl CstDecode<Option<Vec<String>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_mcp",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_base_path = base_path.cst_decode();
            let api_max_file_size = max_file_size.cst_decode();
            let api_allowed_extensions = allowed_extensions.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::init_mcp(
                            api_base_path,
                            api_max_file_size,
                            api_allowed_extensions,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__init_model_impl(
    model_path: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_model",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_model_path = model_path.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::init_model(api_model_path)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__init_model_with_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    model_path: impl CstDecode<String>,
    n_gpu_layers: impl CstDecode<u32>,
    n_ctx: impl CstDecode<u32>,
    n_threads: impl CstDecode<i32>,
    temperature: impl CstDecode<f32>,
    top_p: impl CstDecode<f32>,
    max_tokens: impl CstDecode<u32>,
    model_type: impl CstDecode<Option<i32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_model_with_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_model_path = model_path.cst_decode();
            let api_n_gpu_layers = n_gpu_layers.cst_decode();
            let api_n_ctx = n_ctx.cst_decode();
            let api_n_threads = n_threads.cst_decode();
            let api_temperature = temperature.cst_decode();
            let api_top_p = top_p.cst_decode();
            let api_max_tokens = max_tokens.cst_decode();
            let api_model_type = model_type.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::init_model_with_config(
                            api_model_path,
                            api_n_gpu_layers,
                            api_n_ctx,
                            api_n_threads,
                            api_temperature,
                            api_top_p,
                            api_max_tokens,
                            api_model_type,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__is_graph_stream_running_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_graph_stream_running",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::is_graph_stream_running())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_mcp_initialized_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_mcp_initialized",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::is_mcp_initialized())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_model_loaded_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_model_loaded",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::is_model_loaded())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_classify_task_impl(
    message: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_classify_task",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_message = message.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mcp_classify_task(api_message))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_create_folder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_create_folder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mcp_create_folder(api_path)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__mcp_delete_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_delete_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mcp_delete_file(api_path)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__mcp_execute_tool_call_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    tool_call: impl CstDecode<crate::mcp::MCPToolCall>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_execute_tool_call",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_tool_call = tool_call.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::mcp_execute_tool_call(api_tool_call))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__mcp_get_all_tools_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_get_all_tools",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mcp_get_all_tools())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_get_model_for_task_impl(
    category: impl CstDecode<crate::mcp::TaskCategory>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_get_model_for_task",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_category = category.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::mcp_get_model_for_task(api_category))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_get_tool_description_impl(
    tool: impl CstDecode<crate::mcp::MCPTool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_get_tool_description",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_tool = tool.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::mcp_get_tool_description(api_tool))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_get_tool_name_impl(
    tool: impl CstDecode<crate::mcp::MCPTool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_get_tool_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_tool = tool.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mcp_get_tool_name(api_tool))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_get_tool_parameters_impl(
    tool: impl CstDecode<crate::mcp::MCPTool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_get_tool_parameters",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_tool = tool.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mcp_get_tool_parameters(api_tool))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_get_tool_schemas_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_get_tool_schemas",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mcp_get_tool_schemas())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_list_files_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_list_files",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mcp_list_files(api_path)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__mcp_parse_tool_call_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_parse_tool_call",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json = json.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mcp_parse_tool_call(api_json)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__mcp_read_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_read_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mcp_read_file(api_path)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__mcp_validate_path_impl(
    path: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_validate_path",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_path = path.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mcp_validate_path(api_path))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mcp_write_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
    content: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mcp_write_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            let api_content = content.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::mcp_write_file(api_path, api_content)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__pin_stream_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    pinned: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pin_stream_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_pinned = pinned.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::pin_stream_node(api_id, api_pinned)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__remove_graph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_graph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::remove_graph_node(api_node_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__remove_stream_edge_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    from_id: impl CstDecode<String>,
    to_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_stream_edge",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_from_id = from_id.cst_decode();
            let api_to_id = to_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::remove_stream_edge(api_from_id, api_to_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__remove_stream_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_stream_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::remove_stream_node(api_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__semantic_search_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    query_text: impl CstDecode<String>,
    entries: impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>,
    top_k: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "semantic_search",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_query_text = query_text.cst_decode();
            let api_entries = entries.cst_decode();
            let api_top_k = top_k.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::semantic_search(api_query_text, api_entries, api_top_k)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_stream_node_position_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    x: impl CstDecode<f32>,
    y: impl CstDecode<f32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_stream_node_position",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_x = x.cst_decode();
            let api_y = y.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_stream_node_position(api_id, api_x, api_y)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__start_graph_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_graph_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::start_graph_stream()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__stop_graph_stream_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_graph_stream",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::stop_graph_stream();
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__unload_model_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco
{
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unload_model",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::unload_model();
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__update_graph_viewport_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    x: impl CstDecode<f32>,
    y: impl CstDecode<f32>,
    width: impl CstDecode<f32>,
    height: impl CstDecode<f32>,
    scale: impl CstDecode<f32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_graph_viewport",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_x = x.cst_decode();
            let api_y = y.cst_decode();
            let api_width = width.cst_decode();
            let api_height = height.cst_decode();
            let api_scale = scale.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::update_graph_viewport(
                            api_x, api_y, api_width, api_height, api_scale,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f32> for f32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f32 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::mcp::MCPParamType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::mcp::MCPParamType {
        match self {
            0 => crate::mcp::MCPParamType::String,
            1 => crate::mcp::MCPParamType::Boolean,
            2 => crate::mcp::MCPParamType::Integer,
            3 => crate::mcp::MCPParamType::Array,
            _ => unreachable!("Invalid variant for MCPParamType: {}", self),
        }
    }
}
impl CstDecode<crate::mcp::MCPTool> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::mcp::MCPTool {
        match self {
            0 => crate::mcp::MCPTool::ReadFile,
            1 => crate::mcp::MCPTool::WriteFile,
            2 => crate::mcp::MCPTool::DeleteFile,
            3 => crate::mcp::MCPTool::CreateFolder,
            4 => crate::mcp::MCPTool::ListFiles,
            5 => crate::mcp::MCPTool::CalendarLua,
            6 => crate::mcp::MCPTool::TimerLua,
            7 => crate::mcp::MCPTool::ExportMarkdown,
            _ => unreachable!("Invalid variant for MCPTool: {}", self),
        }
    }
}
impl CstDecode<crate::mcp::TaskCategory> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::mcp::TaskCategory {
        match self {
            0 => crate::mcp::TaskCategory::Conversation,
            1 => crate::mcp::TaskCategory::ToolUse,
            2 => crate::mcp::TaskCategory::CodeGeneration,
            _ => unreachable!("Invalid variant for TaskCategory: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::clustering::ClusterAssignment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_clusterId = <usize>::sse_decode(deserializer);
        let mut var_color = <String>::sse_decode(deserializer);
        return crate::clustering::ClusterAssignment {
            id: var_id,
            cluster_id: var_clusterId,
            color: var_color,
        };
    }
}

impl SseDecode for crate::clustering::ClusterInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <usize>::sse_decode(deserializer);
        let mut var_size = <usize>::sse_decode(deserializer);
        let mut var_color = <String>::sse_decode(deserializer);
        let mut var_centroid = <Option<Vec<f32>>>::sse_decode(deserializer);
        return crate::clustering::ClusterInfo {
            id: var_id,
            size: var_size,
            color: var_color,
            centroid: var_centroid,
        };
    }
}

impl SseDecode for crate::clustering::ClusteringResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_assignments =
            <Vec<crate::clustering::ClusterAssignment>>::sse_decode(deserializer);
        let mut var_clusters = <Vec<crate::clustering::ClusterInfo>>::sse_decode(deserializer);
        let mut var_k = <usize>::sse_decode(deserializer);
        return crate::clustering::ClusteringResult {
            assignments: var_assignments,
            clusters: var_clusters,
            k: var_k,
        };
    }
}

impl SseDecode for crate::api::EmbeddingCluster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ids = <Vec<String>>::sse_decode(deserializer);
        return crate::api::EmbeddingCluster { ids: var_ids };
    }
}

impl SseDecode for crate::embeddings::EmbeddingEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_vector = <Vec<f32>>::sse_decode(deserializer);
        let mut var_textPreview = <Option<String>>::sse_decode(deserializer);
        return crate::embeddings::EmbeddingEntry {
            id: var_id,
            vector: var_vector,
            text_preview: var_textPreview,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::graph::GraphEdge {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_source = <String>::sse_decode(deserializer);
        let mut var_target = <String>::sse_decode(deserializer);
        let mut var_weight = <f32>::sse_decode(deserializer);
        let mut var_edgeType = <String>::sse_decode(deserializer);
        return crate::graph::GraphEdge {
            source: var_source,
            target: var_target,
            weight: var_weight,
            edge_type: var_edgeType,
        };
    }
}

impl SseDecode for crate::graph::GraphNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_nodeType = <String>::sse_decode(deserializer);
        let mut var_x = <f32>::sse_decode(deserializer);
        let mut var_y = <f32>::sse_decode(deserializer);
        let mut var_color = <Option<String>>::sse_decode(deserializer);
        let mut var_metadata = <Option<String>>::sse_decode(deserializer);
        return crate::graph::GraphNode {
            id: var_id,
            label: var_label,
            node_type: var_nodeType,
            x: var_x,
            y: var_y,
            color: var_color,
            metadata: var_metadata,
        };
    }
}

impl SseDecode for crate::graph::GraphState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodes = <Vec<crate::graph::GraphNode>>::sse_decode(deserializer);
        let mut var_edges = <Vec<crate::graph::GraphEdge>>::sse_decode(deserializer);
        return crate::graph::GraphState {
            nodes: var_nodes,
            edges: var_edges,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::KnowledgeGraphAnalysis {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_clustering = <crate::clustering::ClusteringResult>::sse_decode(deserializer);
        let mut var_semanticEdges =
            <crate::clustering::SemanticEdgeResult>::sse_decode(deserializer);
        return crate::api::KnowledgeGraphAnalysis {
            clustering: var_clustering,
            semantic_edges: var_semanticEdges,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::clustering::ClusterAssignment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::clustering::ClusterAssignment>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::clustering::ClusterInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::clustering::ClusterInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::EmbeddingCluster> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::EmbeddingCluster>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::embeddings::EmbeddingEntry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::embeddings::EmbeddingEntry>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::graph::GraphEdge> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::graph::GraphEdge>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::graph::GraphNode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::graph::GraphNode>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::mcp::MCPParameter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::mcp::MCPParameter>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::mcp::MCPTool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::mcp::MCPTool>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::streaming::NodePosition> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::streaming::NodePosition>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::clustering::SemanticEdge> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::clustering::SemanticEdge>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::embeddings::SimilarityResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::embeddings::SimilarityResult>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::mcp::MCPParamType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::mcp::MCPParamType::String,
            1 => crate::mcp::MCPParamType::Boolean,
            2 => crate::mcp::MCPParamType::Integer,
            3 => crate::mcp::MCPParamType::Array,
            _ => unreachable!("Invalid variant for MCPParamType: {}", inner),
        };
    }
}

impl SseDecode for crate::mcp::MCPParameter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_paramType = <crate::mcp::MCPParamType>::sse_decode(deserializer);
        let mut var_required_ = <bool>::sse_decode(deserializer);
        return crate::mcp::MCPParameter {
            name: var_name,
            description: var_description,
            param_type: var_paramType,
            required: var_required_,
        };
    }
}

impl SseDecode for crate::mcp::MCPTool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::mcp::MCPTool::ReadFile,
            1 => crate::mcp::MCPTool::WriteFile,
            2 => crate::mcp::MCPTool::DeleteFile,
            3 => crate::mcp::MCPTool::CreateFolder,
            4 => crate::mcp::MCPTool::ListFiles,
            5 => crate::mcp::MCPTool::CalendarLua,
            6 => crate::mcp::MCPTool::TimerLua,
            7 => crate::mcp::MCPTool::ExportMarkdown,
            _ => unreachable!("Invalid variant for MCPTool: {}", inner),
        };
    }
}

impl SseDecode for crate::mcp::MCPToolCall {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tool = <String>::sse_decode(deserializer);
        let mut var_parametersJson = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        return crate::mcp::MCPToolCall {
            tool: var_tool,
            parameters_json: var_parametersJson,
            description: var_description,
        };
    }
}

impl SseDecode for crate::mcp::MCPToolResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_result = <String>::sse_decode(deserializer);
        let mut var_tool = <String>::sse_decode(deserializer);
        return crate::mcp::MCPToolResult {
            success: var_success,
            result: var_result,
            tool: var_tool,
        };
    }
}

impl SseDecode for crate::streaming::NodePosition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_x = <f32>::sse_decode(deserializer);
        let mut var_y = <f32>::sse_decode(deserializer);
        let mut var_radius = <f32>::sse_decode(deserializer);
        let mut var_color = <u32>::sse_decode(deserializer);
        let mut var_nodeType = <String>::sse_decode(deserializer);
        return crate::streaming::NodePosition {
            id: var_id,
            x: var_x,
            y: var_y,
            radius: var_radius,
            color: var_color,
            node_type: var_nodeType,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<f32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<f32>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<(String, String)>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<(String, String)>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::clustering::SemanticEdge {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_source = <String>::sse_decode(deserializer);
        let mut var_target = <String>::sse_decode(deserializer);
        let mut var_similarity = <f32>::sse_decode(deserializer);
        let mut var_isGhost = <bool>::sse_decode(deserializer);
        return crate::clustering::SemanticEdge {
            source: var_source,
            target: var_target,
            similarity: var_similarity,
            is_ghost: var_isGhost,
        };
    }
}

impl SseDecode for crate::clustering::SemanticEdgeResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_edges = <Vec<crate::clustering::SemanticEdge>>::sse_decode(deserializer);
        let mut var_count = <usize>::sse_decode(deserializer);
        return crate::clustering::SemanticEdgeResult {
            edges: var_edges,
            count: var_count,
        };
    }
}

impl SseDecode for crate::embeddings::SimilarityResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_score = <f32>::sse_decode(deserializer);
        let mut var_textPreview = <Option<String>>::sse_decode(deserializer);
        return crate::embeddings::SimilarityResult {
            id: var_id,
            score: var_score,
            text_preview: var_textPreview,
        };
    }
}

impl SseDecode for crate::api::StreamGraphStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeCount = <usize>::sse_decode(deserializer);
        let mut var_edgeCount = <usize>::sse_decode(deserializer);
        let mut var_visibleCount = <usize>::sse_decode(deserializer);
        return crate::api::StreamGraphStats {
            node_count: var_nodeCount,
            edge_count: var_edgeCount,
            visible_count: var_visibleCount,
        };
    }
}

impl SseDecode for crate::mcp::TaskCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::mcp::TaskCategory::Conversation,
            1 => crate::mcp::TaskCategory::ToolUse,
            2 => crate::mcp::TaskCategory::CodeGeneration,
            _ => unreachable!("Invalid variant for TaskCategory: {}", inner),
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::clustering::ClusterAssignment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.cluster_id.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::clustering::ClusterAssignment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::clustering::ClusterAssignment>
    for crate::clustering::ClusterAssignment
{
    fn into_into_dart(self) -> crate::clustering::ClusterAssignment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::clustering::ClusterInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
            self.centroid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::clustering::ClusterInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::clustering::ClusterInfo>
    for crate::clustering::ClusterInfo
{
    fn into_into_dart(self) -> crate::clustering::ClusterInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::clustering::ClusteringResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.assignments.into_into_dart().into_dart(),
            self.clusters.into_into_dart().into_dart(),
            self.k.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::clustering::ClusteringResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::clustering::ClusteringResult>
    for crate::clustering::ClusteringResult
{
    fn into_into_dart(self) -> crate::clustering::ClusteringResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::EmbeddingCluster {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ids.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::EmbeddingCluster {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::EmbeddingCluster>
    for crate::api::EmbeddingCluster
{
    fn into_into_dart(self) -> crate::api::EmbeddingCluster {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::embeddings::EmbeddingEntry {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.vector.into_into_dart().into_dart(),
            self.text_preview.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::embeddings::EmbeddingEntry
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::embeddings::EmbeddingEntry>
    for crate::embeddings::EmbeddingEntry
{
    fn into_into_dart(self) -> crate::embeddings::EmbeddingEntry {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::graph::GraphEdge {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.source.into_into_dart().into_dart(),
            self.target.into_into_dart().into_dart(),
            self.weight.into_into_dart().into_dart(),
            self.edge_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::graph::GraphEdge {}
impl flutter_rust_bridge::IntoIntoDart<crate::graph::GraphEdge> for crate::graph::GraphEdge {
    fn into_into_dart(self) -> crate::graph::GraphEdge {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::graph::GraphNode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.node_type.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
            self.metadata.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::graph::GraphNode {}
impl flutter_rust_bridge::IntoIntoDart<crate::graph::GraphNode> for crate::graph::GraphNode {
    fn into_into_dart(self) -> crate::graph::GraphNode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::graph::GraphState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.nodes.into_into_dart().into_dart(),
            self.edges.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::graph::GraphState {}
impl flutter_rust_bridge::IntoIntoDart<crate::graph::GraphState> for crate::graph::GraphState {
    fn into_into_dart(self) -> crate::graph::GraphState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::KnowledgeGraphAnalysis {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.clustering.into_into_dart().into_dart(),
            self.semantic_edges.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::KnowledgeGraphAnalysis
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::KnowledgeGraphAnalysis>
    for crate::api::KnowledgeGraphAnalysis
{
    fn into_into_dart(self) -> crate::api::KnowledgeGraphAnalysis {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::mcp::MCPParamType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::String => 0.into_dart(),
            Self::Boolean => 1.into_dart(),
            Self::Integer => 2.into_dart(),
            Self::Array => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::mcp::MCPParamType {}
impl flutter_rust_bridge::IntoIntoDart<crate::mcp::MCPParamType> for crate::mcp::MCPParamType {
    fn into_into_dart(self) -> crate::mcp::MCPParamType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::mcp::MCPParameter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.param_type.into_into_dart().into_dart(),
            self.required.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::mcp::MCPParameter {}
impl flutter_rust_bridge::IntoIntoDart<crate::mcp::MCPParameter> for crate::mcp::MCPParameter {
    fn into_into_dart(self) -> crate::mcp::MCPParameter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::mcp::MCPTool {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ReadFile => 0.into_dart(),
            Self::WriteFile => 1.into_dart(),
            Self::DeleteFile => 2.into_dart(),
            Self::CreateFolder => 3.into_dart(),
            Self::ListFiles => 4.into_dart(),
            Self::CalendarLua => 5.into_dart(),
            Self::TimerLua => 6.into_dart(),
            Self::ExportMarkdown => 7.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::mcp::MCPTool {}
impl flutter_rust_bridge::IntoIntoDart<crate::mcp::MCPTool> for crate::mcp::MCPTool {
    fn into_into_dart(self) -> crate::mcp::MCPTool {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::mcp::MCPToolCall {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tool.into_into_dart().into_dart(),
            self.parameters_json.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::mcp::MCPToolCall {}
impl flutter_rust_bridge::IntoIntoDart<crate::mcp::MCPToolCall> for crate::mcp::MCPToolCall {
    fn into_into_dart(self) -> crate::mcp::MCPToolCall {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::mcp::MCPToolResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.result.into_into_dart().into_dart(),
            self.tool.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::mcp::MCPToolResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::mcp::MCPToolResult> for crate::mcp::MCPToolResult {
    fn into_into_dart(self) -> crate::mcp::MCPToolResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::streaming::NodePosition {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
            self.radius.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
            self.node_type.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::streaming::NodePosition
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::streaming::NodePosition>
    for crate::streaming::NodePosition
{
    fn into_into_dart(self) -> crate::streaming::NodePosition {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::clustering::SemanticEdge {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.source.into_into_dart().into_dart(),
            self.target.into_into_dart().into_dart(),
            self.similarity.into_into_dart().into_dart(),
            self.is_ghost.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::clustering::SemanticEdge
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::clustering::SemanticEdge>
    for crate::clustering::SemanticEdge
{
    fn into_into_dart(self) -> crate::clustering::SemanticEdge {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::clustering::SemanticEdgeResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.edges.into_into_dart().into_dart(),
            self.count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::clustering::SemanticEdgeResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::clustering::SemanticEdgeResult>
    for crate::clustering::SemanticEdgeResult
{
    fn into_into_dart(self) -> crate::clustering::SemanticEdgeResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::embeddings::SimilarityResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.score.into_into_dart().into_dart(),
            self.text_preview.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::embeddings::SimilarityResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::embeddings::SimilarityResult>
    for crate::embeddings::SimilarityResult
{
    fn into_into_dart(self) -> crate::embeddings::SimilarityResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::StreamGraphStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_count.into_into_dart().into_dart(),
            self.edge_count.into_into_dart().into_dart(),
            self.visible_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::StreamGraphStats {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::StreamGraphStats>
    for crate::api::StreamGraphStats
{
    fn into_into_dart(self) -> crate::api::StreamGraphStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::mcp::TaskCategory {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Conversation => 0.into_dart(),
            Self::ToolUse => 1.into_dart(),
            Self::CodeGeneration => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::mcp::TaskCategory {}
impl flutter_rust_bridge::IntoIntoDart<crate::mcp::TaskCategory> for crate::mcp::TaskCategory {
    fn into_into_dart(self) -> crate::mcp::TaskCategory {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::clustering::ClusterAssignment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <usize>::sse_encode(self.cluster_id, serializer);
        <String>::sse_encode(self.color, serializer);
    }
}

impl SseEncode for crate::clustering::ClusterInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.id, serializer);
        <usize>::sse_encode(self.size, serializer);
        <String>::sse_encode(self.color, serializer);
        <Option<Vec<f32>>>::sse_encode(self.centroid, serializer);
    }
}

impl SseEncode for crate::clustering::ClusteringResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::clustering::ClusterAssignment>>::sse_encode(self.assignments, serializer);
        <Vec<crate::clustering::ClusterInfo>>::sse_encode(self.clusters, serializer);
        <usize>::sse_encode(self.k, serializer);
    }
}

impl SseEncode for crate::api::EmbeddingCluster {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.ids, serializer);
    }
}

impl SseEncode for crate::embeddings::EmbeddingEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <Vec<f32>>::sse_encode(self.vector, serializer);
        <Option<String>>::sse_encode(self.text_preview, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::graph::GraphEdge {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.source, serializer);
        <String>::sse_encode(self.target, serializer);
        <f32>::sse_encode(self.weight, serializer);
        <String>::sse_encode(self.edge_type, serializer);
    }
}

impl SseEncode for crate::graph::GraphNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.label, serializer);
        <String>::sse_encode(self.node_type, serializer);
        <f32>::sse_encode(self.x, serializer);
        <f32>::sse_encode(self.y, serializer);
        <Option<String>>::sse_encode(self.color, serializer);
        <Option<String>>::sse_encode(self.metadata, serializer);
    }
}

impl SseEncode for crate::graph::GraphState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::graph::GraphNode>>::sse_encode(self.nodes, serializer);
        <Vec<crate::graph::GraphEdge>>::sse_encode(self.edges, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::KnowledgeGraphAnalysis {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::clustering::ClusteringResult>::sse_encode(self.clustering, serializer);
        <crate::clustering::SemanticEdgeResult>::sse_encode(self.semantic_edges, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::clustering::ClusterAssignment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::clustering::ClusterAssignment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::clustering::ClusterInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::clustering::ClusterInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::EmbeddingCluster> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::EmbeddingCluster>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::embeddings::EmbeddingEntry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::embeddings::EmbeddingEntry>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::graph::GraphEdge> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::graph::GraphEdge>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::graph::GraphNode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::graph::GraphNode>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::mcp::MCPParameter> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::mcp::MCPParameter>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::mcp::MCPTool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::mcp::MCPTool>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::streaming::NodePosition> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::streaming::NodePosition>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::clustering::SemanticEdge> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::clustering::SemanticEdge>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::embeddings::SimilarityResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::embeddings::SimilarityResult>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::mcp::MCPParamType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::mcp::MCPParamType::String => 0,
                crate::mcp::MCPParamType::Boolean => 1,
                crate::mcp::MCPParamType::Integer => 2,
                crate::mcp::MCPParamType::Array => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::mcp::MCPParameter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.description, serializer);
        <crate::mcp::MCPParamType>::sse_encode(self.param_type, serializer);
        <bool>::sse_encode(self.required, serializer);
    }
}

impl SseEncode for crate::mcp::MCPTool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::mcp::MCPTool::ReadFile => 0,
                crate::mcp::MCPTool::WriteFile => 1,
                crate::mcp::MCPTool::DeleteFile => 2,
                crate::mcp::MCPTool::CreateFolder => 3,
                crate::mcp::MCPTool::ListFiles => 4,
                crate::mcp::MCPTool::CalendarLua => 5,
                crate::mcp::MCPTool::TimerLua => 6,
                crate::mcp::MCPTool::ExportMarkdown => 7,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::mcp::MCPToolCall {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.tool, serializer);
        <String>::sse_encode(self.parameters_json, serializer);
        <String>::sse_encode(self.description, serializer);
    }
}

impl SseEncode for crate::mcp::MCPToolResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <String>::sse_encode(self.result, serializer);
        <String>::sse_encode(self.tool, serializer);
    }
}

impl SseEncode for crate::streaming::NodePosition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <f32>::sse_encode(self.x, serializer);
        <f32>::sse_encode(self.y, serializer);
        <f32>::sse_encode(self.radius, serializer);
        <u32>::sse_encode(self.color, serializer);
        <String>::sse_encode(self.node_type, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<f32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<f32>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<(String, String)>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<(String, String)>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::clustering::SemanticEdge {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.source, serializer);
        <String>::sse_encode(self.target, serializer);
        <f32>::sse_encode(self.similarity, serializer);
        <bool>::sse_encode(self.is_ghost, serializer);
    }
}

impl SseEncode for crate::clustering::SemanticEdgeResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::clustering::SemanticEdge>>::sse_encode(self.edges, serializer);
        <usize>::sse_encode(self.count, serializer);
    }
}

impl SseEncode for crate::embeddings::SimilarityResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <f32>::sse_encode(self.score, serializer);
        <Option<String>>::sse_encode(self.text_preview, serializer);
    }
}

impl SseEncode for crate::api::StreamGraphStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.node_count, serializer);
        <usize>::sse_encode(self.edge_count, serializer);
        <usize>::sse_encode(self.visible_count, serializer);
    }
}

impl SseEncode for crate::mcp::TaskCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::mcp::TaskCategory::Conversation => 0,
                crate::mcp::TaskCategory::ToolUse => 1,
                crate::mcp::TaskCategory::CodeGeneration => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<f32> for *mut f32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<i32> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::mcp::MCPToolCall> for *mut wire_cst_mcp_tool_call {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPToolCall {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::mcp::MCPToolCall>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<usize> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::clustering::ClusterAssignment> for wire_cst_cluster_assignment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::ClusterAssignment {
            crate::clustering::ClusterAssignment {
                id: self.id.cst_decode(),
                cluster_id: self.cluster_id.cst_decode(),
                color: self.color.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::clustering::ClusterInfo> for wire_cst_cluster_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::ClusterInfo {
            crate::clustering::ClusterInfo {
                id: self.id.cst_decode(),
                size: self.size.cst_decode(),
                color: self.color.cst_decode(),
                centroid: self.centroid.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::clustering::ClusteringResult> for wire_cst_clustering_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::ClusteringResult {
            crate::clustering::ClusteringResult {
                assignments: self.assignments.cst_decode(),
                clusters: self.clusters.cst_decode(),
                k: self.k.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::EmbeddingCluster> for wire_cst_embedding_cluster {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::EmbeddingCluster {
            crate::api::EmbeddingCluster {
                ids: self.ids.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::embeddings::EmbeddingEntry> for wire_cst_embedding_entry {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::embeddings::EmbeddingEntry {
            crate::embeddings::EmbeddingEntry {
                id: self.id.cst_decode(),
                vector: self.vector.cst_decode(),
                text_preview: self.text_preview.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graph::GraphEdge> for wire_cst_graph_edge {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graph::GraphEdge {
            crate::graph::GraphEdge {
                source: self.source.cst_decode(),
                target: self.target.cst_decode(),
                weight: self.weight.cst_decode(),
                edge_type: self.edge_type.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graph::GraphNode> for wire_cst_graph_node {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graph::GraphNode {
            crate::graph::GraphNode {
                id: self.id.cst_decode(),
                label: self.label.cst_decode(),
                node_type: self.node_type.cst_decode(),
                x: self.x.cst_decode(),
                y: self.y.cst_decode(),
                color: self.color.cst_decode(),
                metadata: self.metadata.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graph::GraphState> for wire_cst_graph_state {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graph::GraphState {
            crate::graph::GraphState {
                nodes: self.nodes.cst_decode(),
                edges: self.edges.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::KnowledgeGraphAnalysis> for wire_cst_knowledge_graph_analysis {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::KnowledgeGraphAnalysis {
            crate::api::KnowledgeGraphAnalysis {
                clustering: self.clustering.cst_decode(),
                semantic_edges: self.semantic_edges.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::clustering::ClusterAssignment>>
        for *mut wire_cst_list_cluster_assignment
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::clustering::ClusterAssignment> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::clustering::ClusterInfo>> for *mut wire_cst_list_cluster_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::clustering::ClusterInfo> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::EmbeddingCluster>> for *mut wire_cst_list_embedding_cluster {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::EmbeddingCluster> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>> for *mut wire_cst_list_embedding_entry {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::embeddings::EmbeddingEntry> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::graph::GraphEdge>> for *mut wire_cst_list_graph_edge {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::graph::GraphEdge> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::graph::GraphNode>> for *mut wire_cst_list_graph_node {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::graph::GraphNode> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::mcp::MCPParameter>> for *mut wire_cst_list_mcp_parameter {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::mcp::MCPParameter> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::mcp::MCPTool>> for *mut wire_cst_list_mcp_tool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::mcp::MCPTool> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::streaming::NodePosition>> for *mut wire_cst_list_node_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::streaming::NodePosition> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<f32>> for *mut wire_cst_list_prim_f_32_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f32> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<f32>> for *mut wire_cst_list_prim_f_32_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f32> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(String, String)>> for *mut wire_cst_list_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, String)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::clustering::SemanticEdge>> for *mut wire_cst_list_semantic_edge {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::clustering::SemanticEdge> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::embeddings::SimilarityResult>> for *mut wire_cst_list_similarity_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::embeddings::SimilarityResult> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::mcp::MCPParameter> for wire_cst_mcp_parameter {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPParameter {
            crate::mcp::MCPParameter {
                name: self.name.cst_decode(),
                description: self.description.cst_decode(),
                param_type: self.param_type.cst_decode(),
                required: self.required.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::mcp::MCPToolCall> for wire_cst_mcp_tool_call {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPToolCall {
            crate::mcp::MCPToolCall {
                tool: self.tool.cst_decode(),
                parameters_json: self.parameters_json.cst_decode(),
                description: self.description.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::mcp::MCPToolResult> for wire_cst_mcp_tool_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPToolResult {
            crate::mcp::MCPToolResult {
                success: self.success.cst_decode(),
                result: self.result.cst_decode(),
                tool: self.tool.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::streaming::NodePosition> for wire_cst_node_position {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::streaming::NodePosition {
            crate::streaming::NodePosition {
                id: self.id.cst_decode(),
                x: self.x.cst_decode(),
                y: self.y.cst_decode(),
                radius: self.radius.cst_decode(),
                color: self.color.cst_decode(),
                node_type: self.node_type.cst_decode(),
            }
        }
    }
    impl CstDecode<(String, String)> for wire_cst_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, String) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<crate::clustering::SemanticEdge> for wire_cst_semantic_edge {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::SemanticEdge {
            crate::clustering::SemanticEdge {
                source: self.source.cst_decode(),
                target: self.target.cst_decode(),
                similarity: self.similarity.cst_decode(),
                is_ghost: self.is_ghost.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::clustering::SemanticEdgeResult> for wire_cst_semantic_edge_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::SemanticEdgeResult {
            crate::clustering::SemanticEdgeResult {
                edges: self.edges.cst_decode(),
                count: self.count.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::embeddings::SimilarityResult> for wire_cst_similarity_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::embeddings::SimilarityResult {
            crate::embeddings::SimilarityResult {
                id: self.id.cst_decode(),
                score: self.score.cst_decode(),
                text_preview: self.text_preview.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::StreamGraphStats> for wire_cst_stream_graph_stats {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::StreamGraphStats {
            crate::api::StreamGraphStats {
                node_count: self.node_count.cst_decode(),
                edge_count: self.edge_count.cst_decode(),
                visible_count: self.visible_count.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_cluster_assignment {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                cluster_id: Default::default(),
                color: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_cluster_assignment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_cluster_info {
        fn new_with_null_ptr() -> Self {
            Self {
                id: Default::default(),
                size: Default::default(),
                color: core::ptr::null_mut(),
                centroid: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_cluster_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_clustering_result {
        fn new_with_null_ptr() -> Self {
            Self {
                assignments: core::ptr::null_mut(),
                clusters: core::ptr::null_mut(),
                k: Default::default(),
            }
        }
    }
    impl Default for wire_cst_clustering_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_embedding_cluster {
        fn new_with_null_ptr() -> Self {
            Self {
                ids: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_embedding_cluster {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_embedding_entry {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                vector: core::ptr::null_mut(),
                text_preview: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_embedding_entry {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_graph_edge {
        fn new_with_null_ptr() -> Self {
            Self {
                source: core::ptr::null_mut(),
                target: core::ptr::null_mut(),
                weight: Default::default(),
                edge_type: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_graph_edge {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_graph_node {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                label: core::ptr::null_mut(),
                node_type: core::ptr::null_mut(),
                x: Default::default(),
                y: Default::default(),
                color: core::ptr::null_mut(),
                metadata: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_graph_node {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_graph_state {
        fn new_with_null_ptr() -> Self {
            Self {
                nodes: core::ptr::null_mut(),
                edges: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_graph_state {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_knowledge_graph_analysis {
        fn new_with_null_ptr() -> Self {
            Self {
                clustering: Default::default(),
                semantic_edges: Default::default(),
            }
        }
    }
    impl Default for wire_cst_knowledge_graph_analysis {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_mcp_parameter {
        fn new_with_null_ptr() -> Self {
            Self {
                name: core::ptr::null_mut(),
                description: core::ptr::null_mut(),
                param_type: Default::default(),
                required: Default::default(),
            }
        }
    }
    impl Default for wire_cst_mcp_parameter {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_mcp_tool_call {
        fn new_with_null_ptr() -> Self {
            Self {
                tool: core::ptr::null_mut(),
                parameters_json: core::ptr::null_mut(),
                description: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_mcp_tool_call {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_mcp_tool_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                result: core::ptr::null_mut(),
                tool: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_mcp_tool_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_position {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                x: Default::default(),
                y: Default::default(),
                radius: Default::default(),
                color: Default::default(),
                node_type: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_position {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_string_string {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_string_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_semantic_edge {
        fn new_with_null_ptr() -> Self {
            Self {
                source: core::ptr::null_mut(),
                target: core::ptr::null_mut(),
                similarity: Default::default(),
                is_ghost: Default::default(),
            }
        }
    }
    impl Default for wire_cst_semantic_edge {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_semantic_edge_result {
        fn new_with_null_ptr() -> Self {
            Self {
                edges: core::ptr::null_mut(),
                count: Default::default(),
            }
        }
    }
    impl Default for wire_cst_semantic_edge_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_similarity_result {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                score: Default::default(),
                text_preview: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_similarity_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_stream_graph_stats {
        fn new_with_null_ptr() -> Self {
            Self {
                node_count: Default::default(),
                edge_count: Default::default(),
                visible_count: Default::default(),
            }
        }
    }
    impl Default for wire_cst_stream_graph_stats {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__add_graph_edge(
        port_: i64,
        source: *mut wire_cst_list_prim_u_8_strict,
        target: *mut wire_cst_list_prim_u_8_strict,
        weight: f32,
        edge_type: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__add_graph_edge_impl(port_, source, target, weight, edge_type)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__add_graph_edges(
        port_: i64,
        edges: *mut wire_cst_list_graph_edge,
    ) {
        wire__crate__api__add_graph_edges_impl(port_, edges)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__add_graph_node(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
        node_type: *mut wire_cst_list_prim_u_8_strict,
        x: f32,
        y: f32,
        color: *mut wire_cst_list_prim_u_8_strict,
        metadata: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__add_graph_node_impl(port_, id, label, node_type, x, y, color, metadata)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__add_graph_nodes(
        port_: i64,
        nodes: *mut wire_cst_list_graph_node,
    ) {
        wire__crate__api__add_graph_nodes_impl(port_, nodes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__add_stream_edge(
        port_: i64,
        from_id: *mut wire_cst_list_prim_u_8_strict,
        to_id: *mut wire_cst_list_prim_u_8_strict,
        strength: f32,
    ) {
        wire__crate__api__add_stream_edge_impl(port_, from_id, to_id, strength)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__add_stream_node(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        x: f32,
        y: f32,
        radius: f32,
        color: u32,
    ) {
        wire__crate__api__add_stream_node_impl(port_, id, x, y, radius, color)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__analyze_knowledge_graph(
        port_: i64,
        entries: *mut wire_cst_list_embedding_entry,
        k: *mut usize,
        similarity_threshold: *mut f32,
        existing_links: *mut wire_cst_list_record_string_string,
    ) {
        wire__crate__api__analyze_knowledge_graph_impl(
            port_,
            entries,
            k,
            similarity_threshold,
            existing_links,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__batch_embed(
        port_: i64,
        texts: *mut wire_cst_list_String,
    ) {
        wire__crate__api__batch_embed_impl(port_, texts)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__chat_completion(
        port_: i64,
        messages: *mut wire_cst_list_record_string_string,
        max_tokens: *mut u32,
    ) {
        wire__crate__api__chat_completion_impl(port_, messages, max_tokens)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__clear_graph(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__clear_graph_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__clear_stream_graph(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__clear_stream_graph_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__cluster_embeddings(
        port_: i64,
        entries: *mut wire_cst_list_embedding_entry,
        threshold: f32,
    ) {
        wire__crate__api__cluster_embeddings_impl(port_, entries, threshold)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__cluster_notes(
        port_: i64,
        entries: *mut wire_cst_list_embedding_entry,
        k: *mut usize,
        max_iterations: *mut usize,
    ) {
        wire__crate__api__cluster_notes_impl(port_, entries, k, max_iterations)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__compute_graph_layout(
        port_: i64,
        iterations: *mut u32,
    ) {
        wire__crate__api__compute_graph_layout_impl(port_, iterations)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__connect_note_to_topics(
        port_: i64,
        note_id: *mut wire_cst_list_prim_u_8_strict,
        topic_ids: *mut wire_cst_list_String,
    ) {
        wire__crate__api__connect_note_to_topics_impl(port_, note_id, topic_ids)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__cosine_similarity(
        a: *mut wire_cst_list_prim_f_32_loose,
        b: *mut wire_cst_list_prim_f_32_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__cosine_similarity_impl(a, b)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__discover_semantic_edges(
        port_: i64,
        entries: *mut wire_cst_list_embedding_entry,
        threshold: *mut f32,
        existing_links: *mut wire_cst_list_record_string_string,
    ) {
        wire__crate__api__discover_semantic_edges_impl(port_, entries, threshold, existing_links)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__extract_topics(
        port_: i64,
        text: *mut wire_cst_list_prim_u_8_strict,
        num_topics: *mut u32,
    ) {
        wire__crate__api__extract_topics_impl(port_, text, num_topics)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__find_similar(
        port_: i64,
        query: *mut wire_cst_list_prim_f_32_loose,
        entries: *mut wire_cst_list_embedding_entry,
        top_k: usize,
        threshold: f32,
    ) {
        wire__crate__api__find_similar_impl(port_, query, entries, top_k, threshold)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__generate_text(
        port_: i64,
        prompt: *mut wire_cst_list_prim_u_8_strict,
        max_tokens: *mut u32,
    ) {
        wire__crate__api__generate_text_impl(port_, prompt, max_tokens)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_embedding(
        port_: i64,
        text: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_embedding_impl(port_, text)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_embedding_dimension(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_embedding_dimension_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_graph_state(port_: i64) {
        wire__crate__api__get_graph_state_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_model_type(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_model_type_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_or_create_topic_hub(
        port_: i64,
        topic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__get_or_create_topic_hub_impl(port_, topic)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_stream_graph_stats(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_stream_graph_stats_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_version(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_version_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_visible_graph_nodes(port_: i64) {
        wire__crate__api__get_visible_graph_nodes_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__health_check(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__health_check_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__init_graph(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__init_graph_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__init_mcp(
        port_: i64,
        base_path: *mut wire_cst_list_prim_u_8_strict,
        max_file_size: *mut usize,
        allowed_extensions: *mut wire_cst_list_String,
    ) {
        wire__crate__api__init_mcp_impl(port_, base_path, max_file_size, allowed_extensions)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__init_model(
        model_path: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__init_model_impl(model_path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__init_model_with_config(
        port_: i64,
        model_path: *mut wire_cst_list_prim_u_8_strict,
        n_gpu_layers: u32,
        n_ctx: u32,
        n_threads: i32,
        temperature: f32,
        top_p: f32,
        max_tokens: u32,
        model_type: *mut i32,
    ) {
        wire__crate__api__init_model_with_config_impl(
            port_,
            model_path,
            n_gpu_layers,
            n_ctx,
            n_threads,
            temperature,
            top_p,
            max_tokens,
            model_type,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__is_graph_stream_running(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_graph_stream_running_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__is_mcp_initialized(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_mcp_initialized_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__is_model_loaded(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_model_loaded_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_classify_task(
        message: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_classify_task_impl(message)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_create_folder(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mcp_create_folder_impl(port_, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_delete_file(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mcp_delete_file_impl(port_, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_execute_tool_call(
        port_: i64,
        tool_call: *mut wire_cst_mcp_tool_call,
    ) {
        wire__crate__api__mcp_execute_tool_call_impl(port_, tool_call)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_get_all_tools(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_all_tools_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_get_model_for_task(
        category: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_model_for_task_impl(category)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_get_tool_description(
        tool: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_description_impl(tool)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_get_tool_name(
        tool: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_name_impl(tool)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_get_tool_parameters(
        tool: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_parameters_impl(tool)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_get_tool_schemas(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_schemas_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_list_files(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mcp_list_files_impl(port_, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_parse_tool_call(
        port_: i64,
        json: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mcp_parse_tool_call_impl(port_, json)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_read_file(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mcp_read_file_impl(port_, path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_validate_path(
        path: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_validate_path_impl(path)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mcp_write_file(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
        content: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__mcp_write_file_impl(port_, path, content)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__pin_stream_node(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        pinned: bool,
    ) {
        wire__crate__api__pin_stream_node_impl(port_, id, pinned)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__remove_graph_node(
        port_: i64,
        node_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__remove_graph_node_impl(port_, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__remove_stream_edge(
        port_: i64,
        from_id: *mut wire_cst_list_prim_u_8_strict,
        to_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__remove_stream_edge_impl(port_, from_id, to_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__remove_stream_node(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__remove_stream_node_impl(port_, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__semantic_search(
        port_: i64,
        query_text: *mut wire_cst_list_prim_u_8_strict,
        entries: *mut wire_cst_list_embedding_entry,
        top_k: usize,
    ) {
        wire__crate__api__semantic_search_impl(port_, query_text, entries, top_k)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__set_stream_node_position(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        x: f32,
        y: f32,
    ) {
        wire__crate__api__set_stream_node_position_impl(port_, id, x, y)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__start_graph_stream(port_: i64) {
        wire__crate__api__start_graph_stream_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__stop_graph_stream(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__stop_graph_stream_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__unload_model(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__unload_model_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__update_graph_viewport(
        port_: i64,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        scale: f32,
    ) {
        wire__crate__api__update_graph_viewport_impl(port_, x, y, width, height, scale)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_f_32(value: f32) -> *mut f32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_i_32(value: i32) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_mcp_tool_call(
    ) -> *mut wire_cst_mcp_tool_call {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_mcp_tool_call::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_usize(value: usize) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_String(len: i32) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_cluster_assignment(
        len: i32,
    ) -> *mut wire_cst_list_cluster_assignment {
        let wrap = wire_cst_list_cluster_assignment {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_cluster_assignment>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_cluster_info(
        len: i32,
    ) -> *mut wire_cst_list_cluster_info {
        let wrap = wire_cst_list_cluster_info {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_cluster_info>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_embedding_cluster(
        len: i32,
    ) -> *mut wire_cst_list_embedding_cluster {
        let wrap = wire_cst_list_embedding_cluster {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_embedding_cluster>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_embedding_entry(
        len: i32,
    ) -> *mut wire_cst_list_embedding_entry {
        let wrap = wire_cst_list_embedding_entry {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_embedding_entry>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_graph_edge(
        len: i32,
    ) -> *mut wire_cst_list_graph_edge {
        let wrap = wire_cst_list_graph_edge {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_graph_edge>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_graph_node(
        len: i32,
    ) -> *mut wire_cst_list_graph_node {
        let wrap = wire_cst_list_graph_node {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_graph_node>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_mcp_parameter(
        len: i32,
    ) -> *mut wire_cst_list_mcp_parameter {
        let wrap = wire_cst_list_mcp_parameter {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_mcp_parameter>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_mcp_tool(len: i32) -> *mut wire_cst_list_mcp_tool {
        let wrap = wire_cst_list_mcp_tool {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_node_position(
        len: i32,
    ) -> *mut wire_cst_list_node_position {
        let wrap = wire_cst_list_node_position {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_node_position>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_f_32_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_f_32_loose {
        let ans = wire_cst_list_prim_f_32_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_f_32_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_f_32_strict {
        let ans = wire_cst_list_prim_f_32_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_record_string_string(
        len: i32,
    ) -> *mut wire_cst_list_record_string_string {
        let wrap = wire_cst_list_record_string_string {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_string>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_semantic_edge(
        len: i32,
    ) -> *mut wire_cst_list_semantic_edge {
        let wrap = wire_cst_list_semantic_edge {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_semantic_edge>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_similarity_result(
        len: i32,
    ) -> *mut wire_cst_list_similarity_result {
        let wrap = wire_cst_list_similarity_result {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_similarity_result>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_cluster_assignment {
        id: *mut wire_cst_list_prim_u_8_strict,
        cluster_id: usize,
        color: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_cluster_info {
        id: usize,
        size: usize,
        color: *mut wire_cst_list_prim_u_8_strict,
        centroid: *mut wire_cst_list_prim_f_32_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_clustering_result {
        assignments: *mut wire_cst_list_cluster_assignment,
        clusters: *mut wire_cst_list_cluster_info,
        k: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_embedding_cluster {
        ids: *mut wire_cst_list_String,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_embedding_entry {
        id: *mut wire_cst_list_prim_u_8_strict,
        vector: *mut wire_cst_list_prim_f_32_strict,
        text_preview: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_graph_edge {
        source: *mut wire_cst_list_prim_u_8_strict,
        target: *mut wire_cst_list_prim_u_8_strict,
        weight: f32,
        edge_type: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_graph_node {
        id: *mut wire_cst_list_prim_u_8_strict,
        label: *mut wire_cst_list_prim_u_8_strict,
        node_type: *mut wire_cst_list_prim_u_8_strict,
        x: f32,
        y: f32,
        color: *mut wire_cst_list_prim_u_8_strict,
        metadata: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_graph_state {
        nodes: *mut wire_cst_list_graph_node,
        edges: *mut wire_cst_list_graph_edge,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_knowledge_graph_analysis {
        clustering: wire_cst_clustering_result,
        semantic_edges: wire_cst_semantic_edge_result,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_cluster_assignment {
        ptr: *mut wire_cst_cluster_assignment,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_cluster_info {
        ptr: *mut wire_cst_cluster_info,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_embedding_cluster {
        ptr: *mut wire_cst_embedding_cluster,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_embedding_entry {
        ptr: *mut wire_cst_embedding_entry,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_graph_edge {
        ptr: *mut wire_cst_graph_edge,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_graph_node {
        ptr: *mut wire_cst_graph_node,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_mcp_parameter {
        ptr: *mut wire_cst_mcp_parameter,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_mcp_tool {
        ptr: *mut i32,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_node_position {
        ptr: *mut wire_cst_node_position,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_f_32_loose {
        ptr: *mut f32,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_f_32_strict {
        ptr: *mut f32,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_string {
        ptr: *mut wire_cst_record_string_string,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_semantic_edge {
        ptr: *mut wire_cst_semantic_edge,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_similarity_result {
        ptr: *mut wire_cst_similarity_result,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_mcp_parameter {
        name: *mut wire_cst_list_prim_u_8_strict,
        description: *mut wire_cst_list_prim_u_8_strict,
        param_type: i32,
        required: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_mcp_tool_call {
        tool: *mut wire_cst_list_prim_u_8_strict,
        parameters_json: *mut wire_cst_list_prim_u_8_strict,
        description: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_mcp_tool_result {
        success: bool,
        result: *mut wire_cst_list_prim_u_8_strict,
        tool: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_position {
        id: *mut wire_cst_list_prim_u_8_strict,
        x: f32,
        y: f32,
        radius: f32,
        color: u32,
        node_type: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_string {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_semantic_edge {
        source: *mut wire_cst_list_prim_u_8_strict,
        target: *mut wire_cst_list_prim_u_8_strict,
        similarity: f32,
        is_ghost: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_semantic_edge_result {
        edges: *mut wire_cst_list_semantic_edge,
        count: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_similarity_result {
        id: *mut wire_cst_list_prim_u_8_strict,
        score: f32,
        text_preview: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_stream_graph_stats {
        node_count: usize,
        edge_count: usize,
        visible_count: usize,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<crate::clustering::ClusterAssignment>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::ClusterAssignment {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::clustering::ClusterAssignment {
                id: self_.get(0).cst_decode(),
                cluster_id: self_.get(1).cst_decode(),
                color: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::clustering::ClusterInfo>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::ClusterInfo {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::clustering::ClusterInfo {
                id: self_.get(0).cst_decode(),
                size: self_.get(1).cst_decode(),
                color: self_.get(2).cst_decode(),
                centroid: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::clustering::ClusteringResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::ClusteringResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::clustering::ClusteringResult {
                assignments: self_.get(0).cst_decode(),
                clusters: self_.get(1).cst_decode(),
                k: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::EmbeddingCluster>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::EmbeddingCluster {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            crate::api::EmbeddingCluster {
                ids: self_.get(0).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::embeddings::EmbeddingEntry>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::embeddings::EmbeddingEntry {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::embeddings::EmbeddingEntry {
                id: self_.get(0).cst_decode(),
                vector: self_.get(1).cst_decode(),
                text_preview: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graph::GraphEdge>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graph::GraphEdge {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::graph::GraphEdge {
                source: self_.get(0).cst_decode(),
                target: self_.get(1).cst_decode(),
                weight: self_.get(2).cst_decode(),
                edge_type: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graph::GraphNode>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graph::GraphNode {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::graph::GraphNode {
                id: self_.get(0).cst_decode(),
                label: self_.get(1).cst_decode(),
                node_type: self_.get(2).cst_decode(),
                x: self_.get(3).cst_decode(),
                y: self_.get(4).cst_decode(),
                color: self_.get(5).cst_decode(),
                metadata: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graph::GraphState>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graph::GraphState {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::graph::GraphState {
                nodes: self_.get(0).cst_decode(),
                edges: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::KnowledgeGraphAnalysis>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::KnowledgeGraphAnalysis {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::KnowledgeGraphAnalysis {
                clustering: self_.get(0).cst_decode(),
                semantic_edges: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<String>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::clustering::ClusterAssignment>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::clustering::ClusterAssignment> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::clustering::ClusterInfo>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::clustering::ClusterInfo> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::api::EmbeddingCluster>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::EmbeddingCluster> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::embeddings::EmbeddingEntry>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::embeddings::EmbeddingEntry> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::graph::GraphEdge>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::graph::GraphEdge> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::graph::GraphNode>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::graph::GraphNode> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::mcp::MCPParameter>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::mcp::MCPParameter> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::mcp::MCPTool>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::mcp::MCPTool> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::streaming::NodePosition>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::streaming::NodePosition> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<f32>> for Box<[f32]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f32> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<(String, String)>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, String)> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::clustering::SemanticEdge>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::clustering::SemanticEdge> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::embeddings::SimilarityResult>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::embeddings::SimilarityResult> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<crate::mcp::MCPParameter>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPParameter {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::mcp::MCPParameter {
                name: self_.get(0).cst_decode(),
                description: self_.get(1).cst_decode(),
                param_type: self_.get(2).cst_decode(),
                required: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::mcp::MCPToolCall>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPToolCall {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::mcp::MCPToolCall {
                tool: self_.get(0).cst_decode(),
                parameters_json: self_.get(1).cst_decode(),
                description: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::mcp::MCPToolResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPToolResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::mcp::MCPToolResult {
                success: self_.get(0).cst_decode(),
                result: self_.get(1).cst_decode(),
                tool: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::streaming::NodePosition>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::streaming::NodePosition {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::streaming::NodePosition {
                id: self_.get(0).cst_decode(),
                x: self_.get(1).cst_decode(),
                y: self_.get(2).cst_decode(),
                radius: self_.get(3).cst_decode(),
                color: self_.get(4).cst_decode(),
                node_type: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<Option<String>> for Option<String> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<String> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<Option<Vec<f32>>> for Option<Box<[f32]>> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<Vec<f32>> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<(String, String)> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, String) {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            (self_.get(0).cst_decode(), self_.get(1).cst_decode())
        }
    }
    impl CstDecode<crate::clustering::SemanticEdge>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::SemanticEdge {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::clustering::SemanticEdge {
                source: self_.get(0).cst_decode(),
                target: self_.get(1).cst_decode(),
                similarity: self_.get(2).cst_decode(),
                is_ghost: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::clustering::SemanticEdgeResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::clustering::SemanticEdgeResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::clustering::SemanticEdgeResult {
                edges: self_.get(0).cst_decode(),
                count: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::embeddings::SimilarityResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::embeddings::SimilarityResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::embeddings::SimilarityResult {
                id: self_.get(0).cst_decode(),
                score: self_.get(1).cst_decode(),
                text_preview: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::StreamGraphStats>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::StreamGraphStats {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::api::StreamGraphStats {
                node_count: self_.get(0).cst_decode(),
                edge_count: self_.get(1).cst_decode(),
                visible_count: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<f32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<Vec<f32>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f32> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Float32Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<crate::mcp::MCPParamType>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPParamType {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::mcp::MCPTool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::MCPTool {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::mcp::TaskCategory>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::mcp::TaskCategory {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_graph_edge(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        source: String,
        target: String,
        weight: f32,
        edge_type: String,
    ) {
        wire__crate__api__add_graph_edge_impl(port_, source, target, weight, edge_type)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_graph_edges(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        edges: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__add_graph_edges_impl(port_, edges)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_graph_node(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        label: String,
        node_type: String,
        x: f32,
        y: f32,
        color: Option<String>,
        metadata: Option<String>,
    ) {
        wire__crate__api__add_graph_node_impl(port_, id, label, node_type, x, y, color, metadata)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_graph_nodes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        nodes: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__add_graph_nodes_impl(port_, nodes)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_stream_edge(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        from_id: String,
        to_id: String,
        strength: f32,
    ) {
        wire__crate__api__add_stream_edge_impl(port_, from_id, to_id, strength)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__add_stream_node(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        x: f32,
        y: f32,
        radius: f32,
        color: u32,
    ) {
        wire__crate__api__add_stream_node_impl(port_, id, x, y, radius, color)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__analyze_knowledge_graph(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        entries: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        k: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        similarity_threshold: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        existing_links: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__analyze_knowledge_graph_impl(
            port_,
            entries,
            k,
            similarity_threshold,
            existing_links,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__batch_embed(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        texts: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__batch_embed_impl(port_, texts)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chat_completion(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        messages: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        max_tokens: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__chat_completion_impl(port_, messages, max_tokens)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__clear_graph(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__clear_graph_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__clear_stream_graph(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__clear_stream_graph_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__cluster_embeddings(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        entries: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        threshold: f32,
    ) {
        wire__crate__api__cluster_embeddings_impl(port_, entries, threshold)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__cluster_notes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        entries: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        k: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        max_iterations: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__cluster_notes_impl(port_, entries, k, max_iterations)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__compute_graph_layout(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        iterations: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__compute_graph_layout_impl(port_, iterations)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__connect_note_to_topics(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        note_id: String,
        topic_ids: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__connect_note_to_topics_impl(port_, note_id, topic_ids)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__cosine_similarity(
        a: Box<[f32]>,
        b: Box<[f32]>,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__cosine_similarity_impl(a, b)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__discover_semantic_edges(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        entries: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        threshold: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        existing_links: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__discover_semantic_edges_impl(port_, entries, threshold, existing_links)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__extract_topics(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        text: String,
        num_topics: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__extract_topics_impl(port_, text, num_topics)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__find_similar(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        query: Box<[f32]>,
        entries: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        top_k: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        threshold: f32,
    ) {
        wire__crate__api__find_similar_impl(port_, query, entries, top_k, threshold)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__generate_text(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        prompt: String,
        max_tokens: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__generate_text_impl(port_, prompt, max_tokens)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_embedding(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        text: String,
    ) {
        wire__crate__api__get_embedding_impl(port_, text)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_embedding_dimension(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_embedding_dimension_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_graph_state(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_graph_state_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_model_type(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_model_type_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_or_create_topic_hub(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        topic: String,
    ) {
        wire__crate__api__get_or_create_topic_hub_impl(port_, topic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_stream_graph_stats(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_stream_graph_stats_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_version(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_version_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_visible_graph_nodes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__get_visible_graph_nodes_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__health_check(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__health_check_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__init_graph() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco
    {
        wire__crate__api__init_graph_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__init_mcp(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        base_path: String,
        max_file_size: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        allowed_extensions: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__init_mcp_impl(port_, base_path, max_file_size, allowed_extensions)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__init_model(
        model_path: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__init_model_impl(model_path)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__init_model_with_config(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        model_path: String,
        n_gpu_layers: u32,
        n_ctx: u32,
        n_threads: i32,
        temperature: f32,
        top_p: f32,
        max_tokens: u32,
        model_type: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__init_model_with_config_impl(
            port_,
            model_path,
            n_gpu_layers,
            n_ctx,
            n_threads,
            temperature,
            top_p,
            max_tokens,
            model_type,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_graph_stream_running(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_graph_stream_running_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_mcp_initialized(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_mcp_initialized_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_model_loaded(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_model_loaded_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_classify_task(
        message: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_classify_task_impl(message)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_create_folder(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        path: String,
    ) {
        wire__crate__api__mcp_create_folder_impl(port_, path)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_delete_file(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        path: String,
    ) {
        wire__crate__api__mcp_delete_file_impl(port_, path)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_execute_tool_call(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        tool_call: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__mcp_execute_tool_call_impl(port_, tool_call)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_get_all_tools(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_all_tools_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_get_model_for_task(
        category: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_model_for_task_impl(category)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_get_tool_description(
        tool: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_description_impl(tool)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_get_tool_name(
        tool: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_name_impl(tool)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_get_tool_parameters(
        tool: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_parameters_impl(tool)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_get_tool_schemas(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_get_tool_schemas_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_list_files(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        path: String,
    ) {
        wire__crate__api__mcp_list_files_impl(port_, path)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_parse_tool_call(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        json: String,
    ) {
        wire__crate__api__mcp_parse_tool_call_impl(port_, json)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_read_file(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        path: String,
    ) {
        wire__crate__api__mcp_read_file_impl(port_, path)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_validate_path(
        path: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mcp_validate_path_impl(path)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mcp_write_file(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        path: String,
        content: String,
    ) {
        wire__crate__api__mcp_write_file_impl(port_, path, content)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__pin_stream_node(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        pinned: bool,
    ) {
        wire__crate__api__pin_stream_node_impl(port_, id, pinned)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__remove_graph_node(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        node_id: String,
    ) {
        wire__crate__api__remove_graph_node_impl(port_, node_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__remove_stream_edge(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        from_id: String,
        to_id: String,
    ) {
        wire__crate__api__remove_stream_edge_impl(port_, from_id, to_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__remove_stream_node(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
    ) {
        wire__crate__api__remove_stream_node_impl(port_, id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__semantic_search(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        query_text: String,
        entries: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        top_k: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__semantic_search_impl(port_, query_text, entries, top_k)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__set_stream_node_position(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        x: f32,
        y: f32,
    ) {
        wire__crate__api__set_stream_node_position_impl(port_, id, x, y)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__start_graph_stream(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__start_graph_stream_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__stop_graph_stream(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__stop_graph_stream_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__unload_model(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__unload_model_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__update_graph_viewport(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        scale: f32,
    ) {
        wire__crate__api__update_graph_viewport_impl(port_, x, y, width, height, scale)
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
