// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kivixa/src/rust_audio/frb_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`

/// Write raw PCM bytes to the audio buffer
///
/// # Arguments
/// * `bytes` - Raw PCM 16-bit little-endian audio bytes
///
/// # Returns
/// Number of samples written
BigInt audioBufferWriteBytes({required List<int> bytes}) =>
    AudioRustLib.instance.api.crateApiAudioBufferWriteBytes(bytes: bytes);

/// Write f32 samples to the audio buffer
///
/// # Arguments
/// * `samples` - Normalized f32 audio samples (-1.0 to 1.0)
///
/// # Returns
/// Number of samples written
BigInt audioBufferWriteSamples({required List<double> samples}) =>
    AudioRustLib.instance.api.crateApiAudioBufferWriteSamples(samples: samples);

/// Write i16 samples to the audio buffer
///
/// # Arguments
/// * `samples` - PCM i16 audio samples
///
/// # Returns
/// Number of samples written
BigInt audioBufferWriteI16({required List<int> samples}) =>
    AudioRustLib.instance.api.crateApiAudioBufferWriteI16(samples: samples);

/// Read all available samples from the buffer
///
/// # Returns
/// Vector of f32 samples
Float32List audioBufferReadAll() =>
    AudioRustLib.instance.api.crateApiAudioBufferReadAll();

/// Read a specific number of samples
///
/// # Arguments
/// * `count` - Number of samples to read
///
/// # Returns
/// Vector of f32 samples (may be shorter if not enough available)
Float32List audioBufferRead({required BigInt count}) =>
    AudioRustLib.instance.api.crateApiAudioBufferRead(count: count);

/// Get the number of available samples
BigInt audioBufferAvailable() =>
    AudioRustLib.instance.api.crateApiAudioBufferAvailable();

/// Get available audio duration in seconds
double audioBufferAvailableDuration() =>
    AudioRustLib.instance.api.crateApiAudioBufferAvailableDuration();

/// Check if we have enough data for a full processing chunk
bool audioBufferHasFullChunk() =>
    AudioRustLib.instance.api.crateApiAudioBufferHasFullChunk();

/// Clear the audio buffer
void audioBufferClear() => AudioRustLib.instance.api.crateApiAudioBufferClear();

/// Get the Whisper sample rate (16000 Hz)
int getWhisperSampleRate() =>
    AudioRustLib.instance.api.crateApiGetWhisperSampleRate();

/// Process audio samples through VAD
///
/// # Arguments
/// * `samples` - Audio samples (f32, normalized)
///
/// # Returns
/// VAD result with speech detection state
DartVadResult vadProcess({required List<double> samples}) =>
    AudioRustLib.instance.api.crateApiVadProcess(samples: samples);

/// Check if VAD currently detects speech
bool vadIsSpeech() => AudioRustLib.instance.api.crateApiVadIsSpeech();

/// Get VAD current state
int vadCurrentState() => AudioRustLib.instance.api.crateApiVadCurrentState();

/// Set VAD speech detection threshold
void vadSetThreshold({required double threshold}) =>
    AudioRustLib.instance.api.crateApiVadSetThreshold(threshold: threshold);

/// Reset VAD state
void vadReset() => AudioRustLib.instance.api.crateApiVadReset();

/// Initialize the STT engine
Future<void> sttInitialize() =>
    AudioRustLib.instance.api.crateApiSttInitialize();

/// Check if STT engine is ready
bool sttIsReady() => AudioRustLib.instance.api.crateApiSttIsReady();

/// Get STT engine state
int sttState() => AudioRustLib.instance.api.crateApiSttState();

/// Process audio samples for transcription
///
/// # Arguments
/// * `samples` - Audio samples (f32, 16kHz)
/// * `start_time` - Start time in seconds relative to recording start
///
/// # Returns
/// Transcription result
Future<DartTranscription> sttProcess({
  required List<double> samples,
  required double startTime,
}) => AudioRustLib.instance.api.crateApiSttProcess(
  samples: samples,
  startTime: startTime,
);

/// Process the global audio buffer
///
/// Reads available samples from the global buffer and transcribes them.
///
/// # Arguments
/// * `start_time` - Start time in seconds
Future<DartTranscription> sttProcessBuffer({required double startTime}) =>
    AudioRustLib.instance.api.crateApiSttProcessBuffer(startTime: startTime);

/// Reset STT engine state
void sttReset() => AudioRustLib.instance.api.crateApiSttReset();

/// Get available Whisper models
List<String> sttAvailableModels() =>
    AudioRustLib.instance.api.crateApiSttAvailableModels();

/// Get model size in bytes
BigInt sttModelSize({required String modelName}) =>
    AudioRustLib.instance.api.crateApiSttModelSize(modelName: modelName);

/// Initialize the TTS engine
Future<void> ttsInitialize() =>
    AudioRustLib.instance.api.crateApiTtsInitialize();

/// Check if TTS engine is ready
bool ttsIsReady() => AudioRustLib.instance.api.crateApiTtsIsReady();

/// Get TTS engine state
int ttsState() => AudioRustLib.instance.api.crateApiTtsState();

/// Synthesize speech from text
///
/// # Arguments
/// * `text` - The text to synthesize
///
/// # Returns
/// Synthesized audio samples and metadata
Future<DartSynthesizedAudio> ttsSynthesize({required String text}) =>
    AudioRustLib.instance.api.crateApiTtsSynthesize(text: text);

/// Synthesize speech with a specific voice
///
/// # Arguments
/// * `text` - The text to synthesize
/// * `voice_id` - The voice identifier
Future<DartSynthesizedAudio> ttsSynthesizeWithVoice({
  required String text,
  required String voiceId,
}) => AudioRustLib.instance.api.crateApiTtsSynthesizeWithVoice(
  text: text,
  voiceId: voiceId,
);

/// Get available voices
List<DartVoiceStyle> ttsAvailableVoices() =>
    AudioRustLib.instance.api.crateApiTtsAvailableVoices();

/// Get synthesized audio as PCM bytes (16-bit LE)
Future<Uint8List> ttsSynthesizeToBytes({required String text}) =>
    AudioRustLib.instance.api.crateApiTtsSynthesizeToBytes(text: text);

/// Get synthesized audio as i16 samples
Future<Int16List> ttsSynthesizeToI16({required String text}) =>
    AudioRustLib.instance.api.crateApiTtsSynthesizeToI16(text: text);

/// Process streaming audio with VAD and optional STT
///
/// This is the main entry point for real-time audio processing.
/// It handles VAD first, then only processes STT when speech is detected.
///
/// # Arguments
/// * `bytes` - Raw PCM 16-bit LE audio bytes
/// * `start_time` - Current timestamp in the recording
/// * `force_transcribe` - If true, force transcription even without speech detection
Future<StreamingResult> processStreamingAudio({
  required List<int> bytes,
  required double startTime,
  required bool forceTranscribe,
}) => AudioRustLib.instance.api.crateApiProcessStreamingAudio(
  bytes: bytes,
  startTime: startTime,
  forceTranscribe: forceTranscribe,
);

/// Get the audio module version
String audioModuleVersion() =>
    AudioRustLib.instance.api.crateApiAudioModuleVersion();

/// Check if the audio module is operational
bool audioModuleHealthCheck() =>
    AudioRustLib.instance.api.crateApiAudioModuleHealthCheck();

/// Initialize all audio subsystems
Future<void> audioInitializeAll() =>
    AudioRustLib.instance.api.crateApiAudioInitializeAll();

/// Reset all audio subsystems
void audioResetAll() => AudioRustLib.instance.api.crateApiAudioResetAll();

/// Synthesized audio result for Dart
class DartSynthesizedAudio {
  /// Audio samples (f32, normalized)
  final Float32List samples;

  /// Sample rate
  final int sampleRate;

  /// Duration in seconds
  final double duration;

  const DartSynthesizedAudio({
    required this.samples,
    required this.sampleRate,
    required this.duration,
  });

  @override
  int get hashCode =>
      samples.hashCode ^ sampleRate.hashCode ^ duration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartSynthesizedAudio &&
          runtimeType == other.runtimeType &&
          samples == other.samples &&
          sampleRate == other.sampleRate &&
          duration == other.duration;
}

/// Full transcription result for Dart
class DartTranscription {
  final List<DartTranscriptionSegment> segments;
  final String? language;
  final double duration;
  final BigInt processingTimeMs;
  final String fullText;

  const DartTranscription({
    required this.segments,
    this.language,
    required this.duration,
    required this.processingTimeMs,
    required this.fullText,
  });

  @override
  int get hashCode =>
      segments.hashCode ^
      language.hashCode ^
      duration.hashCode ^
      processingTimeMs.hashCode ^
      fullText.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartTranscription &&
          runtimeType == other.runtimeType &&
          segments == other.segments &&
          language == other.language &&
          duration == other.duration &&
          processingTimeMs == other.processingTimeMs &&
          fullText == other.fullText;
}

/// Transcription segment for Dart
class DartTranscriptionSegment {
  final int id;
  final String text;
  final double startTime;
  final double endTime;
  final String? language;
  final double confidence;
  final bool isFinal;

  const DartTranscriptionSegment({
    required this.id,
    required this.text,
    required this.startTime,
    required this.endTime,
    this.language,
    required this.confidence,
    required this.isFinal,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      text.hashCode ^
      startTime.hashCode ^
      endTime.hashCode ^
      language.hashCode ^
      confidence.hashCode ^
      isFinal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartTranscriptionSegment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          text == other.text &&
          startTime == other.startTime &&
          endTime == other.endTime &&
          language == other.language &&
          confidence == other.confidence &&
          isFinal == other.isFinal;
}

/// VAD result returned to Dart
class DartVadResult {
  /// Current state (0=Silence, 1=SpeechPending, 2=Speech, 3=SilencePending)
  final int state;

  /// Speech probability (0.0 to 1.0)
  final double speechProbability;

  /// Whether speech is currently active
  final bool isSpeech;

  /// Duration of current state in seconds
  final double stateDuration;

  const DartVadResult({
    required this.state,
    required this.speechProbability,
    required this.isSpeech,
    required this.stateDuration,
  });

  @override
  int get hashCode =>
      state.hashCode ^
      speechProbability.hashCode ^
      isSpeech.hashCode ^
      stateDuration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartVadResult &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          speechProbability == other.speechProbability &&
          isSpeech == other.isSpeech &&
          stateDuration == other.stateDuration;
}

/// Voice style for Dart
class DartVoiceStyle {
  final String id;
  final String name;
  final String description;
  final double rate;
  final double pitch;

  const DartVoiceStyle({
    required this.id,
    required this.name,
    required this.description,
    required this.rate,
    required this.pitch,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      description.hashCode ^
      rate.hashCode ^
      pitch.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartVoiceStyle &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          description == other.description &&
          rate == other.rate &&
          pitch == other.pitch;
}

/// Streaming audio processing result
class StreamingResult {
  /// VAD result
  final DartVadResult vad;

  /// Whether transcription was attempted
  final bool transcriptionAttempted;

  /// Transcription result (if attempted)
  final DartTranscription? transcription;

  const StreamingResult({
    required this.vad,
    required this.transcriptionAttempted,
    this.transcription,
  });

  @override
  int get hashCode =>
      vad.hashCode ^ transcriptionAttempted.hashCode ^ transcription.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StreamingResult &&
          runtimeType == other.runtimeType &&
          vad == other.vad &&
          transcriptionAttempted == other.transcriptionAttempted &&
          transcription == other.transcription;
}
