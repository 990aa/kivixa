// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kivixa/src/rust_math/basic.dart';
import 'package:kivixa/src/rust_math/calculus.dart';
import 'package:kivixa/src/rust_math/complex.dart';
import 'package:kivixa/src/rust_math/discrete.dart';
import 'package:kivixa/src/rust_math/frb_generated.dart';
import 'package:kivixa/src/rust_math/graphing.dart';
import 'package:kivixa/src/rust_math/matrix.dart';
import 'package:kivixa/src/rust_math/statistics.dart';
import 'package:kivixa/src/rust_math/units.dart';

// These functions are ignored because they are not marked as `pub`: `base_to_number_system`

/// Evaluate a mathematical expression string
/// Supports: +, -, *, /, ^, sqrt, sin, cos, tan, log, ln, abs, etc.
ExpressionResult evaluateExpression({required String expression}) =>
    MathRustLib.instance.api.crateApiEvaluateExpression(expression: expression);

/// Convert between number systems (binary, octal, decimal, hex)
/// from_base and to_base: 2 = binary, 8 = octal, 10 = decimal, 16 = hex
String convertNumberSystem({
  required String value,
  required int fromBase,
  required int toBase,
}) => MathRustLib.instance.api.crateApiConvertNumberSystem(
  value: value,
  fromBase: fromBase,
  toBase: toBase,
);

/// Get mathematical constants
double getConstant({required String name}) =>
    MathRustLib.instance.api.crateApiGetConstant(name: name);

/// Perform complex number operations
ComplexResult complexOperation({
  required double aReal,
  required double aImag,
  required double bReal,
  required double bImag,
  required String operation,
}) => MathRustLib.instance.api.crateApiComplexOperation(
  aReal: aReal,
  aImag: aImag,
  bReal: bReal,
  bImag: bImag,
  operation: operation,
);

/// Convert complex number between rectangular and polar forms
ComplexResult complexConvert({
  required double real,
  required double imag,
  required bool toPolar,
}) => MathRustLib.instance.api.crateApiComplexConvert(
  real: real,
  imag: imag,
  toPolar: toPolar,
);

/// Perform matrix operations (add, multiply, transpose, inverse, etc.)
/// Matrix data is passed as a flat array with dimensions
Future<MatrixResult> matrixOperation({
  required List<double> aData,
  required BigInt aRows,
  required BigInt aCols,
  Float64List? bData,
  BigInt? bRows,
  BigInt? bCols,
  required String operation,
}) => MathRustLib.instance.api.crateApiMatrixOperation(
  aData: aData,
  aRows: aRows,
  aCols: aCols,
  bData: bData,
  bRows: bRows,
  bCols: bCols,
  operation: operation,
);

/// Compute matrix decompositions (LU, QR, SVD, Cholesky, Eigen)
Future<MatrixDecomposition> matrixDecomposition({
  required List<double> data,
  required BigInt rows,
  required BigInt cols,
  required String decompositionType,
}) => MathRustLib.instance.api.crateApiMatrixDecomposition(
  data: data,
  rows: rows,
  cols: cols,
  decompositionType: decompositionType,
);

/// Compute matrix properties (determinant, rank, trace, eigenvalues)
Future<MatrixResult> matrixProperties({
  required List<double> data,
  required BigInt rows,
  required BigInt cols,
}) => MathRustLib.instance.api.crateApiMatrixProperties(
  data: data,
  rows: rows,
  cols: cols,
);

/// Row reduce matrix to echelon form (RREF)
Future<MatrixResult> matrixRref({
  required List<double> data,
  required BigInt rows,
  required BigInt cols,
}) => MathRustLib.instance.api.crateApiMatrixRref(
  data: data,
  rows: rows,
  cols: cols,
);

/// Compute numerical derivative at a point
Future<CalculusResult> differentiate({
  required String expression,
  required String variable,
  required double point,
  required int order,
}) => MathRustLib.instance.api.crateApiDifferentiate(
  expression: expression,
  variable: variable,
  point: point,
  order: order,
);

/// Compute numerical integral (definite)
Future<CalculusResult> integrate({
  required String expression,
  required String variable,
  required double lower,
  required double upper,
  required int numIntervals,
}) => MathRustLib.instance.api.crateApiIntegrate(
  expression: expression,
  variable: variable,
  lower: lower,
  upper: upper,
  numIntervals: numIntervals,
);

/// Solve equation f(x) = 0 using Newton-Raphson
Future<SolveResult> solveEquation({
  required String expression,
  required String variable,
  required double initialGuess,
  required double tolerance,
  required int maxIterations,
}) => MathRustLib.instance.api.crateApiSolveEquation(
  expression: expression,
  variable: variable,
  initialGuess: initialGuess,
  tolerance: tolerance,
  maxIterations: maxIterations,
);

/// Find multiple roots in an interval
Future<SolveResult> findRootsInInterval({
  required String expression,
  required String variable,
  required double start,
  required double end,
  required int numSamples,
}) => MathRustLib.instance.api.crateApiFindRootsInInterval(
  expression: expression,
  variable: variable,
  start: start,
  end: end,
  numSamples: numSamples,
);

/// Compute limit numerically
Future<CalculusResult> computeLimit({
  required String expression,
  required String variable,
  required double approachValue,
  required bool fromLeft,
  required bool fromRight,
}) => MathRustLib.instance.api.crateApiComputeLimit(
  expression: expression,
  variable: variable,
  approachValue: approachValue,
  fromLeft: fromLeft,
  fromRight: fromRight,
);

/// Get Taylor series coefficients
Future<Float64List> taylorCoefficients({
  required String expression,
  required String variable,
  required double around,
  required int numTerms,
}) => MathRustLib.instance.api.crateApiTaylorCoefficients(
  expression: expression,
  variable: variable,
  around: around,
  numTerms: numTerms,
);

/// Compute partial derivative with respect to one variable
Future<CalculusResult> partialDerivative({
  required String expression,
  required String variable,
  required List<(String, double)> point,
  required int order,
}) => MathRustLib.instance.api.crateApiPartialDerivative(
  expression: expression,
  variable: variable,
  point: point,
  order: order,
);

/// Compute mixed partial derivative ∂²f/∂x∂y
Future<CalculusResult> mixedPartialDerivative({
  required String expression,
  required String var1,
  required String var2,
  required List<(String, double)> point,
}) => MathRustLib.instance.api.crateApiMixedPartialDerivative(
  expression: expression,
  var1: var1,
  var2: var2,
  point: point,
);

/// Compute gradient vector
Future<Float64List> gradient({
  required String expression,
  required List<String> variables,
  required List<(String, double)> point,
}) => MathRustLib.instance.api.crateApiGradient(
  expression: expression,
  variables: variables,
  point: point,
);

/// Compute double integral ∫∫ f(x,y) dx dy
Future<CalculusResult> doubleIntegral({
  required String expression,
  required String xVar,
  required String yVar,
  required double xMin,
  required double xMax,
  required double yMin,
  required double yMax,
  required int numIntervals,
}) => MathRustLib.instance.api.crateApiDoubleIntegral(
  expression: expression,
  xVar: xVar,
  yVar: yVar,
  xMin: xMin,
  xMax: xMax,
  yMin: yMin,
  yMax: yMax,
  numIntervals: numIntervals,
);

/// Compute triple integral ∫∫∫ f(x,y,z) dx dy dz
Future<CalculusResult> tripleIntegral({
  required String expression,
  required String xVar,
  required String yVar,
  required String zVar,
  required double xMin,
  required double xMax,
  required double yMin,
  required double yMax,
  required double zMin,
  required double zMax,
  required int numIntervals,
}) => MathRustLib.instance.api.crateApiTripleIntegral(
  expression: expression,
  xVar: xVar,
  yVar: yVar,
  zVar: zVar,
  xMin: xMin,
  xMax: xMax,
  yMin: yMin,
  yMax: yMax,
  zMin: zMin,
  zMax: zMax,
  numIntervals: numIntervals,
);

/// Compute line integral along a parameterized path
Future<CalculusResult> lineIntegral({
  required String expression,
  required String xParam,
  required String yParam,
  required String tVar,
  required double tMin,
  required double tMax,
  required int numIntervals,
}) => MathRustLib.instance.api.crateApiLineIntegral(
  expression: expression,
  xParam: xParam,
  yParam: yParam,
  tVar: tVar,
  tMin: tMin,
  tMax: tMax,
  numIntervals: numIntervals,
);

/// Compute descriptive statistics from a dataset
Future<StatisticsResult> computeStatistics({required List<double> data}) =>
    MathRustLib.instance.api.crateApiComputeStatistics(data: data);

/// Compute probability distribution values (PDF, CDF)
Future<DistributionResult> distributionCompute({
  required String distributionType,
  required List<double> params,
  required double x,
}) => MathRustLib.instance.api.crateApiDistributionCompute(
  distributionType: distributionType,
  params: params,
  x: x,
);

/// Perform linear regression
Future<RegressionResult> linearRegression({
  required List<double> xData,
  required List<double> yData,
}) => MathRustLib.instance.api.crateApiLinearRegression(
  xData: xData,
  yData: yData,
);

/// Perform polynomial regression
Future<RegressionResult> polynomialRegression({
  required List<double> xData,
  required List<double> yData,
  required BigInt degree,
}) => MathRustLib.instance.api.crateApiPolynomialRegression(
  xData: xData,
  yData: yData,
  degree: degree,
);

/// One-sample t-test
Future<HypothesisTestResult> tTest({
  required List<double> data,
  required double hypothesizedMean,
  required double alpha,
}) => MathRustLib.instance.api.crateApiTTest(
  data: data,
  hypothesizedMean: hypothesizedMean,
  alpha: alpha,
);

/// Two-sample t-test
Future<HypothesisTestResult> twoSampleTTest({
  required List<double> data1,
  required List<double> data2,
  required double alpha,
}) => MathRustLib.instance.api.crateApiTwoSampleTTest(
  data1: data1,
  data2: data2,
  alpha: alpha,
);

/// Chi-squared test
Future<HypothesisTestResult> chiSquaredTest({
  required List<double> observed,
  required List<double> expected,
  required double alpha,
}) => MathRustLib.instance.api.crateApiChiSquaredTest(
  observed: observed,
  expected: expected,
  alpha: alpha,
);

/// One-sample z-test (known population standard deviation)
Future<HypothesisTestResult> zTest({
  required List<double> data,
  required double hypothesizedMean,
  required double populationStd,
  required double alpha,
}) => MathRustLib.instance.api.crateApiZTest(
  data: data,
  hypothesizedMean: hypothesizedMean,
  populationStd: populationStd,
  alpha: alpha,
);

/// Two-sample z-test (known population standard deviations)
Future<HypothesisTestResult> twoSampleZTest({
  required List<double> data1,
  required List<double> data2,
  required double std1,
  required double std2,
  required double alpha,
}) => MathRustLib.instance.api.crateApiTwoSampleZTest(
  data1: data1,
  data2: data2,
  std1: std1,
  std2: std2,
  alpha: alpha,
);

/// One-way ANOVA (Analysis of Variance)
Future<HypothesisTestResult> anova({
  required List<Float64List> groups,
  required double alpha,
}) => MathRustLib.instance.api.crateApiAnova(groups: groups, alpha: alpha);

/// Correlation and covariance
Future<CorrelationResult> correlationCovariance({
  required List<double> x,
  required List<double> y,
}) => MathRustLib.instance.api.crateApiCorrelationCovariance(x: x, y: y);

/// Confidence interval for mean
Future<ConfidenceIntervalResult> confidenceIntervalMean({
  required List<double> data,
  required double confidenceLevel,
}) => MathRustLib.instance.api.crateApiConfidenceIntervalMean(
  data: data,
  confidenceLevel: confidenceLevel,
);

/// Confidence interval for proportion
ConfidenceIntervalResult confidenceIntervalProportion({
  required BigInt successes,
  required BigInt n,
  required double confidenceLevel,
}) => MathRustLib.instance.api.crateApiConfidenceIntervalProportion(
  successes: successes,
  n: n,
  confidenceLevel: confidenceLevel,
);

/// Confidence interval for variance
Future<ConfidenceIntervalResult> confidenceIntervalVariance({
  required List<double> data,
  required double confidenceLevel,
}) => MathRustLib.instance.api.crateApiConfidenceIntervalVariance(
  data: data,
  confidenceLevel: confidenceLevel,
);

/// Check primality using Miller-Rabin
bool isPrime({required BigInt n}) =>
    MathRustLib.instance.api.crateApiIsPrime(n: n);

/// Compute GCD
BigInt gcd({required BigInt a, required BigInt b}) =>
    MathRustLib.instance.api.crateApiGcd(a: a, b: b);

/// Compute LCM
BigInt lcm({required BigInt a, required BigInt b}) =>
    MathRustLib.instance.api.crateApiLcm(a: a, b: b);

/// Compute combinations nCr
DiscreteResult combinations({required BigInt n, required BigInt r}) =>
    MathRustLib.instance.api.crateApiCombinations(n: n, r: r);

/// Compute permutations nPr
DiscreteResult permutations({required BigInt n, required BigInt r}) =>
    MathRustLib.instance.api.crateApiPermutations(n: n, r: r);

/// Compute factorial
DiscreteResult factorial({required BigInt n}) =>
    MathRustLib.instance.api.crateApiFactorial(n: n);

/// Modular exponentiation (a^b mod m)
DiscreteResult modPow({
  required BigInt base,
  required BigInt exp,
  required BigInt modulus,
}) => MathRustLib.instance.api.crateApiModPow(
  base: base,
  exp: exp,
  modulus: modulus,
);

/// Modular inverse
DiscreteResult modInverse({required BigInt a, required BigInt m}) =>
    MathRustLib.instance.api.crateApiModInverse(a: a, m: m);

/// Modular addition
DiscreteResult modAdd({
  required BigInt a,
  required BigInt b,
  required BigInt m,
}) => MathRustLib.instance.api.crateApiModAdd(a: a, b: b, m: m);

/// Modular subtraction
DiscreteResult modSub({
  required BigInt a,
  required BigInt b,
  required BigInt m,
}) => MathRustLib.instance.api.crateApiModSub(a: a, b: b, m: m);

/// Modular multiplication
DiscreteResult modMultiply({
  required BigInt a,
  required BigInt b,
  required BigInt m,
}) => MathRustLib.instance.api.crateApiModMultiply(a: a, b: b, m: m);

/// Modular division
DiscreteResult modDivide({
  required BigInt a,
  required BigInt b,
  required BigInt m,
}) => MathRustLib.instance.api.crateApiModDivide(a: a, b: b, m: m);

/// Prime factorization
DiscreteResult primeFactors({required BigInt n}) =>
    MathRustLib.instance.api.crateApiPrimeFactors(n: n);

/// Generate primes up to n (sieve)
Future<DiscreteResult> sievePrimes({required BigInt n}) =>
    MathRustLib.instance.api.crateApiSievePrimes(n: n);

/// Nth Fibonacci number
DiscreteResult fibonacci({required BigInt n}) =>
    MathRustLib.instance.api.crateApiFibonacci(n: n);

/// Euler's totient function
DiscreteResult eulerTotient({required BigInt n}) =>
    MathRustLib.instance.api.crateApiEulerTotient(n: n);

/// Get divisors of a number
DiscreteResult listDivisors({required BigInt n}) =>
    MathRustLib.instance.api.crateApiListDivisors(n: n);

/// Catalan number
DiscreteResult catalan({required BigInt n}) =>
    MathRustLib.instance.api.crateApiCatalan(n: n);

/// Check if perfect number
DiscreteResult isPerfect({required BigInt n}) =>
    MathRustLib.instance.api.crateApiIsPerfect(n: n);

/// Convert between units
UnitResult convertUnit({
  required double value,
  required String fromUnit,
  required String toUnit,
}) => MathRustLib.instance.api.crateApiConvertUnit(
  value: value,
  fromUnit: fromUnit,
  toUnit: toUnit,
);

/// Get available units for a category
List<String> getUnitsForCategory({required String category}) =>
    MathRustLib.instance.api.crateApiGetUnitsForCategory(category: category);

/// Get all unit categories
List<String> getUnitCategories() =>
    MathRustLib.instance.api.crateApiGetUnitCategories();

/// Convert to all units in same category
List<UnitResult> convertToAllUnits({
  required double value,
  required String fromUnit,
}) => MathRustLib.instance.api.crateApiConvertToAllUnits(
  value: value,
  fromUnit: fromUnit,
);

/// Evaluate a function over a range for graphing
/// Uses rayon for parallel evaluation - extremely fast
Future<GraphResult> evaluateGraphPoints({
  required String expression,
  required String variable,
  required List<double> xValues,
}) => MathRustLib.instance.api.crateApiEvaluateGraphPoints(
  expression: expression,
  variable: variable,
  xValues: xValues,
);

/// Generate x values for a range
Float64List generateXRange({
  required double start,
  required double end,
  required BigInt numPoints,
}) => MathRustLib.instance.api.crateApiGenerateXRange(
  start: start,
  end: end,
  numPoints: numPoints,
);

/// Find function roots in a range
Future<Float64List> findGraphRoots({
  required String expression,
  required String variable,
  required double xMin,
  required double xMax,
  required BigInt numSamples,
}) => MathRustLib.instance.api.crateApiFindGraphRoots(
  expression: expression,
  variable: variable,
  xMin: xMin,
  xMax: xMax,
  numSamples: numSamples,
);

/// Find local extrema (maxima/minima) in a range
Future<(List<(double, double)>, List<(double, double)>)> findExtrema({
  required String expression,
  required String variable,
  required double xMin,
  required double xMax,
  required BigInt numSamples,
}) => MathRustLib.instance.api.crateApiFindExtrema(
  expression: expression,
  variable: variable,
  xMin: xMin,
  xMax: xMax,
  numSamples: numSamples,
);

/// Compute derivative graph
Future<GraphResult> derivativeGraph({
  required String expression,
  required String variable,
  required List<double> xValues,
}) => MathRustLib.instance.api.crateApiDerivativeGraph(
  expression: expression,
  variable: variable,
  xValues: xValues,
);

/// Compute integral graph (cumulative)
Future<GraphResult> integralGraph({
  required String expression,
  required String variable,
  required List<double> xValues,
  required double initialValue,
}) => MathRustLib.instance.api.crateApiIntegralGraph(
  expression: expression,
  variable: variable,
  xValues: xValues,
  initialValue: initialValue,
);

/// Parse a custom formula and extract variables
List<String> parseFormula({required String formula}) =>
    MathRustLib.instance.api.crateApiParseFormula(formula: formula);

/// Evaluate a custom formula with given variable values
ExpressionResult evaluateFormula({
  required String formula,
  required List<String> variables,
  required List<double> values,
}) => MathRustLib.instance.api.crateApiEvaluateFormula(
  formula: formula,
  variables: variables,
  values: values,
);
