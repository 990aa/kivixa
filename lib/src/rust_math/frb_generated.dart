// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kivixa/src/rust_math/api.dart';
import 'package:kivixa/src/rust_math/basic.dart';
import 'package:kivixa/src/rust_math/calculus.dart';
import 'package:kivixa/src/rust_math/complex.dart';
import 'package:kivixa/src/rust_math/discrete.dart';
import 'package:kivixa/src/rust_math/frb_generated.dart';
import 'package:kivixa/src/rust_math/frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:kivixa/src/rust_math/graphing.dart';
import 'package:kivixa/src/rust_math/matrix.dart';
import 'package:kivixa/src/rust_math/statistics.dart';
import 'package:kivixa/src/rust_math/units.dart';

/// Main entrypoint of the Rust API
class MathRustLib
    extends
        BaseEntrypoint<MathRustLibApi, MathRustLibApiImpl, MathRustLibWire> {
  @internal
  static final instance = MathRustLib._();

  MathRustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    MathRustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required MathRustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<MathRustLibApiImpl, MathRustLibWire>
  get apiImplConstructor => MathRustLibApiImpl.new;

  @override
  WireConstructor<MathRustLibWire> get wireConstructor =>
      MathRustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1636446782;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'kivixa_math',
        ioDirectory: 'native_math/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class MathRustLibApi extends BaseApi {
  Future<HypothesisTestResult> crateApiAnova({
    required List<Float64List> groups,
    required double alpha,
  });

  DiscreteResult crateApiCatalan({required BigInt n});

  Future<HypothesisTestResult> crateApiChiSquaredTest({
    required List<double> observed,
    required List<double> expected,
    required double alpha,
  });

  DiscreteResult crateApiCombinations({required BigInt n, required BigInt r});

  ComplexResult crateApiComplexConvert({
    required double real,
    required double imag,
    required bool toPolar,
  });

  ComplexResult crateApiComplexOperation({
    required double aReal,
    required double aImag,
    required double bReal,
    required double bImag,
    required String operation,
  });

  Future<CalculusResult> crateApiComputeLimit({
    required String expression,
    required String variable,
    required double approachValue,
    required bool fromLeft,
    required bool fromRight,
  });

  Future<StatisticsResult> crateApiComputeStatistics({
    required List<double> data,
  });

  Future<ConfidenceIntervalResult> crateApiConfidenceIntervalMean({
    required List<double> data,
    required double confidenceLevel,
  });

  ConfidenceIntervalResult crateApiConfidenceIntervalProportion({
    required BigInt successes,
    required BigInt n,
    required double confidenceLevel,
  });

  Future<ConfidenceIntervalResult> crateApiConfidenceIntervalVariance({
    required List<double> data,
    required double confidenceLevel,
  });

  String crateApiConvertNumberSystem({
    required String value,
    required int fromBase,
    required int toBase,
  });

  List<UnitResult> crateApiConvertToAllUnits({
    required double value,
    required String fromUnit,
  });

  UnitResult crateApiConvertUnit({
    required double value,
    required String fromUnit,
    required String toUnit,
  });

  Future<CorrelationResult> crateApiCorrelationCovariance({
    required List<double> x,
    required List<double> y,
  });

  Future<GraphResult> crateApiDerivativeGraph({
    required String expression,
    required String variable,
    required List<double> xValues,
  });

  Future<CalculusResult> crateApiDifferentiate({
    required String expression,
    required String variable,
    required double point,
    required int order,
  });

  Future<DistributionResult> crateApiDistributionCompute({
    required String distributionType,
    required List<double> params,
    required double x,
  });

  Future<CalculusResult> crateApiDoubleIntegral({
    required String expression,
    required String xVar,
    required String yVar,
    required double xMin,
    required double xMax,
    required double yMin,
    required double yMax,
    required int numIntervals,
  });

  DiscreteResult crateApiEulerTotient({required BigInt n});

  ExpressionResult crateApiEvaluateExpression({required String expression});

  ExpressionResult crateApiEvaluateFormula({
    required String formula,
    required List<String> variables,
    required List<double> values,
  });

  Future<GraphResult> crateApiEvaluateGraphPoints({
    required String expression,
    required String variable,
    required List<double> xValues,
  });

  DiscreteResult crateApiFactorial({required BigInt n});

  DiscreteResult crateApiFibonacci({required BigInt n});

  Future<(List<(double, double)>, List<(double, double)>)> crateApiFindExtrema({
    required String expression,
    required String variable,
    required double xMin,
    required double xMax,
    required BigInt numSamples,
  });

  Future<Float64List> crateApiFindGraphRoots({
    required String expression,
    required String variable,
    required double xMin,
    required double xMax,
    required BigInt numSamples,
  });

  Future<SolveResult> crateApiFindRootsInInterval({
    required String expression,
    required String variable,
    required double start,
    required double end,
    required int numSamples,
  });

  BigInt crateApiGcd({required BigInt a, required BigInt b});

  Float64List crateApiGenerateXRange({
    required double start,
    required double end,
    required BigInt numPoints,
  });

  double crateApiGetConstant({required String name});

  List<String> crateApiGetUnitCategories();

  List<String> crateApiGetUnitsForCategory({required String category});

  Future<Float64List> crateApiGradient({
    required String expression,
    required List<String> variables,
    required List<(String, double)> point,
  });

  Future<void> crateApiInitApp();

  Future<GraphResult> crateApiIntegralGraph({
    required String expression,
    required String variable,
    required List<double> xValues,
    required double initialValue,
  });

  Future<CalculusResult> crateApiIntegrate({
    required String expression,
    required String variable,
    required double lower,
    required double upper,
    required int numIntervals,
  });

  DiscreteResult crateApiIsPerfect({required BigInt n});

  bool crateApiIsPrime({required BigInt n});

  BigInt crateApiLcm({required BigInt a, required BigInt b});

  Future<CalculusResult> crateApiLineIntegral({
    required String expression,
    required String xParam,
    required String yParam,
    required String tVar,
    required double tMin,
    required double tMax,
    required int numIntervals,
  });

  Future<RegressionResult> crateApiLinearRegression({
    required List<double> xData,
    required List<double> yData,
  });

  DiscreteResult crateApiListDivisors({required BigInt n});

  Future<MatrixDecomposition> crateApiMatrixDecomposition({
    required List<double> data,
    required BigInt rows,
    required BigInt cols,
    required String decompositionType,
  });

  Future<MatrixResult> crateApiMatrixOperation({
    required List<double> aData,
    required BigInt aRows,
    required BigInt aCols,
    Float64List? bData,
    BigInt? bRows,
    BigInt? bCols,
    required String operation,
  });

  Future<MatrixResult> crateApiMatrixProperties({
    required List<double> data,
    required BigInt rows,
    required BigInt cols,
  });

  Future<MatrixResult> crateApiMatrixRref({
    required List<double> data,
    required BigInt rows,
    required BigInt cols,
  });

  Future<CalculusResult> crateApiMixedPartialDerivative({
    required String expression,
    required String var1,
    required String var2,
    required List<(String, double)> point,
  });

  DiscreteResult crateApiModAdd({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  });

  DiscreteResult crateApiModDivide({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  });

  DiscreteResult crateApiModInverse({required BigInt a, required BigInt m});

  DiscreteResult crateApiModMultiply({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  });

  DiscreteResult crateApiModPow({
    required BigInt base,
    required BigInt exp,
    required BigInt modulus,
  });

  DiscreteResult crateApiModSub({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  });

  List<String> crateApiParseFormula({required String formula});

  Future<CalculusResult> crateApiPartialDerivative({
    required String expression,
    required String variable,
    required List<(String, double)> point,
    required int order,
  });

  DiscreteResult crateApiPermutations({required BigInt n, required BigInt r});

  Future<RegressionResult> crateApiPolynomialRegression({
    required List<double> xData,
    required List<double> yData,
    required BigInt degree,
  });

  DiscreteResult crateApiPrimeFactors({required BigInt n});

  Future<DiscreteResult> crateApiSievePrimes({required BigInt n});

  Future<SolveResult> crateApiSolveEquation({
    required String expression,
    required String variable,
    required double initialGuess,
    required double tolerance,
    required int maxIterations,
  });

  Future<HypothesisTestResult> crateApiTTest({
    required List<double> data,
    required double hypothesizedMean,
    required double alpha,
  });

  Future<Float64List> crateApiTaylorCoefficients({
    required String expression,
    required String variable,
    required double around,
    required int numTerms,
  });

  Future<CalculusResult> crateApiTripleIntegral({
    required String expression,
    required String xVar,
    required String yVar,
    required String zVar,
    required double xMin,
    required double xMax,
    required double yMin,
    required double yMax,
    required double zMin,
    required double zMax,
    required int numIntervals,
  });

  Future<HypothesisTestResult> crateApiTwoSampleTTest({
    required List<double> data1,
    required List<double> data2,
    required double alpha,
  });

  Future<HypothesisTestResult> crateApiTwoSampleZTest({
    required List<double> data1,
    required List<double> data2,
    required double std1,
    required double std2,
    required double alpha,
  });

  Future<HypothesisTestResult> crateApiZTest({
    required List<double> data,
    required double hypothesizedMean,
    required double populationStd,
    required double alpha,
  });
}

class MathRustLibApiImpl extends MathRustLibApiImplPlatform
    implements MathRustLibApi {
  MathRustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<HypothesisTestResult> crateApiAnova({
    required List<Float64List> groups,
    required double alpha,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_list_prim_f_64_strict(groups);
          final arg1 = cst_encode_f_64(alpha);
          return wire.wire__crate__api__anova(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_hypothesis_test_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiAnovaConstMeta,
        argValues: [groups, alpha],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAnovaConstMeta =>
      const TaskConstMeta(debugName: 'anova', argNames: ['groups', 'alpha']);

  @override
  DiscreteResult crateApiCatalan({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__catalan(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCatalanConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCatalanConstMeta =>
      const TaskConstMeta(debugName: 'catalan', argNames: ['n']);

  @override
  Future<HypothesisTestResult> crateApiChiSquaredTest({
    required List<double> observed,
    required List<double> expected,
    required double alpha,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(observed);
          final arg1 = cst_encode_list_prim_f_64_loose(expected);
          final arg2 = cst_encode_f_64(alpha);
          return wire.wire__crate__api__chi_squared_test(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_hypothesis_test_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiChiSquaredTestConstMeta,
        argValues: [observed, expected, alpha],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChiSquaredTestConstMeta => const TaskConstMeta(
    debugName: 'chi_squared_test',
    argNames: ['observed', 'expected', 'alpha'],
  );

  @override
  DiscreteResult crateApiCombinations({required BigInt n, required BigInt r}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          final arg1 = cst_encode_u_64(r);
          return wire.wire__crate__api__combinations(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCombinationsConstMeta,
        argValues: [n, r],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCombinationsConstMeta =>
      const TaskConstMeta(debugName: 'combinations', argNames: ['n', 'r']);

  @override
  ComplexResult crateApiComplexConvert({
    required double real,
    required double imag,
    required bool toPolar,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_f_64(real);
          final arg1 = cst_encode_f_64(imag);
          final arg2 = cst_encode_bool(toPolar);
          return wire.wire__crate__api__complex_convert(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_complex_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiComplexConvertConstMeta,
        argValues: [real, imag, toPolar],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiComplexConvertConstMeta => const TaskConstMeta(
    debugName: 'complex_convert',
    argNames: ['real', 'imag', 'toPolar'],
  );

  @override
  ComplexResult crateApiComplexOperation({
    required double aReal,
    required double aImag,
    required double bReal,
    required double bImag,
    required String operation,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_f_64(aReal);
          final arg1 = cst_encode_f_64(aImag);
          final arg2 = cst_encode_f_64(bReal);
          final arg3 = cst_encode_f_64(bImag);
          final arg4 = cst_encode_String(operation);
          return wire.wire__crate__api__complex_operation(
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_complex_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiComplexOperationConstMeta,
        argValues: [aReal, aImag, bReal, bImag, operation],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiComplexOperationConstMeta => const TaskConstMeta(
    debugName: 'complex_operation',
    argNames: ['aReal', 'aImag', 'bReal', 'bImag', 'operation'],
  );

  @override
  Future<CalculusResult> crateApiComputeLimit({
    required String expression,
    required String variable,
    required double approachValue,
    required bool fromLeft,
    required bool fromRight,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(approachValue);
          final arg3 = cst_encode_bool(fromLeft);
          final arg4 = cst_encode_bool(fromRight);
          return wire.wire__crate__api__compute_limit(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiComputeLimitConstMeta,
        argValues: [expression, variable, approachValue, fromLeft, fromRight],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiComputeLimitConstMeta => const TaskConstMeta(
    debugName: 'compute_limit',
    argNames: [
      'expression',
      'variable',
      'approachValue',
      'fromLeft',
      'fromRight',
    ],
  );

  @override
  Future<StatisticsResult> crateApiComputeStatistics({
    required List<double> data,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          return wire.wire__crate__api__compute_statistics(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_statistics_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiComputeStatisticsConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiComputeStatisticsConstMeta =>
      const TaskConstMeta(debugName: 'compute_statistics', argNames: ['data']);

  @override
  Future<ConfidenceIntervalResult> crateApiConfidenceIntervalMean({
    required List<double> data,
    required double confidenceLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_f_64(confidenceLevel);
          return wire.wire__crate__api__confidence_interval_mean(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_confidence_interval_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConfidenceIntervalMeanConstMeta,
        argValues: [data, confidenceLevel],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConfidenceIntervalMeanConstMeta =>
      const TaskConstMeta(
        debugName: 'confidence_interval_mean',
        argNames: ['data', 'confidenceLevel'],
      );

  @override
  ConfidenceIntervalResult crateApiConfidenceIntervalProportion({
    required BigInt successes,
    required BigInt n,
    required double confidenceLevel,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(successes);
          final arg1 = cst_encode_u_64(n);
          final arg2 = cst_encode_f_64(confidenceLevel);
          return wire.wire__crate__api__confidence_interval_proportion(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_confidence_interval_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConfidenceIntervalProportionConstMeta,
        argValues: [successes, n, confidenceLevel],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConfidenceIntervalProportionConstMeta =>
      const TaskConstMeta(
        debugName: 'confidence_interval_proportion',
        argNames: ['successes', 'n', 'confidenceLevel'],
      );

  @override
  Future<ConfidenceIntervalResult> crateApiConfidenceIntervalVariance({
    required List<double> data,
    required double confidenceLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_f_64(confidenceLevel);
          return wire.wire__crate__api__confidence_interval_variance(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_confidence_interval_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConfidenceIntervalVarianceConstMeta,
        argValues: [data, confidenceLevel],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConfidenceIntervalVarianceConstMeta =>
      const TaskConstMeta(
        debugName: 'confidence_interval_variance',
        argNames: ['data', 'confidenceLevel'],
      );

  @override
  String crateApiConvertNumberSystem({
    required String value,
    required int fromBase,
    required int toBase,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(value);
          final arg1 = cst_encode_u_32(fromBase);
          final arg2 = cst_encode_u_32(toBase);
          return wire.wire__crate__api__convert_number_system(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConvertNumberSystemConstMeta,
        argValues: [value, fromBase, toBase],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConvertNumberSystemConstMeta =>
      const TaskConstMeta(
        debugName: 'convert_number_system',
        argNames: ['value', 'fromBase', 'toBase'],
      );

  @override
  List<UnitResult> crateApiConvertToAllUnits({
    required double value,
    required String fromUnit,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_f_64(value);
          final arg1 = cst_encode_String(fromUnit);
          return wire.wire__crate__api__convert_to_all_units(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_unit_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConvertToAllUnitsConstMeta,
        argValues: [value, fromUnit],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConvertToAllUnitsConstMeta => const TaskConstMeta(
    debugName: 'convert_to_all_units',
    argNames: ['value', 'fromUnit'],
  );

  @override
  UnitResult crateApiConvertUnit({
    required double value,
    required String fromUnit,
    required String toUnit,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_f_64(value);
          final arg1 = cst_encode_String(fromUnit);
          final arg2 = cst_encode_String(toUnit);
          return wire.wire__crate__api__convert_unit(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiConvertUnitConstMeta,
        argValues: [value, fromUnit, toUnit],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConvertUnitConstMeta => const TaskConstMeta(
    debugName: 'convert_unit',
    argNames: ['value', 'fromUnit', 'toUnit'],
  );

  @override
  Future<CorrelationResult> crateApiCorrelationCovariance({
    required List<double> x,
    required List<double> y,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(x);
          final arg1 = cst_encode_list_prim_f_64_loose(y);
          return wire.wire__crate__api__correlation_covariance(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_correlation_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCorrelationCovarianceConstMeta,
        argValues: [x, y],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCorrelationCovarianceConstMeta =>
      const TaskConstMeta(
        debugName: 'correlation_covariance',
        argNames: ['x', 'y'],
      );

  @override
  Future<GraphResult> crateApiDerivativeGraph({
    required String expression,
    required String variable,
    required List<double> xValues,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_list_prim_f_64_loose(xValues);
          return wire.wire__crate__api__derivative_graph(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_graph_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDerivativeGraphConstMeta,
        argValues: [expression, variable, xValues],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDerivativeGraphConstMeta => const TaskConstMeta(
    debugName: 'derivative_graph',
    argNames: ['expression', 'variable', 'xValues'],
  );

  @override
  Future<CalculusResult> crateApiDifferentiate({
    required String expression,
    required String variable,
    required double point,
    required int order,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(point);
          final arg3 = cst_encode_u_32(order);
          return wire.wire__crate__api__differentiate(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDifferentiateConstMeta,
        argValues: [expression, variable, point, order],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDifferentiateConstMeta => const TaskConstMeta(
    debugName: 'differentiate',
    argNames: ['expression', 'variable', 'point', 'order'],
  );

  @override
  Future<DistributionResult> crateApiDistributionCompute({
    required String distributionType,
    required List<double> params,
    required double x,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(distributionType);
          final arg1 = cst_encode_list_prim_f_64_loose(params);
          final arg2 = cst_encode_f_64(x);
          return wire.wire__crate__api__distribution_compute(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_distribution_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDistributionComputeConstMeta,
        argValues: [distributionType, params, x],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDistributionComputeConstMeta =>
      const TaskConstMeta(
        debugName: 'distribution_compute',
        argNames: ['distributionType', 'params', 'x'],
      );

  @override
  Future<CalculusResult> crateApiDoubleIntegral({
    required String expression,
    required String xVar,
    required String yVar,
    required double xMin,
    required double xMax,
    required double yMin,
    required double yMax,
    required int numIntervals,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(xVar);
          final arg2 = cst_encode_String(yVar);
          final arg3 = cst_encode_f_64(xMin);
          final arg4 = cst_encode_f_64(xMax);
          final arg5 = cst_encode_f_64(yMin);
          final arg6 = cst_encode_f_64(yMax);
          final arg7 = cst_encode_u_32(numIntervals);
          return wire.wire__crate__api__double_integral(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDoubleIntegralConstMeta,
        argValues: [
          expression,
          xVar,
          yVar,
          xMin,
          xMax,
          yMin,
          yMax,
          numIntervals,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDoubleIntegralConstMeta => const TaskConstMeta(
    debugName: 'double_integral',
    argNames: [
      'expression',
      'xVar',
      'yVar',
      'xMin',
      'xMax',
      'yMin',
      'yMax',
      'numIntervals',
    ],
  );

  @override
  DiscreteResult crateApiEulerTotient({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__euler_totient(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEulerTotientConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEulerTotientConstMeta =>
      const TaskConstMeta(debugName: 'euler_totient', argNames: ['n']);

  @override
  ExpressionResult crateApiEvaluateExpression({required String expression}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(expression);
          return wire.wire__crate__api__evaluate_expression(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_expression_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEvaluateExpressionConstMeta,
        argValues: [expression],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEvaluateExpressionConstMeta => const TaskConstMeta(
    debugName: 'evaluate_expression',
    argNames: ['expression'],
  );

  @override
  ExpressionResult crateApiEvaluateFormula({
    required String formula,
    required List<String> variables,
    required List<double> values,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(formula);
          final arg1 = cst_encode_list_String(variables);
          final arg2 = cst_encode_list_prim_f_64_loose(values);
          return wire.wire__crate__api__evaluate_formula(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_expression_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEvaluateFormulaConstMeta,
        argValues: [formula, variables, values],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEvaluateFormulaConstMeta => const TaskConstMeta(
    debugName: 'evaluate_formula',
    argNames: ['formula', 'variables', 'values'],
  );

  @override
  Future<GraphResult> crateApiEvaluateGraphPoints({
    required String expression,
    required String variable,
    required List<double> xValues,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_list_prim_f_64_loose(xValues);
          return wire.wire__crate__api__evaluate_graph_points(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_graph_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEvaluateGraphPointsConstMeta,
        argValues: [expression, variable, xValues],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEvaluateGraphPointsConstMeta =>
      const TaskConstMeta(
        debugName: 'evaluate_graph_points',
        argNames: ['expression', 'variable', 'xValues'],
      );

  @override
  DiscreteResult crateApiFactorial({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__factorial(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFactorialConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFactorialConstMeta =>
      const TaskConstMeta(debugName: 'factorial', argNames: ['n']);

  @override
  DiscreteResult crateApiFibonacci({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__fibonacci(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFibonacciConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFibonacciConstMeta =>
      const TaskConstMeta(debugName: 'fibonacci', argNames: ['n']);

  @override
  Future<(List<(double, double)>, List<(double, double)>)> crateApiFindExtrema({
    required String expression,
    required String variable,
    required double xMin,
    required double xMax,
    required BigInt numSamples,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(xMin);
          final arg3 = cst_encode_f_64(xMax);
          final arg4 = cst_encode_usize(numSamples);
          return wire.wire__crate__api__find_extrema(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData:
              dco_decode_record_list_record_f_64_f_64_list_record_f_64_f_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFindExtremaConstMeta,
        argValues: [expression, variable, xMin, xMax, numSamples],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFindExtremaConstMeta => const TaskConstMeta(
    debugName: 'find_extrema',
    argNames: ['expression', 'variable', 'xMin', 'xMax', 'numSamples'],
  );

  @override
  Future<Float64List> crateApiFindGraphRoots({
    required String expression,
    required String variable,
    required double xMin,
    required double xMax,
    required BigInt numSamples,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(xMin);
          final arg3 = cst_encode_f_64(xMax);
          final arg4 = cst_encode_usize(numSamples);
          return wire.wire__crate__api__find_graph_roots(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_f_64_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFindGraphRootsConstMeta,
        argValues: [expression, variable, xMin, xMax, numSamples],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFindGraphRootsConstMeta => const TaskConstMeta(
    debugName: 'find_graph_roots',
    argNames: ['expression', 'variable', 'xMin', 'xMax', 'numSamples'],
  );

  @override
  Future<SolveResult> crateApiFindRootsInInterval({
    required String expression,
    required String variable,
    required double start,
    required double end,
    required int numSamples,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(start);
          final arg3 = cst_encode_f_64(end);
          final arg4 = cst_encode_u_32(numSamples);
          return wire.wire__crate__api__find_roots_in_interval(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_solve_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFindRootsInIntervalConstMeta,
        argValues: [expression, variable, start, end, numSamples],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFindRootsInIntervalConstMeta =>
      const TaskConstMeta(
        debugName: 'find_roots_in_interval',
        argNames: ['expression', 'variable', 'start', 'end', 'numSamples'],
      );

  @override
  BigInt crateApiGcd({required BigInt a, required BigInt b}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(b);
          return wire.wire__crate__api__gcd(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGcdConstMeta,
        argValues: [a, b],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGcdConstMeta =>
      const TaskConstMeta(debugName: 'gcd', argNames: ['a', 'b']);

  @override
  Float64List crateApiGenerateXRange({
    required double start,
    required double end,
    required BigInt numPoints,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_f_64(start);
          final arg1 = cst_encode_f_64(end);
          final arg2 = cst_encode_usize(numPoints);
          return wire.wire__crate__api__generate_x_range(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_f_64_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGenerateXRangeConstMeta,
        argValues: [start, end, numPoints],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGenerateXRangeConstMeta => const TaskConstMeta(
    debugName: 'generate_x_range',
    argNames: ['start', 'end', 'numPoints'],
  );

  @override
  double crateApiGetConstant({required String name}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(name);
          return wire.wire__crate__api__get_constant(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_f_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetConstantConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetConstantConstMeta =>
      const TaskConstMeta(debugName: 'get_constant', argNames: ['name']);

  @override
  List<String> crateApiGetUnitCategories() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__get_unit_categories();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetUnitCategoriesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetUnitCategoriesConstMeta =>
      const TaskConstMeta(debugName: 'get_unit_categories', argNames: []);

  @override
  List<String> crateApiGetUnitsForCategory({required String category}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(category);
          return wire.wire__crate__api__get_units_for_category(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetUnitsForCategoryConstMeta,
        argValues: [category],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetUnitsForCategoryConstMeta =>
      const TaskConstMeta(
        debugName: 'get_units_for_category',
        argNames: ['category'],
      );

  @override
  Future<Float64List> crateApiGradient({
    required String expression,
    required List<String> variables,
    required List<(String, double)> point,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_list_String(variables);
          final arg2 = cst_encode_list_record_string_f_64(point);
          return wire.wire__crate__api__gradient(port_, arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_f_64_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGradientConstMeta,
        argValues: [expression, variables, point],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGradientConstMeta => const TaskConstMeta(
    debugName: 'gradient',
    argNames: ['expression', 'variables', 'point'],
  );

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__init_app(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitAppConstMeta =>
      const TaskConstMeta(debugName: 'init_app', argNames: []);

  @override
  Future<GraphResult> crateApiIntegralGraph({
    required String expression,
    required String variable,
    required List<double> xValues,
    required double initialValue,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_list_prim_f_64_loose(xValues);
          final arg3 = cst_encode_f_64(initialValue);
          return wire.wire__crate__api__integral_graph(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_graph_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIntegralGraphConstMeta,
        argValues: [expression, variable, xValues, initialValue],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIntegralGraphConstMeta => const TaskConstMeta(
    debugName: 'integral_graph',
    argNames: ['expression', 'variable', 'xValues', 'initialValue'],
  );

  @override
  Future<CalculusResult> crateApiIntegrate({
    required String expression,
    required String variable,
    required double lower,
    required double upper,
    required int numIntervals,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(lower);
          final arg3 = cst_encode_f_64(upper);
          final arg4 = cst_encode_u_32(numIntervals);
          return wire.wire__crate__api__integrate(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIntegrateConstMeta,
        argValues: [expression, variable, lower, upper, numIntervals],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIntegrateConstMeta => const TaskConstMeta(
    debugName: 'integrate',
    argNames: ['expression', 'variable', 'lower', 'upper', 'numIntervals'],
  );

  @override
  DiscreteResult crateApiIsPerfect({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__is_perfect(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsPerfectConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsPerfectConstMeta =>
      const TaskConstMeta(debugName: 'is_perfect', argNames: ['n']);

  @override
  bool crateApiIsPrime({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__is_prime(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsPrimeConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsPrimeConstMeta =>
      const TaskConstMeta(debugName: 'is_prime', argNames: ['n']);

  @override
  BigInt crateApiLcm({required BigInt a, required BigInt b}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(b);
          return wire.wire__crate__api__lcm(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiLcmConstMeta,
        argValues: [a, b],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLcmConstMeta =>
      const TaskConstMeta(debugName: 'lcm', argNames: ['a', 'b']);

  @override
  Future<CalculusResult> crateApiLineIntegral({
    required String expression,
    required String xParam,
    required String yParam,
    required String tVar,
    required double tMin,
    required double tMax,
    required int numIntervals,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(xParam);
          final arg2 = cst_encode_String(yParam);
          final arg3 = cst_encode_String(tVar);
          final arg4 = cst_encode_f_64(tMin);
          final arg5 = cst_encode_f_64(tMax);
          final arg6 = cst_encode_u_32(numIntervals);
          return wire.wire__crate__api__line_integral(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiLineIntegralConstMeta,
        argValues: [expression, xParam, yParam, tVar, tMin, tMax, numIntervals],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLineIntegralConstMeta => const TaskConstMeta(
    debugName: 'line_integral',
    argNames: [
      'expression',
      'xParam',
      'yParam',
      'tVar',
      'tMin',
      'tMax',
      'numIntervals',
    ],
  );

  @override
  Future<RegressionResult> crateApiLinearRegression({
    required List<double> xData,
    required List<double> yData,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(xData);
          final arg1 = cst_encode_list_prim_f_64_loose(yData);
          return wire.wire__crate__api__linear_regression(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_regression_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiLinearRegressionConstMeta,
        argValues: [xData, yData],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLinearRegressionConstMeta => const TaskConstMeta(
    debugName: 'linear_regression',
    argNames: ['xData', 'yData'],
  );

  @override
  DiscreteResult crateApiListDivisors({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__list_divisors(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiListDivisorsConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiListDivisorsConstMeta =>
      const TaskConstMeta(debugName: 'list_divisors', argNames: ['n']);

  @override
  Future<MatrixDecomposition> crateApiMatrixDecomposition({
    required List<double> data,
    required BigInt rows,
    required BigInt cols,
    required String decompositionType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_usize(rows);
          final arg2 = cst_encode_usize(cols);
          final arg3 = cst_encode_String(decompositionType);
          return wire.wire__crate__api__matrix_decomposition(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_matrix_decomposition,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMatrixDecompositionConstMeta,
        argValues: [data, rows, cols, decompositionType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMatrixDecompositionConstMeta =>
      const TaskConstMeta(
        debugName: 'matrix_decomposition',
        argNames: ['data', 'rows', 'cols', 'decompositionType'],
      );

  @override
  Future<MatrixResult> crateApiMatrixOperation({
    required List<double> aData,
    required BigInt aRows,
    required BigInt aCols,
    Float64List? bData,
    BigInt? bRows,
    BigInt? bCols,
    required String operation,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(aData);
          final arg1 = cst_encode_usize(aRows);
          final arg2 = cst_encode_usize(aCols);
          final arg3 = cst_encode_opt_list_prim_f_64_strict(bData);
          final arg4 = cst_encode_opt_box_autoadd_usize(bRows);
          final arg5 = cst_encode_opt_box_autoadd_usize(bCols);
          final arg6 = cst_encode_String(operation);
          return wire.wire__crate__api__matrix_operation(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_matrix_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMatrixOperationConstMeta,
        argValues: [aData, aRows, aCols, bData, bRows, bCols, operation],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMatrixOperationConstMeta => const TaskConstMeta(
    debugName: 'matrix_operation',
    argNames: [
      'aData',
      'aRows',
      'aCols',
      'bData',
      'bRows',
      'bCols',
      'operation',
    ],
  );

  @override
  Future<MatrixResult> crateApiMatrixProperties({
    required List<double> data,
    required BigInt rows,
    required BigInt cols,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_usize(rows);
          final arg2 = cst_encode_usize(cols);
          return wire.wire__crate__api__matrix_properties(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_matrix_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMatrixPropertiesConstMeta,
        argValues: [data, rows, cols],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMatrixPropertiesConstMeta => const TaskConstMeta(
    debugName: 'matrix_properties',
    argNames: ['data', 'rows', 'cols'],
  );

  @override
  Future<MatrixResult> crateApiMatrixRref({
    required List<double> data,
    required BigInt rows,
    required BigInt cols,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_usize(rows);
          final arg2 = cst_encode_usize(cols);
          return wire.wire__crate__api__matrix_rref(port_, arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_matrix_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMatrixRrefConstMeta,
        argValues: [data, rows, cols],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMatrixRrefConstMeta => const TaskConstMeta(
    debugName: 'matrix_rref',
    argNames: ['data', 'rows', 'cols'],
  );

  @override
  Future<CalculusResult> crateApiMixedPartialDerivative({
    required String expression,
    required String var1,
    required String var2,
    required List<(String, double)> point,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(var1);
          final arg2 = cst_encode_String(var2);
          final arg3 = cst_encode_list_record_string_f_64(point);
          return wire.wire__crate__api__mixed_partial_derivative(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMixedPartialDerivativeConstMeta,
        argValues: [expression, var1, var2, point],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMixedPartialDerivativeConstMeta =>
      const TaskConstMeta(
        debugName: 'mixed_partial_derivative',
        argNames: ['expression', 'var1', 'var2', 'point'],
      );

  @override
  DiscreteResult crateApiModAdd({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(b);
          final arg2 = cst_encode_u_64(m);
          return wire.wire__crate__api__mod_add(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModAddConstMeta,
        argValues: [a, b, m],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModAddConstMeta =>
      const TaskConstMeta(debugName: 'mod_add', argNames: ['a', 'b', 'm']);

  @override
  DiscreteResult crateApiModDivide({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(b);
          final arg2 = cst_encode_u_64(m);
          return wire.wire__crate__api__mod_divide(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModDivideConstMeta,
        argValues: [a, b, m],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModDivideConstMeta =>
      const TaskConstMeta(debugName: 'mod_divide', argNames: ['a', 'b', 'm']);

  @override
  DiscreteResult crateApiModInverse({required BigInt a, required BigInt m}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(m);
          return wire.wire__crate__api__mod_inverse(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModInverseConstMeta,
        argValues: [a, m],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModInverseConstMeta =>
      const TaskConstMeta(debugName: 'mod_inverse', argNames: ['a', 'm']);

  @override
  DiscreteResult crateApiModMultiply({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(b);
          final arg2 = cst_encode_u_64(m);
          return wire.wire__crate__api__mod_multiply(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModMultiplyConstMeta,
        argValues: [a, b, m],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModMultiplyConstMeta =>
      const TaskConstMeta(debugName: 'mod_multiply', argNames: ['a', 'b', 'm']);

  @override
  DiscreteResult crateApiModPow({
    required BigInt base,
    required BigInt exp,
    required BigInt modulus,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(base);
          final arg1 = cst_encode_u_64(exp);
          final arg2 = cst_encode_u_64(modulus);
          return wire.wire__crate__api__mod_pow(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModPowConstMeta,
        argValues: [base, exp, modulus],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModPowConstMeta => const TaskConstMeta(
    debugName: 'mod_pow',
    argNames: ['base', 'exp', 'modulus'],
  );

  @override
  DiscreteResult crateApiModSub({
    required BigInt a,
    required BigInt b,
    required BigInt m,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(a);
          final arg1 = cst_encode_u_64(b);
          final arg2 = cst_encode_u_64(m);
          return wire.wire__crate__api__mod_sub(arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiModSubConstMeta,
        argValues: [a, b, m],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiModSubConstMeta =>
      const TaskConstMeta(debugName: 'mod_sub', argNames: ['a', 'b', 'm']);

  @override
  List<String> crateApiParseFormula({required String formula}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(formula);
          return wire.wire__crate__api__parse_formula(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiParseFormulaConstMeta,
        argValues: [formula],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiParseFormulaConstMeta =>
      const TaskConstMeta(debugName: 'parse_formula', argNames: ['formula']);

  @override
  Future<CalculusResult> crateApiPartialDerivative({
    required String expression,
    required String variable,
    required List<(String, double)> point,
    required int order,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_list_record_string_f_64(point);
          final arg3 = cst_encode_u_32(order);
          return wire.wire__crate__api__partial_derivative(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPartialDerivativeConstMeta,
        argValues: [expression, variable, point, order],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPartialDerivativeConstMeta => const TaskConstMeta(
    debugName: 'partial_derivative',
    argNames: ['expression', 'variable', 'point', 'order'],
  );

  @override
  DiscreteResult crateApiPermutations({required BigInt n, required BigInt r}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          final arg1 = cst_encode_u_64(r);
          return wire.wire__crate__api__permutations(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPermutationsConstMeta,
        argValues: [n, r],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPermutationsConstMeta =>
      const TaskConstMeta(debugName: 'permutations', argNames: ['n', 'r']);

  @override
  Future<RegressionResult> crateApiPolynomialRegression({
    required List<double> xData,
    required List<double> yData,
    required BigInt degree,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(xData);
          final arg1 = cst_encode_list_prim_f_64_loose(yData);
          final arg2 = cst_encode_usize(degree);
          return wire.wire__crate__api__polynomial_regression(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_regression_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPolynomialRegressionConstMeta,
        argValues: [xData, yData, degree],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPolynomialRegressionConstMeta =>
      const TaskConstMeta(
        debugName: 'polynomial_regression',
        argNames: ['xData', 'yData', 'degree'],
      );

  @override
  DiscreteResult crateApiPrimeFactors({required BigInt n}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__prime_factors(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPrimeFactorsConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPrimeFactorsConstMeta =>
      const TaskConstMeta(debugName: 'prime_factors', argNames: ['n']);

  @override
  Future<DiscreteResult> crateApiSievePrimes({required BigInt n}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_u_64(n);
          return wire.wire__crate__api__sieve_primes(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_discrete_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSievePrimesConstMeta,
        argValues: [n],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSievePrimesConstMeta =>
      const TaskConstMeta(debugName: 'sieve_primes', argNames: ['n']);

  @override
  Future<SolveResult> crateApiSolveEquation({
    required String expression,
    required String variable,
    required double initialGuess,
    required double tolerance,
    required int maxIterations,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(initialGuess);
          final arg3 = cst_encode_f_64(tolerance);
          final arg4 = cst_encode_u_32(maxIterations);
          return wire.wire__crate__api__solve_equation(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_solve_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSolveEquationConstMeta,
        argValues: [
          expression,
          variable,
          initialGuess,
          tolerance,
          maxIterations,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSolveEquationConstMeta => const TaskConstMeta(
    debugName: 'solve_equation',
    argNames: [
      'expression',
      'variable',
      'initialGuess',
      'tolerance',
      'maxIterations',
    ],
  );

  @override
  Future<HypothesisTestResult> crateApiTTest({
    required List<double> data,
    required double hypothesizedMean,
    required double alpha,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_f_64(hypothesizedMean);
          final arg2 = cst_encode_f_64(alpha);
          return wire.wire__crate__api__t_test(port_, arg0, arg1, arg2);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_hypothesis_test_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTTestConstMeta,
        argValues: [data, hypothesizedMean, alpha],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTTestConstMeta => const TaskConstMeta(
    debugName: 't_test',
    argNames: ['data', 'hypothesizedMean', 'alpha'],
  );

  @override
  Future<Float64List> crateApiTaylorCoefficients({
    required String expression,
    required String variable,
    required double around,
    required int numTerms,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(variable);
          final arg2 = cst_encode_f_64(around);
          final arg3 = cst_encode_u_32(numTerms);
          return wire.wire__crate__api__taylor_coefficients(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_f_64_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTaylorCoefficientsConstMeta,
        argValues: [expression, variable, around, numTerms],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTaylorCoefficientsConstMeta => const TaskConstMeta(
    debugName: 'taylor_coefficients',
    argNames: ['expression', 'variable', 'around', 'numTerms'],
  );

  @override
  Future<CalculusResult> crateApiTripleIntegral({
    required String expression,
    required String xVar,
    required String yVar,
    required String zVar,
    required double xMin,
    required double xMax,
    required double yMin,
    required double yMax,
    required double zMin,
    required double zMax,
    required int numIntervals,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(expression);
          final arg1 = cst_encode_String(xVar);
          final arg2 = cst_encode_String(yVar);
          final arg3 = cst_encode_String(zVar);
          final arg4 = cst_encode_f_64(xMin);
          final arg5 = cst_encode_f_64(xMax);
          final arg6 = cst_encode_f_64(yMin);
          final arg7 = cst_encode_f_64(yMax);
          final arg8 = cst_encode_f_64(zMin);
          final arg9 = cst_encode_f_64(zMax);
          final arg10 = cst_encode_u_32(numIntervals);
          return wire.wire__crate__api__triple_integral(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_calculus_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTripleIntegralConstMeta,
        argValues: [
          expression,
          xVar,
          yVar,
          zVar,
          xMin,
          xMax,
          yMin,
          yMax,
          zMin,
          zMax,
          numIntervals,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTripleIntegralConstMeta => const TaskConstMeta(
    debugName: 'triple_integral',
    argNames: [
      'expression',
      'xVar',
      'yVar',
      'zVar',
      'xMin',
      'xMax',
      'yMin',
      'yMax',
      'zMin',
      'zMax',
      'numIntervals',
    ],
  );

  @override
  Future<HypothesisTestResult> crateApiTwoSampleTTest({
    required List<double> data1,
    required List<double> data2,
    required double alpha,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data1);
          final arg1 = cst_encode_list_prim_f_64_loose(data2);
          final arg2 = cst_encode_f_64(alpha);
          return wire.wire__crate__api__two_sample_t_test(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_hypothesis_test_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTwoSampleTTestConstMeta,
        argValues: [data1, data2, alpha],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTwoSampleTTestConstMeta => const TaskConstMeta(
    debugName: 'two_sample_t_test',
    argNames: ['data1', 'data2', 'alpha'],
  );

  @override
  Future<HypothesisTestResult> crateApiTwoSampleZTest({
    required List<double> data1,
    required List<double> data2,
    required double std1,
    required double std2,
    required double alpha,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data1);
          final arg1 = cst_encode_list_prim_f_64_loose(data2);
          final arg2 = cst_encode_f_64(std1);
          final arg3 = cst_encode_f_64(std2);
          final arg4 = cst_encode_f_64(alpha);
          return wire.wire__crate__api__two_sample_z_test(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_hypothesis_test_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTwoSampleZTestConstMeta,
        argValues: [data1, data2, std1, std2, alpha],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTwoSampleZTestConstMeta => const TaskConstMeta(
    debugName: 'two_sample_z_test',
    argNames: ['data1', 'data2', 'std1', 'std2', 'alpha'],
  );

  @override
  Future<HypothesisTestResult> crateApiZTest({
    required List<double> data,
    required double hypothesizedMean,
    required double populationStd,
    required double alpha,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_64_loose(data);
          final arg1 = cst_encode_f_64(hypothesizedMean);
          final arg2 = cst_encode_f_64(populationStd);
          final arg3 = cst_encode_f_64(alpha);
          return wire.wire__crate__api__z_test(port_, arg0, arg1, arg2, arg3);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_hypothesis_test_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiZTestConstMeta,
        argValues: [data, hypothesizedMean, populationStd, alpha],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiZTestConstMeta => const TaskConstMeta(
    debugName: 'z_test',
    argNames: ['data', 'hypothesizedMean', 'populationStd', 'alpha'],
  );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  BigInt dco_decode_box_autoadd_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_usize(raw);
  }

  @protected
  CalculusResult dco_decode_calculus_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return CalculusResult(
      success: dco_decode_bool(arr[0]),
      value: dco_decode_f_64(arr[1]),
      symbolic: dco_decode_opt_String(arr[2]),
      error: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  ComplexResult dco_decode_complex_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ComplexResult(
      success: dco_decode_bool(arr[0]),
      real: dco_decode_f_64(arr[1]),
      imag: dco_decode_f_64(arr[2]),
      magnitude: dco_decode_f_64(arr[3]),
      angleRad: dco_decode_f_64(arr[4]),
      angleDeg: dco_decode_f_64(arr[5]),
      formattedRect: dco_decode_String(arr[6]),
      formattedPolar: dco_decode_String(arr[7]),
      error: dco_decode_opt_String(arr[8]),
    );
  }

  @protected
  ConfidenceIntervalResult dco_decode_confidence_interval_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ConfidenceIntervalResult(
      success: dco_decode_bool(arr[0]),
      lower: dco_decode_f_64(arr[1]),
      upper: dco_decode_f_64(arr[2]),
      center: dco_decode_f_64(arr[3]),
      marginOfError: dco_decode_f_64(arr[4]),
      error: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  CorrelationResult dco_decode_correlation_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CorrelationResult(
      success: dco_decode_bool(arr[0]),
      correlation: dco_decode_f_64(arr[1]),
      covariance: dco_decode_f_64(arr[2]),
      pValue: dco_decode_f_64(arr[3]),
      error: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  DiscreteResult dco_decode_discrete_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DiscreteResult(
      success: dco_decode_bool(arr[0]),
      value: dco_decode_u_64(arr[1]),
      bigValue: dco_decode_opt_String(arr[2]),
      values: dco_decode_list_prim_u_64_strict(arr[3]),
      boolResult: dco_decode_opt_box_autoadd_bool(arr[4]),
      error: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  DistributionResult dco_decode_distribution_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return DistributionResult(
      success: dco_decode_bool(arr[0]),
      pdf: dco_decode_f_64(arr[1]),
      cdf: dco_decode_f_64(arr[2]),
      mean: dco_decode_f_64(arr[3]),
      variance: dco_decode_f_64(arr[4]),
      stdDev: dco_decode_f_64(arr[5]),
      error: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  ExpressionResult dco_decode_expression_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ExpressionResult(
      success: dco_decode_bool(arr[0]),
      value: dco_decode_f_64(arr[1]),
      error: dco_decode_opt_String(arr[2]),
      formatted: dco_decode_String(arr[3]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GraphPoint dco_decode_graph_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return GraphPoint(
      x: dco_decode_f_64(arr[0]),
      y: dco_decode_f_64(arr[1]),
      valid: dco_decode_bool(arr[2]),
    );
  }

  @protected
  GraphResult dco_decode_graph_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return GraphResult(
      success: dco_decode_bool(arr[0]),
      points: dco_decode_list_graph_point(arr[1]),
      xMin: dco_decode_f_64(arr[2]),
      xMax: dco_decode_f_64(arr[3]),
      yMin: dco_decode_f_64(arr[4]),
      yMax: dco_decode_f_64(arr[5]),
      error: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  HypothesisTestResult dco_decode_hypothesis_test_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return HypothesisTestResult(
      success: dco_decode_bool(arr[0]),
      testStatistic: dco_decode_f_64(arr[1]),
      pValue: dco_decode_f_64(arr[2]),
      criticalValue: dco_decode_f_64(arr[3]),
      rejectNull: dco_decode_bool(arr[4]),
      confidenceInterval: dco_decode_record_f_64_f_64(arr[5]),
      error: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<GraphPoint> dco_decode_list_graph_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_graph_point).toList();
  }

  @protected
  List<Float64List> dco_decode_list_list_prim_f_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_list_prim_f_64_strict)
        .toList();
  }

  @protected
  List<MatrixResult> dco_decode_list_matrix_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_matrix_result).toList();
  }

  @protected
  List<double> dco_decode_list_prim_f_64_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<double>;
  }

  @protected
  Float64List dco_decode_list_prim_f_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float64List;
  }

  @protected
  Uint64List dco_decode_list_prim_u_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeUint64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(double, double)> dco_decode_list_record_f_64_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_f_64_f_64).toList();
  }

  @protected
  List<(String, double)> dco_decode_list_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_f_64).toList();
  }

  @protected
  List<UnitResult> dco_decode_list_unit_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_unit_result).toList();
  }

  @protected
  MatrixDecomposition dco_decode_matrix_decomposition(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return MatrixDecomposition(
      success: dco_decode_bool(arr[0]),
      decompositionType: dco_decode_String(arr[1]),
      matrices: dco_decode_list_matrix_result(arr[2]),
      labels: dco_decode_list_String(arr[3]),
      error: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  MatrixResult dco_decode_matrix_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return MatrixResult(
      success: dco_decode_bool(arr[0]),
      data: dco_decode_list_prim_f_64_strict(arr[1]),
      rows: dco_decode_usize(arr[2]),
      cols: dco_decode_usize(arr[3]),
      scalar: dco_decode_opt_box_autoadd_f_64(arr[4]),
      error: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_usize(raw);
  }

  @protected
  Float64List? dco_decode_opt_list_prim_f_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_f_64_strict(raw);
  }

  @protected
  (double, double) dco_decode_record_f_64_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_f_64(arr[0]), dco_decode_f_64(arr[1]));
  }

  @protected
  (List<(double, double)>, List<(double, double)>)
  dco_decode_record_list_record_f_64_f_64_list_record_f_64_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_list_record_f_64_f_64(arr[0]),
      dco_decode_list_record_f_64_f_64(arr[1]),
    );
  }

  @protected
  (String, double) dco_decode_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_f_64(arr[1]));
  }

  @protected
  RegressionResult dco_decode_regression_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RegressionResult(
      success: dco_decode_bool(arr[0]),
      coefficients: dco_decode_list_prim_f_64_strict(arr[1]),
      rSquared: dco_decode_f_64(arr[2]),
      residuals: dco_decode_list_prim_f_64_strict(arr[3]),
      error: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  SolveResult dco_decode_solve_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SolveResult(
      success: dco_decode_bool(arr[0]),
      roots: dco_decode_list_prim_f_64_strict(arr[1]),
      iterations: dco_decode_usize(arr[2]),
      error: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  StatisticsResult dco_decode_statistics_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return StatisticsResult(
      success: dco_decode_bool(arr[0]),
      values: dco_decode_list_record_string_f_64(arr[1]),
      error: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UnitResult dco_decode_unit_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return UnitResult(
      success: dco_decode_bool(arr[0]),
      value: dco_decode_f_64(arr[1]),
      fromUnit: dco_decode_String(arr[2]),
      toUnit: dco_decode_String(arr[3]),
      formula: dco_decode_String(arr[4]),
      error: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_usize(deserializer));
  }

  @protected
  CalculusResult sse_decode_calculus_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_value = sse_decode_f_64(deserializer);
    final var_symbolic = sse_decode_opt_String(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return CalculusResult(
      success: var_success,
      value: var_value,
      symbolic: var_symbolic,
      error: var_error,
    );
  }

  @protected
  ComplexResult sse_decode_complex_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_real = sse_decode_f_64(deserializer);
    final var_imag = sse_decode_f_64(deserializer);
    final var_magnitude = sse_decode_f_64(deserializer);
    final var_angleRad = sse_decode_f_64(deserializer);
    final var_angleDeg = sse_decode_f_64(deserializer);
    final var_formattedRect = sse_decode_String(deserializer);
    final var_formattedPolar = sse_decode_String(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return ComplexResult(
      success: var_success,
      real: var_real,
      imag: var_imag,
      magnitude: var_magnitude,
      angleRad: var_angleRad,
      angleDeg: var_angleDeg,
      formattedRect: var_formattedRect,
      formattedPolar: var_formattedPolar,
      error: var_error,
    );
  }

  @protected
  ConfidenceIntervalResult sse_decode_confidence_interval_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_lower = sse_decode_f_64(deserializer);
    final var_upper = sse_decode_f_64(deserializer);
    final var_center = sse_decode_f_64(deserializer);
    final var_marginOfError = sse_decode_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return ConfidenceIntervalResult(
      success: var_success,
      lower: var_lower,
      upper: var_upper,
      center: var_center,
      marginOfError: var_marginOfError,
      error: var_error,
    );
  }

  @protected
  CorrelationResult sse_decode_correlation_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_correlation = sse_decode_f_64(deserializer);
    final var_covariance = sse_decode_f_64(deserializer);
    final var_pValue = sse_decode_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return CorrelationResult(
      success: var_success,
      correlation: var_correlation,
      covariance: var_covariance,
      pValue: var_pValue,
      error: var_error,
    );
  }

  @protected
  DiscreteResult sse_decode_discrete_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_value = sse_decode_u_64(deserializer);
    final var_bigValue = sse_decode_opt_String(deserializer);
    final var_values = sse_decode_list_prim_u_64_strict(deserializer);
    final var_boolResult = sse_decode_opt_box_autoadd_bool(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return DiscreteResult(
      success: var_success,
      value: var_value,
      bigValue: var_bigValue,
      values: var_values,
      boolResult: var_boolResult,
      error: var_error,
    );
  }

  @protected
  DistributionResult sse_decode_distribution_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_pdf = sse_decode_f_64(deserializer);
    final var_cdf = sse_decode_f_64(deserializer);
    final var_mean = sse_decode_f_64(deserializer);
    final var_variance = sse_decode_f_64(deserializer);
    final var_stdDev = sse_decode_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return DistributionResult(
      success: var_success,
      pdf: var_pdf,
      cdf: var_cdf,
      mean: var_mean,
      variance: var_variance,
      stdDev: var_stdDev,
      error: var_error,
    );
  }

  @protected
  ExpressionResult sse_decode_expression_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_value = sse_decode_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    final var_formatted = sse_decode_String(deserializer);
    return ExpressionResult(
      success: var_success,
      value: var_value,
      error: var_error,
      formatted: var_formatted,
    );
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  GraphPoint sse_decode_graph_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_x = sse_decode_f_64(deserializer);
    final var_y = sse_decode_f_64(deserializer);
    final var_valid = sse_decode_bool(deserializer);
    return GraphPoint(x: var_x, y: var_y, valid: var_valid);
  }

  @protected
  GraphResult sse_decode_graph_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_points = sse_decode_list_graph_point(deserializer);
    final var_xMin = sse_decode_f_64(deserializer);
    final var_xMax = sse_decode_f_64(deserializer);
    final var_yMin = sse_decode_f_64(deserializer);
    final var_yMax = sse_decode_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return GraphResult(
      success: var_success,
      points: var_points,
      xMin: var_xMin,
      xMax: var_xMax,
      yMin: var_yMin,
      yMax: var_yMax,
      error: var_error,
    );
  }

  @protected
  HypothesisTestResult sse_decode_hypothesis_test_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_testStatistic = sse_decode_f_64(deserializer);
    final var_pValue = sse_decode_f_64(deserializer);
    final var_criticalValue = sse_decode_f_64(deserializer);
    final var_rejectNull = sse_decode_bool(deserializer);
    final var_confidenceInterval = sse_decode_record_f_64_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return HypothesisTestResult(
      success: var_success,
      testStatistic: var_testStatistic,
      pValue: var_pValue,
      criticalValue: var_criticalValue,
      rejectNull: var_rejectNull,
      confidenceInterval: var_confidenceInterval,
      error: var_error,
    );
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<GraphPoint> sse_decode_list_graph_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <GraphPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_graph_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<Float64List> sse_decode_list_list_prim_f_64_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <Float64List>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_prim_f_64_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<MatrixResult> sse_decode_list_matrix_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <MatrixResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_matrix_result(deserializer));
    }
    return ans_;
  }

  @protected
  List<double> sse_decode_list_prim_f_64_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat64List(len_);
  }

  @protected
  Float64List sse_decode_list_prim_f_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat64List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_u_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(double, double)> sse_decode_list_record_f_64_f_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <(double, double)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_f_64_f_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, double)> sse_decode_list_record_string_f_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <(String, double)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_f_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<UnitResult> sse_decode_list_unit_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <UnitResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_unit_result(deserializer));
    }
    return ans_;
  }

  @protected
  MatrixDecomposition sse_decode_matrix_decomposition(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_decompositionType = sse_decode_String(deserializer);
    final var_matrices = sse_decode_list_matrix_result(deserializer);
    final var_labels = sse_decode_list_String(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return MatrixDecomposition(
      success: var_success,
      decompositionType: var_decompositionType,
      matrices: var_matrices,
      labels: var_labels,
      error: var_error,
    );
  }

  @protected
  MatrixResult sse_decode_matrix_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_data = sse_decode_list_prim_f_64_strict(deserializer);
    final var_rows = sse_decode_usize(deserializer);
    final var_cols = sse_decode_usize(deserializer);
    final var_scalar = sse_decode_opt_box_autoadd_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return MatrixResult(
      success: var_success,
      data: var_data,
      rows: var_rows,
      cols: var_cols,
      scalar: var_scalar,
      error: var_error,
    );
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_usize(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Float64List? sse_decode_opt_list_prim_f_64_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_f_64_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (double, double) sse_decode_record_f_64_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_field0 = sse_decode_f_64(deserializer);
    final var_field1 = sse_decode_f_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (List<(double, double)>, List<(double, double)>)
  sse_decode_record_list_record_f_64_f_64_list_record_f_64_f_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_field0 = sse_decode_list_record_f_64_f_64(deserializer);
    final var_field1 = sse_decode_list_record_f_64_f_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, double) sse_decode_record_string_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_field0 = sse_decode_String(deserializer);
    final var_field1 = sse_decode_f_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RegressionResult sse_decode_regression_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_coefficients = sse_decode_list_prim_f_64_strict(deserializer);
    final var_rSquared = sse_decode_f_64(deserializer);
    final var_residuals = sse_decode_list_prim_f_64_strict(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return RegressionResult(
      success: var_success,
      coefficients: var_coefficients,
      rSquared: var_rSquared,
      residuals: var_residuals,
      error: var_error,
    );
  }

  @protected
  SolveResult sse_decode_solve_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_roots = sse_decode_list_prim_f_64_strict(deserializer);
    final var_iterations = sse_decode_usize(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return SolveResult(
      success: var_success,
      roots: var_roots,
      iterations: var_iterations,
      error: var_error,
    );
  }

  @protected
  StatisticsResult sse_decode_statistics_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_values = sse_decode_list_record_string_f_64(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return StatisticsResult(
      success: var_success,
      values: var_values,
      error: var_error,
    );
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UnitResult sse_decode_unit_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_success = sse_decode_bool(deserializer);
    final var_value = sse_decode_f_64(deserializer);
    final var_fromUnit = sse_decode_String(deserializer);
    final var_toUnit = sse_decode_String(deserializer);
    final var_formula = sse_decode_String(deserializer);
    final var_error = sse_decode_opt_String(deserializer);
    return UnitResult(
      success: var_success,
      value: var_value,
      fromUnit: var_fromUnit,
      toUnit: var_toUnit,
      formula: var_formula,
      error: var_error,
    );
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self, serializer);
  }

  @protected
  void sse_encode_calculus_result(
    CalculusResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.value, serializer);
    sse_encode_opt_String(self.symbolic, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_complex_result(ComplexResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.real, serializer);
    sse_encode_f_64(self.imag, serializer);
    sse_encode_f_64(self.magnitude, serializer);
    sse_encode_f_64(self.angleRad, serializer);
    sse_encode_f_64(self.angleDeg, serializer);
    sse_encode_String(self.formattedRect, serializer);
    sse_encode_String(self.formattedPolar, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_confidence_interval_result(
    ConfidenceIntervalResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.lower, serializer);
    sse_encode_f_64(self.upper, serializer);
    sse_encode_f_64(self.center, serializer);
    sse_encode_f_64(self.marginOfError, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_correlation_result(
    CorrelationResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.correlation, serializer);
    sse_encode_f_64(self.covariance, serializer);
    sse_encode_f_64(self.pValue, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_discrete_result(
    DiscreteResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_u_64(self.value, serializer);
    sse_encode_opt_String(self.bigValue, serializer);
    sse_encode_list_prim_u_64_strict(self.values, serializer);
    sse_encode_opt_box_autoadd_bool(self.boolResult, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_distribution_result(
    DistributionResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.pdf, serializer);
    sse_encode_f_64(self.cdf, serializer);
    sse_encode_f_64(self.mean, serializer);
    sse_encode_f_64(self.variance, serializer);
    sse_encode_f_64(self.stdDev, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_expression_result(
    ExpressionResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.value, serializer);
    sse_encode_opt_String(self.error, serializer);
    sse_encode_String(self.formatted, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_graph_point(GraphPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.x, serializer);
    sse_encode_f_64(self.y, serializer);
    sse_encode_bool(self.valid, serializer);
  }

  @protected
  void sse_encode_graph_result(GraphResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_list_graph_point(self.points, serializer);
    sse_encode_f_64(self.xMin, serializer);
    sse_encode_f_64(self.xMax, serializer);
    sse_encode_f_64(self.yMin, serializer);
    sse_encode_f_64(self.yMax, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_hypothesis_test_result(
    HypothesisTestResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.testStatistic, serializer);
    sse_encode_f_64(self.pValue, serializer);
    sse_encode_f_64(self.criticalValue, serializer);
    sse_encode_bool(self.rejectNull, serializer);
    sse_encode_record_f_64_f_64(self.confidenceInterval, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_graph_point(
    List<GraphPoint> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_graph_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_prim_f_64_strict(
    List<Float64List> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_prim_f_64_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_matrix_result(
    List<MatrixResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_matrix_result(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_64_loose(
    List<double> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat64List(
      self is Float64List ? self : Float64List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_f_64_strict(
    Float64List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat64List(self);
  }

  @protected
  void sse_encode_list_prim_u_64_strict(
    Uint64List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_f_64_f_64(
    List<(double, double)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_f_64_f_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_f_64(
    List<(String, double)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_f_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_unit_result(
    List<UnitResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_unit_result(item, serializer);
    }
  }

  @protected
  void sse_encode_matrix_decomposition(
    MatrixDecomposition self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_String(self.decompositionType, serializer);
    sse_encode_list_matrix_result(self.matrices, serializer);
    sse_encode_list_String(self.labels, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_matrix_result(MatrixResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_list_prim_f_64_strict(self.data, serializer);
    sse_encode_usize(self.rows, serializer);
    sse_encode_usize(self.cols, serializer);
    sse_encode_opt_box_autoadd_f_64(self.scalar, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_usize(
    BigInt? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_f_64_strict(
    Float64List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_f_64_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_record_f_64_f_64(
    (double, double) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.$1, serializer);
    sse_encode_f_64(self.$2, serializer);
  }

  @protected
  void sse_encode_record_list_record_f_64_f_64_list_record_f_64_f_64(
    (List<(double, double)>, List<(double, double)>) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_f_64_f_64(self.$1, serializer);
    sse_encode_list_record_f_64_f_64(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_f_64(
    (String, double) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_f_64(self.$2, serializer);
  }

  @protected
  void sse_encode_regression_result(
    RegressionResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_list_prim_f_64_strict(self.coefficients, serializer);
    sse_encode_f_64(self.rSquared, serializer);
    sse_encode_list_prim_f_64_strict(self.residuals, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_solve_result(SolveResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_list_prim_f_64_strict(self.roots, serializer);
    sse_encode_usize(self.iterations, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_statistics_result(
    StatisticsResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_list_record_string_f_64(self.values, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_unit_result(UnitResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_f_64(self.value, serializer);
    sse_encode_String(self.fromUnit, serializer);
    sse_encode_String(self.toUnit, serializer);
    sse_encode_String(self.formula, serializer);
    sse_encode_opt_String(self.error, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }
}
