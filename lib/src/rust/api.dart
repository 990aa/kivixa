// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kivixa/src/rust/clustering.dart';
import 'package:kivixa/src/rust/embeddings.dart';
import 'package:kivixa/src/rust/frb_generated.dart';
import 'package:kivixa/src/rust/graph.dart';
import 'package:kivixa/src/rust/mcp.dart';
import 'package:kivixa/src/rust/streaming.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Initialize an AI model from the given path (auto-detects model type)
void initModel({required String modelPath}) =>
    RustLib.instance.api.crateApiInitModel(modelPath: modelPath);

/// Initialize the model with custom configuration
/// model_type: 0 = Phi4, 1 = Qwen, 2 = Functionary (auto-detected if not in range)
Future<void> initModelWithConfig({
  required String modelPath,
  required int nGpuLayers,
  required int nCtx,
  required int nThreads,
  required double temperature,
  required double topP,
  required int maxTokens,
  int? modelType,
}) => RustLib.instance.api.crateApiInitModelWithConfig(
  modelPath: modelPath,
  nGpuLayers: nGpuLayers,
  nCtx: nCtx,
  nThreads: nThreads,
  temperature: temperature,
  topP: topP,
  maxTokens: maxTokens,
  modelType: modelType,
);

/// Get the loaded model type (0 = Phi4, 1 = Qwen, 2 = Functionary, -1 = not loaded)
int getModelType() => RustLib.instance.api.crateApiGetModelType();

/// Check if the model is loaded
bool isModelLoaded() => RustLib.instance.api.crateApiIsModelLoaded();

/// Unload the model and free resources
void unloadModel() => RustLib.instance.api.crateApiUnloadModel();

/// Get the embedding dimension of the loaded model
BigInt getEmbeddingDimension() =>
    RustLib.instance.api.crateApiGetEmbeddingDimension();

/// Generate text completion from a prompt
Future<String> generateText({required String prompt, int? maxTokens}) => RustLib
    .instance
    .api
    .crateApiGenerateText(prompt: prompt, maxTokens: maxTokens);

/// Chat completion with conversation history
///
/// Messages should be a list of (role, content) tuples where role is
/// "system", "user", or "assistant"
Future<String> chatCompletion({
  required List<(String, String)> messages,
  int? maxTokens,
}) => RustLib.instance.api.crateApiChatCompletion(
  messages: messages,
  maxTokens: maxTokens,
);

/// Extract topics from note content
Future<List<String>> extractTopics({required String text, int? numTopics}) =>
    RustLib.instance.api.crateApiExtractTopics(
      text: text,
      numTopics: numTopics,
    );

/// Get embedding for text
Future<Float32List> getEmbedding({required String text}) =>
    RustLib.instance.api.crateApiGetEmbedding(text: text);

/// Compute embeddings for multiple texts
Future<List<EmbeddingEntry>> batchEmbed({required List<String> texts}) =>
    RustLib.instance.api.crateApiBatchEmbed(texts: texts);

/// Find similar entries to a query embedding
Future<List<SimilarityResult>> findSimilar({
  required List<double> query,
  required List<EmbeddingEntry> entries,
  required BigInt topK,
  required double threshold,
}) => RustLib.instance.api.crateApiFindSimilar(
  query: query,
  entries: entries,
  topK: topK,
  threshold: threshold,
);

/// Semantic search: embed query and find similar entries
Future<List<SimilarityResult>> semanticSearch({
  required String queryText,
  required List<EmbeddingEntry> entries,
  required BigInt topK,
}) => RustLib.instance.api.crateApiSemanticSearch(
  queryText: queryText,
  entries: entries,
  topK: topK,
);

/// Cluster embeddings by similarity
Future<List<EmbeddingCluster>> clusterEmbeddings({
  required List<EmbeddingEntry> entries,
  required double threshold,
}) => RustLib.instance.api.crateApiClusterEmbeddings(
  entries: entries,
  threshold: threshold,
);

/// Compute cosine similarity between two vectors
double cosineSimilarity({required List<double> a, required List<double> b}) =>
    RustLib.instance.api.crateApiCosineSimilarity(a: a, b: b);

/// Initialize the knowledge graph
void initGraph() => RustLib.instance.api.crateApiInitGraph();

/// Add a node to the graph
Future<void> addGraphNode({
  required String id,
  required String label,
  required String nodeType,
  required double x,
  required double y,
  String? color,
  String? metadata,
}) => RustLib.instance.api.crateApiAddGraphNode(
  id: id,
  label: label,
  nodeType: nodeType,
  x: x,
  y: y,
  color: color,
  metadata: metadata,
);

/// Add multiple nodes at once
Future<void> addGraphNodes({required List<GraphNode> nodes}) =>
    RustLib.instance.api.crateApiAddGraphNodes(nodes: nodes);

/// Remove a node from the graph
Future<void> removeGraphNode({required String nodeId}) =>
    RustLib.instance.api.crateApiRemoveGraphNode(nodeId: nodeId);

/// Add an edge to the graph
Future<void> addGraphEdge({
  required String source,
  required String target,
  required double weight,
  required String edgeType,
}) => RustLib.instance.api.crateApiAddGraphEdge(
  source: source,
  target: target,
  weight: weight,
  edgeType: edgeType,
);

/// Add multiple edges at once
Future<void> addGraphEdges({required List<GraphEdge> edges}) =>
    RustLib.instance.api.crateApiAddGraphEdges(edges: edges);

/// Compute physics-based layout
Future<GraphState> computeGraphLayout({int? iterations}) =>
    RustLib.instance.api.crateApiComputeGraphLayout(iterations: iterations);

/// Get current graph state
Future<GraphState> getGraphState() =>
    RustLib.instance.api.crateApiGetGraphState();

/// Clear the graph
void clearGraph() => RustLib.instance.api.crateApiClearGraph();

/// Connect a note to topic hubs
Future<void> connectNoteToTopics({
  required String noteId,
  required List<String> topicIds,
}) => RustLib.instance.api.crateApiConnectNoteToTopics(
  noteId: noteId,
  topicIds: topicIds,
);

/// Get or create a topic hub node
Future<String> getOrCreateTopicHub({required String topic}) =>
    RustLib.instance.api.crateApiGetOrCreateTopicHub(topic: topic);

/// Simple health check
String healthCheck() => RustLib.instance.api.crateApiHealthCheck();

/// Get version info
String getVersion() => RustLib.instance.api.crateApiGetVersion();

/// Start the graph streaming simulation
/// This runs physics simulation at 60fps and streams visible nodes
Future<void> startGraphStream() =>
    RustLib.instance.api.crateApiStartGraphStream();

/// Stop the graph streaming simulation
void stopGraphStream() => RustLib.instance.api.crateApiStopGraphStream();

/// Check if the graph stream is currently running
bool isGraphStreamRunning() =>
    RustLib.instance.api.crateApiIsGraphStreamRunning();

/// Update the viewport for culling
/// Only nodes within the viewport will be sent to Flutter
Future<void> updateGraphViewport({
  required double x,
  required double y,
  required double width,
  required double height,
  required double scale,
}) => RustLib.instance.api.crateApiUpdateGraphViewport(
  x: x,
  y: y,
  width: width,
  height: height,
  scale: scale,
);

/// Get visible nodes within the current viewport
/// Returns positions for nodes that should be rendered
Future<List<NodePosition>> getVisibleGraphNodes() =>
    RustLib.instance.api.crateApiGetVisibleGraphNodes();

/// Add a node to the streaming graph
Future<void> addStreamNode({
  required String id,
  required double x,
  required double y,
  required double radius,
  required int color,
}) => RustLib.instance.api.crateApiAddStreamNode(
  id: id,
  x: x,
  y: y,
  radius: radius,
  color: color,
);

/// Remove a node from the streaming graph
Future<void> removeStreamNode({required String id}) =>
    RustLib.instance.api.crateApiRemoveStreamNode(id: id);

/// Add an edge to the streaming graph
Future<void> addStreamEdge({
  required String fromId,
  required String toId,
  required double strength,
}) => RustLib.instance.api.crateApiAddStreamEdge(
  fromId: fromId,
  toId: toId,
  strength: strength,
);

/// Remove an edge from the streaming graph
Future<void> removeStreamEdge({required String fromId, required String toId}) =>
    RustLib.instance.api.crateApiRemoveStreamEdge(fromId: fromId, toId: toId);

/// Pin a node at its current position (stops physics for that node)
Future<void> pinStreamNode({required String id, required bool pinned}) =>
    RustLib.instance.api.crateApiPinStreamNode(id: id, pinned: pinned);

/// Set node position (for dragging)
Future<void> setStreamNodePosition({
  required String id,
  required double x,
  required double y,
}) => RustLib.instance.api.crateApiSetStreamNodePosition(id: id, x: x, y: y);

/// Clear all nodes and edges from the streaming graph
void clearStreamGraph() => RustLib.instance.api.crateApiClearStreamGraph();

/// Get stats about the streaming graph
StreamGraphStats getStreamGraphStats() =>
    RustLib.instance.api.crateApiGetStreamGraphStats();

/// Run K-Means clustering on note embeddings
///
/// # Arguments
/// * `entries` - List of embedding entries to cluster
/// * `k` - Number of clusters (if None, auto-detect based on data size)
/// * `max_iterations` - Maximum K-Means iterations (default: 100)
///
/// # Returns
/// * Clustering result with assignments and metadata
Future<ClusteringResult> clusterNotes({
  required List<EmbeddingEntry> entries,
  BigInt? k,
  BigInt? maxIterations,
}) => RustLib.instance.api.crateApiClusterNotes(
  entries: entries,
  k: k,
  maxIterations: maxIterations,
);

/// Discover semantic edges between notes based on embedding similarity
///
/// # Arguments
/// * `entries` - List of embedding entries
/// * `threshold` - Minimum similarity for edge creation (default: 0.85)
/// * `existing_links` - Optional list of existing hard links (source, target pairs)
///
/// # Returns
/// * Semantic edges with similarity scores
Future<SemanticEdgeResult> discoverSemanticEdges({
  required List<EmbeddingEntry> entries,
  double? threshold,
  List<(String, String)>? existingLinks,
}) => RustLib.instance.api.crateApiDiscoverSemanticEdges(
  entries: entries,
  threshold: threshold,
  existingLinks: existingLinks,
);

/// Analyze knowledge graph: cluster and find semantic edges in one pass
///
/// More efficient than calling both functions separately
Future<KnowledgeGraphAnalysis> analyzeKnowledgeGraph({
  required List<EmbeddingEntry> entries,
  BigInt? k,
  double? similarityThreshold,
  List<(String, String)>? existingLinks,
}) => RustLib.instance.api.crateApiAnalyzeKnowledgeGraph(
  entries: entries,
  k: k,
  similarityThreshold: similarityThreshold,
  existingLinks: existingLinks,
);

/// Initialize the MCP system with configuration
///
/// # Arguments
/// * `base_path` - Base path for file operations (browse/ directory)
/// * `max_file_size` - Maximum file size in bytes (default: 10MB)
/// * `allowed_extensions` - Optional list of allowed file extensions
Future<void> initMcp({
  required String basePath,
  BigInt? maxFileSize,
  List<String>? allowedExtensions,
}) => RustLib.instance.api.crateApiInitMcp(
  basePath: basePath,
  maxFileSize: maxFileSize,
  allowedExtensions: allowedExtensions,
);

/// Check if MCP is initialized
bool isMcpInitialized() => RustLib.instance.api.crateApiIsMcpInitialized();

/// Validate a file path for MCP operations
///
/// # Arguments
/// * `path` - Relative path to validate
///
/// # Returns
/// * `true` if path is valid and within sandbox
bool mcpValidatePath({required String path}) =>
    RustLib.instance.api.crateApiMcpValidatePath(path: path);

/// Read a file via MCP
///
/// # Arguments
/// * `path` - Relative path within browse/ folder
///
/// # Returns
/// * File contents as string
Future<String> mcpReadFile({required String path}) =>
    RustLib.instance.api.crateApiMcpReadFile(path: path);

/// Write a file via MCP
///
/// # Arguments
/// * `path` - Relative path within browse/ folder
/// * `content` - Content to write
Future<void> mcpWriteFile({required String path, required String content}) =>
    RustLib.instance.api.crateApiMcpWriteFile(path: path, content: content);

/// Delete a file via MCP
///
/// # Arguments
/// * `path` - Relative path within browse/ folder
Future<void> mcpDeleteFile({required String path}) =>
    RustLib.instance.api.crateApiMcpDeleteFile(path: path);

/// Create a folder via MCP
///
/// # Arguments
/// * `path` - Relative path within browse/ folder
Future<void> mcpCreateFolder({required String path}) =>
    RustLib.instance.api.crateApiMcpCreateFolder(path: path);

/// List files in a directory via MCP
///
/// # Arguments
/// * `path` - Relative path within browse/ folder (empty for root)
///
/// # Returns
/// * List of file/folder names
Future<List<String>> mcpListFiles({required String path}) =>
    RustLib.instance.api.crateApiMcpListFiles(path: path);

/// Get tool schemas for AI prompt construction
///
/// # Returns
/// * JSON string containing tool schemas
String mcpGetToolSchemas() => RustLib.instance.api.crateApiMcpGetToolSchemas();

/// Parse a tool call from AI response
///
/// # Arguments
/// * `json` - JSON string representing the tool call
///
/// # Returns
/// * Parsed tool call structure
Future<MCPToolCall> mcpParseToolCall({required String json}) =>
    RustLib.instance.api.crateApiMcpParseToolCall(json: json);

/// Execute a tool call
///
/// # Arguments
/// * `tool_call` - The tool call to execute
///
/// # Returns
/// * Result of the tool execution
Future<MCPToolResult> mcpExecuteToolCall({required MCPToolCall toolCall}) =>
    RustLib.instance.api.crateApiMcpExecuteToolCall(toolCall: toolCall);

/// Classify a task based on user message
///
/// # Arguments
/// * `message` - User message to classify
///
/// # Returns
/// * Task category (Conversation, ToolUse, CodeGeneration)
TaskCategory mcpClassifyTask({required String message}) =>
    RustLib.instance.api.crateApiMcpClassifyTask(message: message);

/// Get the recommended model for a task category
///
/// # Arguments
/// * `category` - Task category
///
/// # Returns
/// * Model name string
String mcpGetModelForTask({required TaskCategory category}) =>
    RustLib.instance.api.crateApiMcpGetModelForTask(category: category);

/// Get all available MCP tools
List<MCPTool> mcpGetAllTools() => RustLib.instance.api.crateApiMcpGetAllTools();

/// Get tool name
String mcpGetToolName({required MCPTool tool}) =>
    RustLib.instance.api.crateApiMcpGetToolName(tool: tool);

/// Get tool description
String mcpGetToolDescription({required MCPTool tool}) =>
    RustLib.instance.api.crateApiMcpGetToolDescription(tool: tool);

/// Get tool parameters
List<MCPParameter> mcpGetToolParameters({required MCPTool tool}) =>
    RustLib.instance.api.crateApiMcpGetToolParameters(tool: tool);

/// A cluster of embedding IDs
class EmbeddingCluster {
  /// IDs of embeddings in this cluster
  final List<String> ids;

  const EmbeddingCluster({required this.ids});

  @override
  int get hashCode => ids.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EmbeddingCluster &&
          runtimeType == other.runtimeType &&
          ids == other.ids;
}

/// Combined result of knowledge graph analysis
class KnowledgeGraphAnalysis {
  /// Cluster assignments for each note
  final ClusteringResult clustering;

  /// Discovered semantic edges
  final SemanticEdgeResult semanticEdges;

  const KnowledgeGraphAnalysis({
    required this.clustering,
    required this.semanticEdges,
  });

  @override
  int get hashCode => clustering.hashCode ^ semanticEdges.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KnowledgeGraphAnalysis &&
          runtimeType == other.runtimeType &&
          clustering == other.clustering &&
          semanticEdges == other.semanticEdges;
}

/// Statistics about the streaming graph
class StreamGraphStats {
  final BigInt nodeCount;
  final BigInt edgeCount;
  final BigInt visibleCount;

  const StreamGraphStats({
    required this.nodeCount,
    required this.edgeCount,
    required this.visibleCount,
  });

  @override
  int get hashCode =>
      nodeCount.hashCode ^ edgeCount.hashCode ^ visibleCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StreamGraphStats &&
          runtimeType == other.runtimeType &&
          nodeCount == other.nodeCount &&
          edgeCount == other.edgeCount &&
          visibleCount == other.visibleCount;
}
