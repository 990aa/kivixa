// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kivixa/src/rust/frb_generated.dart';

/// Cluster assignment result
class ClusterAssignment {
  /// Note/node ID
  final String id;

  /// Assigned cluster ID (0-based)
  final BigInt clusterId;

  /// Cluster color (hex string)
  final String color;

  const ClusterAssignment({
    required this.id,
    required this.clusterId,
    required this.color,
  });

  @override
  int get hashCode => id.hashCode ^ clusterId.hashCode ^ color.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClusterAssignment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          clusterId == other.clusterId &&
          color == other.color;
}

/// Cluster metadata
class ClusterInfo {
  /// Cluster ID
  final BigInt id;

  /// Number of nodes in cluster
  final BigInt size;

  /// Representative color
  final String color;

  /// Centroid position (if computed)
  final Float32List? centroid;

  const ClusterInfo({
    required this.id,
    required this.size,
    required this.color,
    this.centroid,
  });

  @override
  int get hashCode =>
      id.hashCode ^ size.hashCode ^ color.hashCode ^ centroid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClusterInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          size == other.size &&
          color == other.color &&
          centroid == other.centroid;
}

/// Result of clustering operation
class ClusteringResult {
  /// Individual node assignments
  final List<ClusterAssignment> assignments;

  /// Cluster metadata
  final List<ClusterInfo> clusters;

  /// Number of clusters
  final BigInt k;

  const ClusteringResult({
    required this.assignments,
    required this.clusters,
    required this.k,
  });

  @override
  int get hashCode => assignments.hashCode ^ clusters.hashCode ^ k.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClusteringResult &&
          runtimeType == other.runtimeType &&
          assignments == other.assignments &&
          clusters == other.clusters &&
          k == other.k;
}

/// Semantic edge discovered through embedding similarity
class SemanticEdge {
  /// Source node ID
  final String source;

  /// Target node ID
  final String target;

  /// Similarity score (0.0 to 1.0)
  final double similarity;

  /// Whether this is a "ghost" edge (no hard link exists)
  final bool isGhost;

  const SemanticEdge({
    required this.source,
    required this.target,
    required this.similarity,
    required this.isGhost,
  });

  @override
  int get hashCode =>
      source.hashCode ^
      target.hashCode ^
      similarity.hashCode ^
      isGhost.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SemanticEdge &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          target == other.target &&
          similarity == other.similarity &&
          isGhost == other.isGhost;
}

/// Result of semantic edge discovery
class SemanticEdgeResult {
  /// Discovered semantic edges
  final List<SemanticEdge> edges;

  /// Total edges found
  final BigInt count;

  const SemanticEdgeResult({required this.edges, required this.count});

  @override
  int get hashCode => edges.hashCode ^ count.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SemanticEdgeResult &&
          runtimeType == other.runtimeType &&
          edges == other.edges &&
          count == other.count;
}
