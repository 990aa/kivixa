// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kivixa/src/rust/api.dart';
import 'package:kivixa/src/rust/embeddings.dart';
import 'package:kivixa/src/rust/frb_generated.dart';
import 'package:kivixa/src/rust/frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:kivixa/src/rust/graph.dart';
import 'package:kivixa/src/rust/streaming.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1602308821;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'kivixa_native',
        ioDirectory: '',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiAddGraphEdge({
    required String source,
    required String target,
    required double weight,
    required String edgeType,
  });

  Future<void> crateApiAddGraphEdges({required List<GraphEdge> edges});

  Future<void> crateApiAddGraphNode({
    required String id,
    required String label,
    required String nodeType,
    required double x,
    required double y,
    String? color,
    String? metadata,
  });

  Future<void> crateApiAddGraphNodes({required List<GraphNode> nodes});

  Future<void> crateApiAddStreamEdge({
    required String fromId,
    required String toId,
    required double strength,
  });

  Future<void> crateApiAddStreamNode({
    required String id,
    required double x,
    required double y,
    required double radius,
    required int color,
  });

  Future<List<EmbeddingEntry>> crateApiBatchEmbed({
    required List<String> texts,
  });

  Future<String> crateApiChatCompletion({
    required List<(String, String)> messages,
    int? maxTokens,
  });

  void crateApiClearGraph();

  void crateApiClearStreamGraph();

  Future<List<EmbeddingCluster>> crateApiClusterEmbeddings({
    required List<EmbeddingEntry> entries,
    required double threshold,
  });

  Future<GraphState> crateApiComputeGraphLayout({int? iterations});

  Future<void> crateApiConnectNoteToTopics({
    required String noteId,
    required List<String> topicIds,
  });

  double crateApiCosineSimilarity({
    required List<double> a,
    required List<double> b,
  });

  Future<List<String>> crateApiExtractTopics({
    required String text,
    int? numTopics,
  });

  Future<List<SimilarityResult>> crateApiFindSimilar({
    required List<double> query,
    required List<EmbeddingEntry> entries,
    required BigInt topK,
    required double threshold,
  });

  Future<String> crateApiGenerateText({required String prompt, int? maxTokens});

  Future<Float32List> crateApiGetEmbedding({required String text});

  BigInt crateApiGetEmbeddingDimension();

  Future<GraphState> crateApiGetGraphState();

  Future<String> crateApiGetOrCreateTopicHub({required String topic});

  StreamGraphStats crateApiGetStreamGraphStats();

  String crateApiGetVersion();

  Future<List<NodePosition>> crateApiGetVisibleGraphNodes();

  String crateApiHealthCheck();

  void crateApiInitGraph();

  void crateApiInitModel({required String modelPath});

  Future<void> crateApiInitModelWithConfig({
    required String modelPath,
    required int nGpuLayers,
    required int nCtx,
    required int nThreads,
    required double temperature,
    required double topP,
    required int maxTokens,
  });

  bool crateApiIsGraphStreamRunning();

  bool crateApiIsModelLoaded();

  Future<void> crateApiPinStreamNode({
    required String id,
    required bool pinned,
  });

  Future<void> crateApiRemoveGraphNode({required String nodeId});

  Future<void> crateApiRemoveStreamEdge({
    required String fromId,
    required String toId,
  });

  Future<void> crateApiRemoveStreamNode({required String id});

  Future<List<SimilarityResult>> crateApiSemanticSearch({
    required String queryText,
    required List<EmbeddingEntry> entries,
    required BigInt topK,
  });

  Future<void> crateApiSetStreamNodePosition({
    required String id,
    required double x,
    required double y,
  });

  Future<void> crateApiStartGraphStream();

  void crateApiStopGraphStream();

  void crateApiUnloadModel();

  Future<void> crateApiUpdateGraphViewport({
    required double x,
    required double y,
    required double width,
    required double height,
    required double scale,
  });
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiAddGraphEdge({
    required String source,
    required String target,
    required double weight,
    required String edgeType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(source);
          final arg1 = cst_encode_String(target);
          final arg2 = cst_encode_f_32(weight);
          final arg3 = cst_encode_String(edgeType);
          return wire.wire__crate__api__add_graph_edge(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddGraphEdgeConstMeta,
        argValues: [source, target, weight, edgeType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddGraphEdgeConstMeta => const TaskConstMeta(
    debugName: 'add_graph_edge',
    argNames: ['source', 'target', 'weight', 'edgeType'],
  );

  @override
  Future<void> crateApiAddGraphEdges({required List<GraphEdge> edges}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_graph_edge(edges);
          return wire.wire__crate__api__add_graph_edges(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddGraphEdgesConstMeta,
        argValues: [edges],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddGraphEdgesConstMeta =>
      const TaskConstMeta(debugName: 'add_graph_edges', argNames: ['edges']);

  @override
  Future<void> crateApiAddGraphNode({
    required String id,
    required String label,
    required String nodeType,
    required double x,
    required double y,
    String? color,
    String? metadata,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(id);
          final arg1 = cst_encode_String(label);
          final arg2 = cst_encode_String(nodeType);
          final arg3 = cst_encode_f_32(x);
          final arg4 = cst_encode_f_32(y);
          final arg5 = cst_encode_opt_String(color);
          final arg6 = cst_encode_opt_String(metadata);
          return wire.wire__crate__api__add_graph_node(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddGraphNodeConstMeta,
        argValues: [id, label, nodeType, x, y, color, metadata],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddGraphNodeConstMeta => const TaskConstMeta(
    debugName: 'add_graph_node',
    argNames: ['id', 'label', 'nodeType', 'x', 'y', 'color', 'metadata'],
  );

  @override
  Future<void> crateApiAddGraphNodes({required List<GraphNode> nodes}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_graph_node(nodes);
          return wire.wire__crate__api__add_graph_nodes(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddGraphNodesConstMeta,
        argValues: [nodes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddGraphNodesConstMeta =>
      const TaskConstMeta(debugName: 'add_graph_nodes', argNames: ['nodes']);

  @override
  Future<void> crateApiAddStreamEdge({
    required String fromId,
    required String toId,
    required double strength,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(fromId);
          final arg1 = cst_encode_String(toId);
          final arg2 = cst_encode_f_32(strength);
          return wire.wire__crate__api__add_stream_edge(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddStreamEdgeConstMeta,
        argValues: [fromId, toId, strength],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddStreamEdgeConstMeta => const TaskConstMeta(
    debugName: 'add_stream_edge',
    argNames: ['fromId', 'toId', 'strength'],
  );

  @override
  Future<void> crateApiAddStreamNode({
    required String id,
    required double x,
    required double y,
    required double radius,
    required int color,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(id);
          final arg1 = cst_encode_f_32(x);
          final arg2 = cst_encode_f_32(y);
          final arg3 = cst_encode_f_32(radius);
          final arg4 = cst_encode_u_32(color);
          return wire.wire__crate__api__add_stream_node(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddStreamNodeConstMeta,
        argValues: [id, x, y, radius, color],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddStreamNodeConstMeta => const TaskConstMeta(
    debugName: 'add_stream_node',
    argNames: ['id', 'x', 'y', 'radius', 'color'],
  );

  @override
  Future<List<EmbeddingEntry>> crateApiBatchEmbed({
    required List<String> texts,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_String(texts);
          return wire.wire__crate__api__batch_embed(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_embedding_entry,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiBatchEmbedConstMeta,
        argValues: [texts],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBatchEmbedConstMeta =>
      const TaskConstMeta(debugName: 'batch_embed', argNames: ['texts']);

  @override
  Future<String> crateApiChatCompletion({
    required List<(String, String)> messages,
    int? maxTokens,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_record_string_string(messages);
          final arg1 = cst_encode_opt_box_autoadd_u_32(maxTokens);
          return wire.wire__crate__api__chat_completion(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiChatCompletionConstMeta,
        argValues: [messages, maxTokens],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiChatCompletionConstMeta => const TaskConstMeta(
    debugName: 'chat_completion',
    argNames: ['messages', 'maxTokens'],
  );

  @override
  void crateApiClearGraph() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__clear_graph();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiClearGraphConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClearGraphConstMeta =>
      const TaskConstMeta(debugName: 'clear_graph', argNames: []);

  @override
  void crateApiClearStreamGraph() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__clear_stream_graph();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiClearStreamGraphConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClearStreamGraphConstMeta =>
      const TaskConstMeta(debugName: 'clear_stream_graph', argNames: []);

  @override
  Future<List<EmbeddingCluster>> crateApiClusterEmbeddings({
    required List<EmbeddingEntry> entries,
    required double threshold,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_embedding_entry(entries);
          final arg1 = cst_encode_f_32(threshold);
          return wire.wire__crate__api__cluster_embeddings(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_embedding_cluster,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiClusterEmbeddingsConstMeta,
        argValues: [entries, threshold],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiClusterEmbeddingsConstMeta => const TaskConstMeta(
    debugName: 'cluster_embeddings',
    argNames: ['entries', 'threshold'],
  );

  @override
  Future<GraphState> crateApiComputeGraphLayout({int? iterations}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_opt_box_autoadd_u_32(iterations);
          return wire.wire__crate__api__compute_graph_layout(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_graph_state,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiComputeGraphLayoutConstMeta,
        argValues: [iterations],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiComputeGraphLayoutConstMeta => const TaskConstMeta(
    debugName: 'compute_graph_layout',
    argNames: ['iterations'],
  );

  @override
  Future<void> crateApiConnectNoteToTopics({
    required String noteId,
    required List<String> topicIds,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(noteId);
          final arg1 = cst_encode_list_String(topicIds);
          return wire.wire__crate__api__connect_note_to_topics(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiConnectNoteToTopicsConstMeta,
        argValues: [noteId, topicIds],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConnectNoteToTopicsConstMeta =>
      const TaskConstMeta(
        debugName: 'connect_note_to_topics',
        argNames: ['noteId', 'topicIds'],
      );

  @override
  double crateApiCosineSimilarity({
    required List<double> a,
    required List<double> b,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_list_prim_f_32_loose(a);
          final arg1 = cst_encode_list_prim_f_32_loose(b);
          return wire.wire__crate__api__cosine_similarity(arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_f_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCosineSimilarityConstMeta,
        argValues: [a, b],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCosineSimilarityConstMeta =>
      const TaskConstMeta(debugName: 'cosine_similarity', argNames: ['a', 'b']);

  @override
  Future<List<String>> crateApiExtractTopics({
    required String text,
    int? numTopics,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(text);
          final arg1 = cst_encode_opt_box_autoadd_u_32(numTopics);
          return wire.wire__crate__api__extract_topics(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiExtractTopicsConstMeta,
        argValues: [text, numTopics],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiExtractTopicsConstMeta => const TaskConstMeta(
    debugName: 'extract_topics',
    argNames: ['text', 'numTopics'],
  );

  @override
  Future<List<SimilarityResult>> crateApiFindSimilar({
    required List<double> query,
    required List<EmbeddingEntry> entries,
    required BigInt topK,
    required double threshold,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_list_prim_f_32_loose(query);
          final arg1 = cst_encode_list_embedding_entry(entries);
          final arg2 = cst_encode_usize(topK);
          final arg3 = cst_encode_f_32(threshold);
          return wire.wire__crate__api__find_similar(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_similarity_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFindSimilarConstMeta,
        argValues: [query, entries, topK, threshold],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFindSimilarConstMeta => const TaskConstMeta(
    debugName: 'find_similar',
    argNames: ['query', 'entries', 'topK', 'threshold'],
  );

  @override
  Future<String> crateApiGenerateText({
    required String prompt,
    int? maxTokens,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(prompt);
          final arg1 = cst_encode_opt_box_autoadd_u_32(maxTokens);
          return wire.wire__crate__api__generate_text(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGenerateTextConstMeta,
        argValues: [prompt, maxTokens],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGenerateTextConstMeta => const TaskConstMeta(
    debugName: 'generate_text',
    argNames: ['prompt', 'maxTokens'],
  );

  @override
  Future<Float32List> crateApiGetEmbedding({required String text}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(text);
          return wire.wire__crate__api__get_embedding(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_f_32_strict,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetEmbeddingConstMeta,
        argValues: [text],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetEmbeddingConstMeta =>
      const TaskConstMeta(debugName: 'get_embedding', argNames: ['text']);

  @override
  BigInt crateApiGetEmbeddingDimension() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__get_embedding_dimension();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetEmbeddingDimensionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetEmbeddingDimensionConstMeta =>
      const TaskConstMeta(debugName: 'get_embedding_dimension', argNames: []);

  @override
  Future<GraphState> crateApiGetGraphState() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_graph_state(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_graph_state,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetGraphStateConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetGraphStateConstMeta =>
      const TaskConstMeta(debugName: 'get_graph_state', argNames: []);

  @override
  Future<String> crateApiGetOrCreateTopicHub({required String topic}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(topic);
          return wire.wire__crate__api__get_or_create_topic_hub(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetOrCreateTopicHubConstMeta,
        argValues: [topic],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetOrCreateTopicHubConstMeta =>
      const TaskConstMeta(
        debugName: 'get_or_create_topic_hub',
        argNames: ['topic'],
      );

  @override
  StreamGraphStats crateApiGetStreamGraphStats() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__get_stream_graph_stats();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_stream_graph_stats,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetStreamGraphStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetStreamGraphStatsConstMeta =>
      const TaskConstMeta(debugName: 'get_stream_graph_stats', argNames: []);

  @override
  String crateApiGetVersion() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__get_version();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetVersionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVersionConstMeta =>
      const TaskConstMeta(debugName: 'get_version', argNames: []);

  @override
  Future<List<NodePosition>> crateApiGetVisibleGraphNodes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__get_visible_graph_nodes(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_node_position,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetVisibleGraphNodesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetVisibleGraphNodesConstMeta =>
      const TaskConstMeta(debugName: 'get_visible_graph_nodes', argNames: []);

  @override
  String crateApiHealthCheck() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__health_check();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiHealthCheckConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHealthCheckConstMeta =>
      const TaskConstMeta(debugName: 'health_check', argNames: []);

  @override
  void crateApiInitGraph() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__init_graph();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitGraphConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitGraphConstMeta =>
      const TaskConstMeta(debugName: 'init_graph', argNames: []);

  @override
  void crateApiInitModel({required String modelPath}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final arg0 = cst_encode_String(modelPath);
          return wire.wire__crate__api__init_model(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitModelConstMeta,
        argValues: [modelPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitModelConstMeta =>
      const TaskConstMeta(debugName: 'init_model', argNames: ['modelPath']);

  @override
  Future<void> crateApiInitModelWithConfig({
    required String modelPath,
    required int nGpuLayers,
    required int nCtx,
    required int nThreads,
    required double temperature,
    required double topP,
    required int maxTokens,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(modelPath);
          final arg1 = cst_encode_u_32(nGpuLayers);
          final arg2 = cst_encode_u_32(nCtx);
          final arg3 = cst_encode_i_32(nThreads);
          final arg4 = cst_encode_f_32(temperature);
          final arg5 = cst_encode_f_32(topP);
          final arg6 = cst_encode_u_32(maxTokens);
          return wire.wire__crate__api__init_model_with_config(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiInitModelWithConfigConstMeta,
        argValues: [
          modelPath,
          nGpuLayers,
          nCtx,
          nThreads,
          temperature,
          topP,
          maxTokens,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitModelWithConfigConstMeta =>
      const TaskConstMeta(
        debugName: 'init_model_with_config',
        argNames: [
          'modelPath',
          'nGpuLayers',
          'nCtx',
          'nThreads',
          'temperature',
          'topP',
          'maxTokens',
        ],
      );

  @override
  bool crateApiIsGraphStreamRunning() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__is_graph_stream_running();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsGraphStreamRunningConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsGraphStreamRunningConstMeta =>
      const TaskConstMeta(debugName: 'is_graph_stream_running', argNames: []);

  @override
  bool crateApiIsModelLoaded() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__is_model_loaded();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsModelLoadedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsModelLoadedConstMeta =>
      const TaskConstMeta(debugName: 'is_model_loaded', argNames: []);

  @override
  Future<void> crateApiPinStreamNode({
    required String id,
    required bool pinned,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(id);
          final arg1 = cst_encode_bool(pinned);
          return wire.wire__crate__api__pin_stream_node(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiPinStreamNodeConstMeta,
        argValues: [id, pinned],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPinStreamNodeConstMeta => const TaskConstMeta(
    debugName: 'pin_stream_node',
    argNames: ['id', 'pinned'],
  );

  @override
  Future<void> crateApiRemoveGraphNode({required String nodeId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(nodeId);
          return wire.wire__crate__api__remove_graph_node(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiRemoveGraphNodeConstMeta,
        argValues: [nodeId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRemoveGraphNodeConstMeta =>
      const TaskConstMeta(debugName: 'remove_graph_node', argNames: ['nodeId']);

  @override
  Future<void> crateApiRemoveStreamEdge({
    required String fromId,
    required String toId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(fromId);
          final arg1 = cst_encode_String(toId);
          return wire.wire__crate__api__remove_stream_edge(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiRemoveStreamEdgeConstMeta,
        argValues: [fromId, toId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRemoveStreamEdgeConstMeta => const TaskConstMeta(
    debugName: 'remove_stream_edge',
    argNames: ['fromId', 'toId'],
  );

  @override
  Future<void> crateApiRemoveStreamNode({required String id}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(id);
          return wire.wire__crate__api__remove_stream_node(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiRemoveStreamNodeConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRemoveStreamNodeConstMeta =>
      const TaskConstMeta(debugName: 'remove_stream_node', argNames: ['id']);

  @override
  Future<List<SimilarityResult>> crateApiSemanticSearch({
    required String queryText,
    required List<EmbeddingEntry> entries,
    required BigInt topK,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(queryText);
          final arg1 = cst_encode_list_embedding_entry(entries);
          final arg2 = cst_encode_usize(topK);
          return wire.wire__crate__api__semantic_search(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_similarity_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiSemanticSearchConstMeta,
        argValues: [queryText, entries, topK],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSemanticSearchConstMeta => const TaskConstMeta(
    debugName: 'semantic_search',
    argNames: ['queryText', 'entries', 'topK'],
  );

  @override
  Future<void> crateApiSetStreamNodePosition({
    required String id,
    required double x,
    required double y,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_String(id);
          final arg1 = cst_encode_f_32(x);
          final arg2 = cst_encode_f_32(y);
          return wire.wire__crate__api__set_stream_node_position(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetStreamNodePositionConstMeta,
        argValues: [id, x, y],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetStreamNodePositionConstMeta =>
      const TaskConstMeta(
        debugName: 'set_stream_node_position',
        argNames: ['id', 'x', 'y'],
      );

  @override
  Future<void> crateApiStartGraphStream() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__start_graph_stream(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiStartGraphStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStartGraphStreamConstMeta =>
      const TaskConstMeta(debugName: 'start_graph_stream', argNames: []);

  @override
  void crateApiStopGraphStream() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__stop_graph_stream();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiStopGraphStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopGraphStreamConstMeta =>
      const TaskConstMeta(debugName: 'stop_graph_stream', argNames: []);

  @override
  void crateApiUnloadModel() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__unload_model();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiUnloadModelConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnloadModelConstMeta =>
      const TaskConstMeta(debugName: 'unload_model', argNames: []);

  @override
  Future<void> crateApiUpdateGraphViewport({
    required double x,
    required double y,
    required double width,
    required double height,
    required double scale,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final arg0 = cst_encode_f_32(x);
          final arg1 = cst_encode_f_32(y);
          final arg2 = cst_encode_f_32(width);
          final arg3 = cst_encode_f_32(height);
          final arg4 = cst_encode_f_32(scale);
          return wire.wire__crate__api__update_graph_viewport(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUpdateGraphViewportConstMeta,
        argValues: [x, y, width, height, scale],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUpdateGraphViewportConstMeta =>
      const TaskConstMeta(
        debugName: 'update_graph_viewport',
        argNames: ['x', 'y', 'width', 'height', 'scale'],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  EmbeddingCluster dco_decode_embedding_cluster(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return EmbeddingCluster(ids: dco_decode_list_String(arr[0]));
  }

  @protected
  EmbeddingEntry dco_decode_embedding_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EmbeddingEntry(
      id: dco_decode_String(arr[0]),
      vector: dco_decode_list_prim_f_32_strict(arr[1]),
      textPreview: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GraphEdge dco_decode_graph_edge(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GraphEdge(
      source: dco_decode_String(arr[0]),
      target: dco_decode_String(arr[1]),
      weight: dco_decode_f_32(arr[2]),
      edgeType: dco_decode_String(arr[3]),
    );
  }

  @protected
  GraphNode dco_decode_graph_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return GraphNode(
      id: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
      nodeType: dco_decode_String(arr[2]),
      x: dco_decode_f_32(arr[3]),
      y: dco_decode_f_32(arr[4]),
      color: dco_decode_opt_String(arr[5]),
      metadata: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  GraphState dco_decode_graph_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GraphState(
      nodes: dco_decode_list_graph_node(arr[0]),
      edges: dco_decode_list_graph_edge(arr[1]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<EmbeddingCluster> dco_decode_list_embedding_cluster(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_embedding_cluster).toList();
  }

  @protected
  List<EmbeddingEntry> dco_decode_list_embedding_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_embedding_entry).toList();
  }

  @protected
  List<GraphEdge> dco_decode_list_graph_edge(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_graph_edge).toList();
  }

  @protected
  List<GraphNode> dco_decode_list_graph_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_graph_node).toList();
  }

  @protected
  List<NodePosition> dco_decode_list_node_position(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_node_position).toList();
  }

  @protected
  List<double> dco_decode_list_prim_f_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<double>;
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<SimilarityResult> dco_decode_list_similarity_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_similarity_result).toList();
  }

  @protected
  NodePosition dco_decode_node_position(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return NodePosition(
      id: dco_decode_String(arr[0]),
      x: dco_decode_f_32(arr[1]),
      y: dco_decode_f_32(arr[2]),
      radius: dco_decode_f_32(arr[3]),
      color: dco_decode_u_32(arr[4]),
      nodeType: dco_decode_String(arr[5]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_String(arr[1]));
  }

  @protected
  SimilarityResult dco_decode_similarity_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SimilarityResult(
      id: dco_decode_String(arr[0]),
      score: dco_decode_f_32(arr[1]),
      textPreview: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  StreamGraphStats dco_decode_stream_graph_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return StreamGraphStats(
      nodeCount: dco_decode_usize(arr[0]),
      edgeCount: dco_decode_usize(arr[1]),
      visibleCount: dco_decode_usize(arr[2]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  EmbeddingCluster sse_decode_embedding_cluster(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_ids = sse_decode_list_String(deserializer);
    return EmbeddingCluster(ids: var_ids);
  }

  @protected
  EmbeddingEntry sse_decode_embedding_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_String(deserializer);
    final var_vector = sse_decode_list_prim_f_32_strict(deserializer);
    final var_textPreview = sse_decode_opt_String(deserializer);
    return EmbeddingEntry(
      id: var_id,
      vector: var_vector,
      textPreview: var_textPreview,
    );
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  GraphEdge sse_decode_graph_edge(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_source = sse_decode_String(deserializer);
    final var_target = sse_decode_String(deserializer);
    final var_weight = sse_decode_f_32(deserializer);
    final var_edgeType = sse_decode_String(deserializer);
    return GraphEdge(
      source: var_source,
      target: var_target,
      weight: var_weight,
      edgeType: var_edgeType,
    );
  }

  @protected
  GraphNode sse_decode_graph_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_String(deserializer);
    final var_label = sse_decode_String(deserializer);
    final var_nodeType = sse_decode_String(deserializer);
    final var_x = sse_decode_f_32(deserializer);
    final var_y = sse_decode_f_32(deserializer);
    final var_color = sse_decode_opt_String(deserializer);
    final var_metadata = sse_decode_opt_String(deserializer);
    return GraphNode(
      id: var_id,
      label: var_label,
      nodeType: var_nodeType,
      x: var_x,
      y: var_y,
      color: var_color,
      metadata: var_metadata,
    );
  }

  @protected
  GraphState sse_decode_graph_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_nodes = sse_decode_list_graph_node(deserializer);
    final var_edges = sse_decode_list_graph_edge(deserializer);
    return GraphState(nodes: var_nodes, edges: var_edges);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<EmbeddingCluster> sse_decode_list_embedding_cluster(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <EmbeddingCluster>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_embedding_cluster(deserializer));
    }
    return ans_;
  }

  @protected
  List<EmbeddingEntry> sse_decode_list_embedding_entry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <EmbeddingEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_embedding_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<GraphEdge> sse_decode_list_graph_edge(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <GraphEdge>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_graph_edge(deserializer));
    }
    return ans_;
  }

  @protected
  List<GraphNode> sse_decode_list_graph_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <GraphNode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_graph_node(deserializer));
    }
    return ans_;
  }

  @protected
  List<NodePosition> sse_decode_list_node_position(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <NodePosition>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_node_position(deserializer));
    }
    return ans_;
  }

  @protected
  List<double> sse_decode_list_prim_f_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<SimilarityResult> sse_decode_list_similarity_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <SimilarityResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_similarity_result(deserializer));
    }
    return ans_;
  }

  @protected
  NodePosition sse_decode_node_position(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_String(deserializer);
    final var_x = sse_decode_f_32(deserializer);
    final var_y = sse_decode_f_32(deserializer);
    final var_radius = sse_decode_f_32(deserializer);
    final var_color = sse_decode_u_32(deserializer);
    final var_nodeType = sse_decode_String(deserializer);
    return NodePosition(
      id: var_id,
      x: var_x,
      y: var_y,
      radius: var_radius,
      color: var_color,
      nodeType: var_nodeType,
    );
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, String) sse_decode_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_field0 = sse_decode_String(deserializer);
    final var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  SimilarityResult sse_decode_similarity_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_id = sse_decode_String(deserializer);
    final var_score = sse_decode_f_32(deserializer);
    final var_textPreview = sse_decode_opt_String(deserializer);
    return SimilarityResult(
      id: var_id,
      score: var_score,
      textPreview: var_textPreview,
    );
  }

  @protected
  StreamGraphStats sse_decode_stream_graph_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_nodeCount = sse_decode_usize(deserializer);
    final var_edgeCount = sse_decode_usize(deserializer);
    final var_visibleCount = sse_decode_usize(deserializer);
    return StreamGraphStats(
      nodeCount: var_nodeCount,
      edgeCount: var_edgeCount,
      visibleCount: var_visibleCount,
    );
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_embedding_cluster(
    EmbeddingCluster self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.ids, serializer);
  }

  @protected
  void sse_encode_embedding_entry(
    EmbeddingEntry self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_list_prim_f_32_strict(self.vector, serializer);
    sse_encode_opt_String(self.textPreview, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_graph_edge(GraphEdge self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.source, serializer);
    sse_encode_String(self.target, serializer);
    sse_encode_f_32(self.weight, serializer);
    sse_encode_String(self.edgeType, serializer);
  }

  @protected
  void sse_encode_graph_node(GraphNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.nodeType, serializer);
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
    sse_encode_opt_String(self.color, serializer);
    sse_encode_opt_String(self.metadata, serializer);
  }

  @protected
  void sse_encode_graph_state(GraphState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_graph_node(self.nodes, serializer);
    sse_encode_list_graph_edge(self.edges, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_embedding_cluster(
    List<EmbeddingCluster> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_embedding_cluster(item, serializer);
    }
  }

  @protected
  void sse_encode_list_embedding_entry(
    List<EmbeddingEntry> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_embedding_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_graph_edge(
    List<GraphEdge> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_graph_edge(item, serializer);
    }
  }

  @protected
  void sse_encode_list_graph_node(
    List<GraphNode> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_graph_node(item, serializer);
    }
  }

  @protected
  void sse_encode_list_node_position(
    List<NodePosition> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_node_position(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_loose(
    List<double> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(
      self is Float32List ? self : Float32List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_f_32_strict(
    Float32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_string(
    List<(String, String)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_similarity_result(
    List<SimilarityResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_similarity_result(item, serializer);
    }
  }

  @protected
  void sse_encode_node_position(NodePosition self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
    sse_encode_f_32(self.radius, serializer);
    sse_encode_u_32(self.color, serializer);
    sse_encode_String(self.nodeType, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_string(
    (String, String) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_similarity_result(
    SimilarityResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_f_32(self.score, serializer);
    sse_encode_opt_String(self.textPreview, serializer);
  }

  @protected
  void sse_encode_stream_graph_stats(
    StreamGraphStats self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.nodeCount, serializer);
    sse_encode_usize(self.edgeCount, serializer);
    sse_encode_usize(self.visibleCount, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
