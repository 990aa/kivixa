import 'dart:async';
import 'dart:convert'; // Added for jsonEncode/jsonDecode
import 'package:drift/drift.dart' as drift;
import 'package:kivixa/data/database.dart';

class DocumentRepository {
  DocumentRepository(this._db);

  final AppDatabase _db;

  Stream<List<DocumentData>> watchDocuments() {
    return _db.select(_db.documents).watch();
  }

  Future<DocumentData> getDocument(int id) {
    return (_db.select(_db.documents)..where((tbl) => tbl.id.equals(id))).getSingle();
  }

  Future<DocumentData> createDocument(String title) {
    return _db.into(_db.documents).insertReturning(DocumentsCompanion.insert(title: title));
  }

  Future<bool> updateDocument(DocumentData entry) {
    final updates = DocumentsCompanion(
      title: drift.Value(entry.title),
    );
    return _db.update(_db.documents)
        .where((tbl) => tbl.id.equals(entry.id))
        .write(updates)
        .then((numberOfAffectedRows) => numberOfAffectedRows > 0);
  }

  Future<int> deleteDocument(int id) {
    return (_db.delete(_db.documents)..where((tbl) => tbl.id.equals(id))).go();
  }

  Future<List<Map<String, dynamic>>> listPages({required int documentId}) async {
    // Assuming a 'Pages' table (`_db.pages`) with PageData class generated by Drift.
    // And columns: id, documentId, pageNumber (example).
    // You'll need to define this table in your AppDatabase.
    final query = _db.select(_db.pages)..where((tbl) => tbl.documentId.equals(documentId));
    final pageEntries = await query.get();
    return pageEntries.map((entry) {
      // Assuming PageData has at least id and pageNumber. Adjust as per your PageData structure.
      return {
        'id': entry.id,
        'document_id': entry.documentId, // Assuming documentId is part of PageData
        // Add other relevant page properties here, e.g.:
        // 'pageNumber': entry.pageNumber,
        // 'thumbnail_path': entry.thumbnailPath, // If you have it
      };
    }).toList();
  }

  Future<void> updateImage(int imageId, Map<String, dynamic> data) async {
    // Assuming an 'Images' table (`_db.images`) and ImagesCompanion class generated by Drift.
    // And columns: assetPath, transform (TEXT for JSON).
    // You'll need to define this table in your AppDatabase.
    final companion = ImagesCompanion(
      assetPath: data.containsKey('asset_path') 
          ? drift.Value(data['asset_path'] as String)
          : const drift.Value.absent(),
      transform: data.containsKey('transform') 
          ? drift.Value(jsonEncode(data['transform'])) 
          : const drift.Value.absent(),
      // Add other fields from your Images table if necessary
    );
    await (_db.update(_db.images)..where((tbl) => tbl.id.equals(imageId))).write(companion);
  }

  Future<Map<String, dynamic>?> getImage(int imageId) async {
    // Assuming an 'Images' table (`_db.images`) and ImageData class generated by Drift.
    // And columns: id, assetPath, thumbnailPath, transform (TEXT for JSON).
    // You'll need to define this table in your AppDatabase.
    final imageData = await (_db.select(_db.images)..where((tbl) => tbl.id.equals(imageId))).getSingleOrNull();
    if (imageData != null) {
      return {
        'id': imageData.id,
        'asset_path': imageData.assetPath, // Assuming ImageData has assetPath
        'thumbnail_path': imageData.thumbnailPath, // Assuming ImageData has thumbnailPath
        'transform': imageData.transform != null 
            ? jsonDecode(imageData.transform!) // Assuming transform is a String field
            : null,
      };
    }
    return null;
  }

  Future<Map<String, dynamic>?> getTemplate(int templateId) async {
    // Assuming a 'Templates' table (`_db.templates`) and TemplateData class generated by Drift.
    // And columns: id, name, content.
    // You'll need to define this table in your AppDatabase.
    final templateData = await (_db.select(_db.templates)..where((tbl) => tbl.id.equals(templateId))).getSingleOrNull();
    if (templateData != null) {
      return {
        'id': templateData.id,
        'name': templateData.name, // Assuming TemplateData has name
        'content': templateData.content, // Assuming TemplateData has content
      };
    }
    return null;
  }

  Future<void> createMinimapTile(Map<String, dynamic> tileData) async {
    final documentId = tileData['document_id'] as int?;
    final x = tileData['x'] as int?;
    final y = tileData['y'] as int?;
    final dynamic rawData = tileData['data'];

    if (documentId == null || x == null || y == null || rawData == null) {
      print('DocumentRepository.createMinimapTile: Missing required fields in tileData. $tileData');
      return;
    }

    final String jsonData;
    if (rawData is String) {
      jsonData = rawData;
    } else {
      jsonData = jsonEncode(rawData);
    }

    final companion = MinimapTilesCompanion.insert(
      documentId: documentId,
      x: x,
      y: y,
      data: jsonData,
    );

    await _db.into(_db.minimapTiles).insert(companion, mode: drift.InsertMode.replace);
  }
}

// Added Repository interface based on SQLiteRepository methods
abstract class Repository {
  Future<int> createNotebook(Map<String, dynamic> data);
  Future<Map<String, dynamic>?> getNotebook(int id);
  Future<List<Map<String, dynamic>>> listNotebooks({
    int? limit,
    int? offset,
  });
  Future<void> updateNotebook(int id, Map<String, dynamic> data);
  Future<void> deleteNotebook(int id);

  Future<int> createDocument(Map<String, dynamic> data);
  Future<Map<String, dynamic>?> getDocument(int id);
  Future<List<Map<String, dynamic>>> listDocuments({
    int? notebookId,
    int? parentId,
    String? orderBy,
    int? limit,
    int? offset,
  });
  Future<void> updateDocument(int id, Map<String, dynamic> data);
  Future<void> deleteDocument(int id);

  Future<void> updateUserSetting(String userId, String key, Map<String, dynamic> data);
  Future<List<Map<String, dynamic>>> listUserSettings({
    String? userId,
    int? limit,
    int? offset,
  });

  Future<void> batchWrite(List<Function()> operations);

  Future<void> updatePageThumbnailMetadata(int pageId, Map<String, dynamic> metadata);

  Future<List<Map<String, dynamic>>> listPages({required int documentId, int? limit, int? offset});

  Future<Map<String, dynamic>?> getPageThumbnail(int pageId); 
  Future<Map<String, dynamic>?> getAsset(int assetId); 

  // Methods for TextBlocksService
  Future<void> updateTextBlock(int textBlockId, Map<String, dynamic> data);
  Future<Map<String, dynamic>?> getTextBlock(int textBlockId);
}
