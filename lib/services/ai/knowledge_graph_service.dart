// Knowledge Graph Service
//
// Manages the knowledge graph for note relationships and topic clustering.
// Uses force-directed graph layout computed in native Rust.

import 'dart:async';

import 'package:flutter/foundation.dart';

// Note: These imports will be generated by flutter_rust_bridge
// import 'package:kivixa/src/rust/api.dart' as native;

/// A node in the knowledge graph
class GraphNode {
  final String id;
  final String label;
  final String nodeType; // "note", "topic", or "hub"
  double x;
  double y;
  final String? color;
  final Map<String, dynamic>? metadata;

  GraphNode({
    required this.id,
    required this.label,
    required this.nodeType,
    this.x = 0.0,
    this.y = 0.0,
    this.color,
    this.metadata,
  });

  GraphNode copyWith({
    String? id,
    String? label,
    String? nodeType,
    double? x,
    double? y,
    String? color,
    Map<String, dynamic>? metadata,
  }) {
    return GraphNode(
      id: id ?? this.id,
      label: label ?? this.label,
      nodeType: nodeType ?? this.nodeType,
      x: x ?? this.x,
      y: y ?? this.y,
      color: color ?? this.color,
      metadata: metadata ?? this.metadata,
    );
  }
}

/// An edge in the knowledge graph
class GraphEdge {
  final String source;
  final String target;
  final double weight;
  final String edgeType; // "topic", "link", or "similarity"

  const GraphEdge({
    required this.source,
    required this.target,
    this.weight = 1.0,
    this.edgeType = 'link',
  });
}

/// Complete graph state
class GraphState {
  final List<GraphNode> nodes;
  final List<GraphEdge> edges;

  const GraphState({required this.nodes, required this.edges});

  GraphState.empty() : nodes = const [], edges = const [];
}

/// Knowledge Graph Service singleton
class KnowledgeGraphService {
  static final _instance =
      KnowledgeGraphService._internal();
  factory KnowledgeGraphService() => _instance;
  KnowledgeGraphService._internal();

  var _isInitialized = false;

  final _stateController = StreamController<GraphState>.broadcast();

  /// Stream of graph state updates
  Stream<GraphState> get stateStream => _stateController.stream;

  /// Current graph state (cached)
  var _currentState = GraphState.empty();
  GraphState get currentState => _currentState;

  /// Whether the service is initialized
  bool get isInitialized => _isInitialized;

  /// Initialize the knowledge graph service
  Future<void> initialize() async {
    if (_isInitialized) return;

    // native.initGraph();
    _isInitialized = true;
    debugPrint('KnowledgeGraphService initialized');
  }

  /// Add a note node to the graph
  Future<void> addNote({
    required String noteId,
    required String title,
    String? color,
    Map<String, dynamic>? metadata,
  }) async {
    await initialize();

    final node = GraphNode(
      id: noteId,
      label: title,
      nodeType: 'note',
      color: color,
      metadata: metadata,
    );

    // native.addGraphNode(
    //   id: node.id,
    //   label: node.label,
    //   nodeType: node.nodeType,
    //   x: node.x,
    //   y: node.y,
    //   color: node.color,
    //   metadata: metadata != null ? jsonEncode(metadata) : null,
    // );

    _currentState = GraphState(
      nodes: [..._currentState.nodes, node],
      edges: _currentState.edges,
    );
    _stateController.add(_currentState);
  }

  /// Remove a note node from the graph
  Future<void> removeNote(String noteId) async {
    await initialize();

    // native.removeGraphNode(nodeId: noteId);

    _currentState = GraphState(
      nodes: _currentState.nodes.where((n) => n.id != noteId).toList(),
      edges: _currentState.edges
          .where((e) => e.source != noteId && e.target != noteId)
          .toList(),
    );
    _stateController.add(_currentState);
  }

  /// Link a note to topic hubs
  ///
  /// This creates topic hub nodes if they don't exist, and connects
  /// the note to them so they cluster together in the visualization.
  Future<void> linkNoteToTopics(String noteId, List<String> topics) async {
    await initialize();

    for (final topic in topics) {
      // Get or create topic hub
      final hubId = 'hub_${topic.toLowerCase().replaceAll(' ', '_')}';

      // Check if hub exists
      final hubExists = _currentState.nodes.any((n) => n.id == hubId);
      if (!hubExists) {
        final hubNode = GraphNode(
          id: hubId,
          label: topic,
          nodeType: 'hub',
          color: '#6200EE', // Material primary
        );

        // native.addGraphNode(
        //   id: hubNode.id,
        //   label: hubNode.label,
        //   nodeType: hubNode.nodeType,
        //   x: hubNode.x,
        //   y: hubNode.y,
        //   color: hubNode.color,
        // );

        _currentState = GraphState(
          nodes: [..._currentState.nodes, hubNode],
          edges: _currentState.edges,
        );
      }

      // Add edge from note to hub
      final edge = GraphEdge(source: noteId, target: hubId, edgeType: 'topic');

      // native.addGraphEdge(
      //   source: edge.source,
      //   target: edge.target,
      //   weight: edge.weight,
      //   edgeType: edge.edgeType,
      // );

      _currentState = GraphState(
        nodes: _currentState.nodes,
        edges: [..._currentState.edges, edge],
      );
    }

    _stateController.add(_currentState);
  }

  /// Create a direct link between two notes
  Future<void> linkNotes(String sourceId, String targetId) async {
    await initialize();

    final edge = GraphEdge(
      source: sourceId,
      target: targetId,
      edgeType: 'link',
    );

    // native.addGraphEdge(
    //   source: edge.source,
    //   target: edge.target,
    //   weight: edge.weight,
    //   edgeType: edge.edgeType,
    // );

    _currentState = GraphState(
      nodes: _currentState.nodes,
      edges: [..._currentState.edges, edge],
    );
    _stateController.add(_currentState);
  }

  /// Compute physics-based layout
  ///
  /// Runs the force-directed simulation to position nodes.
  Future<GraphState> computeLayout({int iterations = 100}) async {
    await initialize();

    // final nativeState = await native.computeGraphLayout(iterations: iterations);

    // Convert native state to Dart objects
    // final nodes = nativeState.nodes.map((n) => GraphNode(
    //   id: n.id,
    //   label: n.label,
    //   nodeType: n.nodeType,
    //   x: n.x,
    //   y: n.y,
    //   color: n.color,
    // )).toList();

    // final edges = nativeState.edges.map((e) => GraphEdge(
    //   source: e.source,
    //   target: e.target,
    //   weight: e.weight,
    //   edgeType: e.edgeType,
    // )).toList();

    // Placeholder: just return current state
    // In production, this would update positions from native
    _stateController.add(_currentState);
    return _currentState;
  }

  /// Get current graph state from native
  Future<GraphState> getState() async {
    await initialize();

    // final nativeState = await native.getGraphState();
    // Convert and return...

    return _currentState;
  }

  /// Clear the graph
  Future<void> clear() async {
    await initialize();

    // native.clearGraph();

    _currentState = GraphState.empty();
    _stateController.add(_currentState);
  }

  /// Build graph from all notes
  ///
  /// Loads all notes and their links to build the complete graph.
  Future<void> buildFromNotes(
    Future<List<Map<String, dynamic>>> Function() getNotes,
    Future<List<String>> Function(String noteContent) extractTopics,
  ) async {
    await initialize();
    await clear();

    final notes = await getNotes();

    for (final note in notes) {
      final noteId = note['id'] as String;
      final title = note['title'] as String? ?? 'Untitled';
      final content = note['content'] as String? ?? '';
      final color = note['color'] as String?;

      // Add note node
      await addNote(noteId: noteId, title: title, color: color);

      // Extract and link topics
      if (content.isNotEmpty) {
        try {
          final topics = await extractTopics(content);
          await linkNoteToTopics(noteId, topics);
        } catch (e) {
          debugPrint('Failed to extract topics for note $noteId: $e');
        }
      }

      // Handle explicit note links if present
      final links = note['links'] as List<String>? ?? [];
      for (final linkedId in links) {
        await linkNotes(noteId, linkedId);
      }
    }

    // Compute layout after building
    await computeLayout();
  }

  /// Dispose resources
  void dispose() {
    _stateController.close();
  }
}
