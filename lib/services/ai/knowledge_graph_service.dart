// Knowledge Graph Service
//
// Manages the knowledge graph for note relationships and topic clustering.
// Uses force-directed graph layout computed in native Rust.

import 'dart:async';
import 'dart:math' show sqrt;

import 'package:flutter/foundation.dart';

// Note: These imports will be generated by flutter_rust_bridge
// import 'package:kivixa/src/rust/api.dart' as native;

/// A node in the knowledge graph
class GraphNode {
  final String id;
  final String label;
  final String nodeType; // "note", "topic", or "hub"
  double x;
  double y;
  final String? color;
  final Map<String, dynamic>? metadata;

  GraphNode({
    required this.id,
    required this.label,
    required this.nodeType,
    this.x = 0.0,
    this.y = 0.0,
    this.color,
    this.metadata,
  });

  GraphNode copyWith({
    String? id,
    String? label,
    String? nodeType,
    double? x,
    double? y,
    String? color,
    Map<String, dynamic>? metadata,
  }) {
    return GraphNode(
      id: id ?? this.id,
      label: label ?? this.label,
      nodeType: nodeType ?? this.nodeType,
      x: x ?? this.x,
      y: y ?? this.y,
      color: color ?? this.color,
      metadata: metadata ?? this.metadata,
    );
  }
}

/// An edge in the knowledge graph
class GraphEdge {
  final String source;
  final String target;
  final double weight;
  final String edgeType; // "topic", "link", or "similarity"

  const GraphEdge({
    required this.source,
    required this.target,
    this.weight = 1.0,
    this.edgeType = 'link',
  });
}

/// Complete graph state
class GraphState {
  final List<GraphNode> nodes;
  final List<GraphEdge> edges;

  const GraphState({required this.nodes, required this.edges});

  GraphState.empty() : nodes = const [], edges = const [];
}

/// Knowledge Graph Service singleton
class KnowledgeGraphService {
  static final _instance = KnowledgeGraphService._internal();
  factory KnowledgeGraphService() => _instance;
  KnowledgeGraphService._internal();

  var _isInitialized = false;

  final _stateController = StreamController<GraphState>.broadcast();

  /// Stream of graph state updates
  Stream<GraphState> get stateStream => _stateController.stream;

  /// Current graph state (cached)
  var _currentState = GraphState.empty();
  GraphState get currentState => _currentState;

  /// Whether the service is initialized
  bool get isInitialized => _isInitialized;

  /// Initialize the knowledge graph service
  Future<void> initialize() async {
    if (_isInitialized) return;

    // native.initGraph();
    _isInitialized = true;
    debugPrint('KnowledgeGraphService initialized');
  }

  /// Add a note node to the graph
  Future<void> addNote({
    required String noteId,
    required String title,
    String? color,
    Map<String, dynamic>? metadata,
  }) async {
    await initialize();

    final node = GraphNode(
      id: noteId,
      label: title,
      nodeType: 'note',
      color: color,
      metadata: metadata,
    );

    // native.addGraphNode(
    //   id: node.id,
    //   label: node.label,
    //   nodeType: node.nodeType,
    //   x: node.x,
    //   y: node.y,
    //   color: node.color,
    //   metadata: metadata != null ? jsonEncode(metadata) : null,
    // );

    _currentState = GraphState(
      nodes: [..._currentState.nodes, node],
      edges: _currentState.edges,
    );
    _stateController.add(_currentState);
  }

  /// Remove a note node from the graph
  Future<void> removeNote(String noteId) async {
    await initialize();

    // native.removeGraphNode(nodeId: noteId);

    _currentState = GraphState(
      nodes: _currentState.nodes.where((n) => n.id != noteId).toList(),
      edges: _currentState.edges
          .where((e) => e.source != noteId && e.target != noteId)
          .toList(),
    );
    _stateController.add(_currentState);
  }

  /// Link a note to topic hubs
  ///
  /// This creates topic hub nodes if they don't exist, and connects
  /// the note to them so they cluster together in the visualization.
  Future<void> linkNoteToTopics(String noteId, List<String> topics) async {
    await initialize();

    for (final topic in topics) {
      // Get or create topic hub
      final hubId = 'hub_${topic.toLowerCase().replaceAll(' ', '_')}';

      // Check if hub exists
      final hubExists = _currentState.nodes.any((n) => n.id == hubId);
      if (!hubExists) {
        final hubNode = GraphNode(
          id: hubId,
          label: topic,
          nodeType: 'hub',
          color: '#6200EE', // Material primary
        );

        // native.addGraphNode(
        //   id: hubNode.id,
        //   label: hubNode.label,
        //   nodeType: hubNode.nodeType,
        //   x: hubNode.x,
        //   y: hubNode.y,
        //   color: hubNode.color,
        // );

        _currentState = GraphState(
          nodes: [..._currentState.nodes, hubNode],
          edges: _currentState.edges,
        );
      }

      // Add edge from note to hub
      final edge = GraphEdge(source: noteId, target: hubId, edgeType: 'topic');

      // native.addGraphEdge(
      //   source: edge.source,
      //   target: edge.target,
      //   weight: edge.weight,
      //   edgeType: edge.edgeType,
      // );

      _currentState = GraphState(
        nodes: _currentState.nodes,
        edges: [..._currentState.edges, edge],
      );
    }

    _stateController.add(_currentState);
  }

  /// Create a direct link between two notes
  Future<void> linkNotes(String sourceId, String targetId) async {
    await initialize();

    final edge = GraphEdge(
      source: sourceId,
      target: targetId,
      edgeType: 'link',
    );

    // native.addGraphEdge(
    //   source: edge.source,
    //   target: edge.target,
    //   weight: edge.weight,
    //   edgeType: edge.edgeType,
    // );

    _currentState = GraphState(
      nodes: _currentState.nodes,
      edges: [..._currentState.edges, edge],
    );
    _stateController.add(_currentState);
  }

  /// Compute physics-based layout
  ///
  /// Runs the force-directed simulation to position nodes.
  Future<GraphState> computeLayout({int iterations = 100}) async {
    await initialize();

    // final nativeState = await native.computeGraphLayout(iterations: iterations);

    // Convert native state to Dart objects
    // final nodes = nativeState.nodes.map((n) => GraphNode(
    //   id: n.id,
    //   label: n.label,
    //   nodeType: n.nodeType,
    //   x: n.x,
    //   y: n.y,
    //   color: n.color,
    // )).toList();

    // final edges = nativeState.edges.map((e) => GraphEdge(
    //   source: e.source,
    //   target: e.target,
    //   weight: e.weight,
    //   edgeType: e.edgeType,
    // )).toList();

    // Placeholder: just return current state
    // In production, this would update positions from native
    _stateController.add(_currentState);
    return _currentState;
  }

  /// Get current graph state from native
  Future<GraphState> getState() async {
    await initialize();

    // final nativeState = await native.getGraphState();
    // Convert and return...

    return _currentState;
  }

  /// Clear the graph
  Future<void> clear() async {
    await initialize();

    // native.clearGraph();

    _currentState = GraphState.empty();
    _stateController.add(_currentState);
  }

  /// Build graph from all notes
  ///
  /// Loads all notes and their links to build the complete graph.
  Future<void> buildFromNotes(
    Future<List<Map<String, dynamic>>> Function() getNotes,
    Future<List<String>> Function(String noteContent) extractTopics,
  ) async {
    await initialize();
    await clear();

    final notes = await getNotes();

    for (final note in notes) {
      final noteId = note['id'] as String;
      final title = note['title'] as String? ?? 'Untitled';
      final content = note['content'] as String? ?? '';
      final color = note['color'] as String?;

      // Add note node
      await addNote(noteId: noteId, title: title, color: color);

      // Extract and link topics
      if (content.isNotEmpty) {
        try {
          final topics = await extractTopics(content);
          await linkNoteToTopics(noteId, topics);
        } catch (e) {
          debugPrint('Failed to extract topics for note $noteId: $e');
        }
      }

      // Handle explicit note links if present
      final links = note['links'] as List<String>? ?? [];
      for (final linkedId in links) {
        await linkNotes(noteId, linkedId);
      }
    }

    // Compute layout after building
    await computeLayout();
  }

  /// Cluster notes using K-Means on embeddings
  ///
  /// Groups similar notes into clusters and assigns colors.
  /// Requires embeddings to be pre-computed for each note.
  ///
  /// Returns map of noteId -> (clusterId, color)
  Future<Map<String, ClusterAssignment>> clusterNotes({
    required List<NoteEmbedding> embeddings,
    int? k,
  }) async {
    if (embeddings.isEmpty) return {};

    try {
      // Call native clustering
      // final result = await native.clusterNotes(
      //   entries: embeddings.map((e) => native.EmbeddingEntry(
      //     id: e.noteId,
      //     vector: e.embedding,
      //     textPreview: e.preview,
      //   )).toList(),
      //   k: k,
      // );

      // Placeholder: simple hash-based clustering
      final assignments = <String, ClusterAssignment>{};
      final clusterColors = [
        '#FF6B6B',
        '#4ECDC4',
        '#45B7D1',
        '#96CEB4',
        '#FFEAA7',
        '#DDA0DD',
        '#FF8C42',
        '#98D8C8',
      ];

      for (var i = 0; i < embeddings.length; i++) {
        final entry = embeddings[i];
        final clusterId = i % (k ?? 8);
        assignments[entry.noteId] = ClusterAssignment(
          noteId: entry.noteId,
          clusterId: clusterId,
          color: clusterColors[clusterId % clusterColors.length],
        );
      }

      // Update node colors in current state
      final updatedNodes = _currentState.nodes.map((node) {
        final assignment = assignments[node.id];
        if (assignment != null) {
          return node.copyWith(color: assignment.color);
        }
        return node;
      }).toList();

      _currentState = GraphState(
        nodes: updatedNodes,
        edges: _currentState.edges,
      );
      _stateController.add(_currentState);

      return assignments;
    } catch (e) {
      debugPrint('Clustering failed: $e');
      return {};
    }
  }

  /// Discover semantic edges between similar notes
  ///
  /// Finds notes with high embedding similarity that aren't explicitly linked.
  /// Creates "ghost edges" for these hidden connections.
  ///
  /// [threshold] - Minimum similarity (0-1) for edge creation (default: 0.85)
  Future<List<SemanticEdgeResult>> discoverSemanticEdges({
    required List<NoteEmbedding> embeddings,
    double threshold = 0.85,
  }) async {
    if (embeddings.length < 2) return [];

    try {
      // Get existing links
      final existingLinks = _currentState.edges
          .map((e) => (e.source, e.target))
          .toList();

      // Call native semantic edge discovery
      // final result = await native.discoverSemanticEdges(
      //   entries: embeddings.map((e) => native.EmbeddingEntry(
      //     id: e.noteId,
      //     vector: e.embedding,
      //     textPreview: e.preview,
      //   )).toList(),
      //   threshold: threshold,
      //   existingLinks: existingLinks,
      // );

      // Placeholder: simple cosine similarity
      final semanticEdges = <SemanticEdgeResult>[];

      for (var i = 0; i < embeddings.length; i++) {
        for (var j = i + 1; j < embeddings.length; j++) {
          final similarity = _cosineSimilarity(
            embeddings[i].embedding,
            embeddings[j].embedding,
          );

          if (similarity >= threshold) {
            final source = embeddings[i].noteId;
            final target = embeddings[j].noteId;

            // Check if explicit link exists
            final isGhost = !existingLinks.any(
              (link) =>
                  (link.$1 == source && link.$2 == target) ||
                  (link.$1 == target && link.$2 == source),
            );

            semanticEdges.add(
              SemanticEdgeResult(
                source: source,
                target: target,
                similarity: similarity,
                isGhost: isGhost,
              ),
            );
          }
        }
      }

      // Add ghost edges to graph
      for (final edge in semanticEdges.where((e) => e.isGhost)) {
        final graphEdge = GraphEdge(
          source: edge.source,
          target: edge.target,
          weight: edge.similarity,
          edgeType: 'similarity',
        );

        _currentState = GraphState(
          nodes: _currentState.nodes,
          edges: [..._currentState.edges, graphEdge],
        );
      }

      if (semanticEdges.any((e) => e.isGhost)) {
        _stateController.add(_currentState);
      }

      return semanticEdges;
    } catch (e) {
      debugPrint('Semantic edge discovery failed: $e');
      return [];
    }
  }

  /// Calculate cosine similarity between two vectors
  double _cosineSimilarity(List<double> a, List<double> b) {
    if (a.length != b.length) return 0.0;

    var dotProduct = 0.0;
    var normA = 0.0;
    var normB = 0.0;

    for (var i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }

    if (normA == 0 || normB == 0) return 0.0;
    return dotProduct / sqrt(normA * normB);
  }

  /// Full analysis: cluster notes and find semantic edges
  Future<GraphAnalysisResult> analyzeGraph({
    required List<NoteEmbedding> embeddings,
    int? k,
    double similarityThreshold = 0.85,
  }) async {
    final clusters = await clusterNotes(embeddings: embeddings, k: k);
    final semanticEdges = await discoverSemanticEdges(
      embeddings: embeddings,
      threshold: similarityThreshold,
    );

    return GraphAnalysisResult(
      clusters: clusters,
      semanticEdges: semanticEdges,
      clusterCount: clusters.values.map((c) => c.clusterId).toSet().length,
      ghostEdgeCount: semanticEdges.where((e) => e.isGhost).length,
    );
  }

  /// Dispose resources
  void dispose() {
    _stateController.close();
  }
}

/// Note embedding data for clustering
class NoteEmbedding {
  final String noteId;
  final List<double> embedding;
  final String? preview;

  const NoteEmbedding({
    required this.noteId,
    required this.embedding,
    this.preview,
  });
}

/// Cluster assignment for a note
class ClusterAssignment {
  final String noteId;
  final int clusterId;
  final String color;

  const ClusterAssignment({
    required this.noteId,
    required this.clusterId,
    required this.color,
  });
}

/// Semantic edge discovery result
class SemanticEdgeResult {
  final String source;
  final String target;
  final double similarity;
  final bool isGhost;

  const SemanticEdgeResult({
    required this.source,
    required this.target,
    required this.similarity,
    required this.isGhost,
  });
}

/// Full graph analysis result
class GraphAnalysisResult {
  final Map<String, ClusterAssignment> clusters;
  final List<SemanticEdgeResult> semanticEdges;
  final int clusterCount;
  final int ghostEdgeCount;

  const GraphAnalysisResult({
    required this.clusters,
    required this.semanticEdges,
    required this.clusterCount,
    required this.ghostEdgeCount,
  });
}
