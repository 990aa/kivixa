<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Generator</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: transparent;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="paperCanvas"></canvas>

<script>
    const canvas = document.getElementById('paperCanvas');
    const ctx = canvas.getContext('2d');

    /**
     * Sets the canvas dimensions, accounting for device pixel ratio for crisp rendering.
     * @param {number} width - The logical width of the canvas.
     * @param {number} height - The logical height of the canvas.
     */
    function setCanvasSize(width, height) {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.scale(dpr, dpr);
    }

    /**
     * Draws ruled lines on the canvas.
     * @param {number} width - The width of the canvas.
     * @param {number} height - The height of the canvas.
     * @param {number} lineSpacing - The space between lines.
     * @param {number} marginLeft - The left margin for a vertical rule line.
     * @param {string} lineColor - The color of the lines.
     * @param {string} marginColor - The color of the margin line.
     */
    function drawRuledLines(width, height, lineSpacing = 24, marginLeft = 60, lineColor = '#a2c8e6', marginColor = '#e6a2a2') {
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 0.5;

        for (let y = lineSpacing; y < height; y += lineSpacing) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }

        if (marginLeft > 0) {
            ctx.strokeStyle = marginColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginLeft, 0);
            ctx.lineTo(marginLeft, height);
            ctx.stroke();
        }
    }

    /**
     * Draws a grid pattern on the canvas.
     * @param {number} width - The width of the canvas.
     * @param {number} height - The height of the canvas.
     * @param {number} gridSize - The size of each grid cell.
     * @param {string} color - The color of the grid lines.
     */
    function drawGrid(width, height, gridSize = 20, color = '#dcdcdc') {
        ctx.strokeStyle = color;
        ctx.lineWidth = 0.5;

        for (let x = 0; x < width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        for (let y = 0; y < height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
    }

    /**
     * Draws a dot grid pattern on the canvas.
     * @param {number} width - The width of the canvas.
     * @param {number} height - The height of the canvas.
     * @param {number} dotSpacing - The space between dots.
     * @param {number} dotSize - The radius of each dot.
     * @param {string} color - The color of the dots.
     */
    function drawDotGrid(width, height, dotSpacing = 20, dotSize = 1, color = '#cccccc') {
        ctx.fillStyle = color;
        for (let x = dotSpacing; x < width; x += dotSpacing) {
            for (let y = dotSpacing; y < height; y += dotSpacing) {
                ctx.beginPath();
                ctx.arc(x, y, dotSize, 0, 2 * Math.PI, false);
                ctx.fill();
            }
        }
    }

    /**
     * Draws a graph paper pattern with major and minor lines.
     * @param {number} width - The width of the canvas.
     * @param {number} height - The height of the canvas.
     * @param {number} gridSize - The size of the minor grid.
     * @param {number} majorEvery - How many minor lines before a major line.
     * @param {string} minorColor - The color of minor lines.
     * @param {string} majorColor - The color of major lines.
     */
    function drawGraphPaper(width, height, gridSize = 15, majorEvery = 5, minorColor = '#e0e0e0', majorColor = '#c0c0c0') {
        ctx.lineWidth = 0.5;

        for (let x = 0; x < width; x += gridSize) {
            ctx.strokeStyle = (x % (gridSize * majorEvery) === 0) ? majorColor : minorColor;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        for (let y = 0; y < height; y += gridSize) {
            ctx.strokeStyle = (y % (gridSize * majorEvery) === 0) ? majorColor : minorColor;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
    }
    
    /**
     * Draws a watermark on the canvas.
     * @param {number} width - The width of the canvas.
     * @param {number} height - The height of the canvas.
     * @param {string} text - The watermark text.
     */
    function drawWatermark(width, height, text) {
        if (!text) return;
        ctx.save();
        ctx.font = "bold 24px Arial";
        ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.translate(width / 2, height / 2);
        ctx.rotate(-0.4); // 45 degrees
        ctx.fillText(text, 0, 0);
        ctx.restore();
    }

    /**
     * Exports the canvas content to a Base64 encoded image string.
     * @param {string} [format='image/png'] - The image format.
     * @param {number} [quality=0.9] - The image quality for lossy formats (0.0 to 1.0).
     * @returns {string} The Base64 encoded image data.
     */
    function exportCanvasToBase64(format = 'image/png', quality = 0.9) {
        return canvas.toDataURL(format, quality);
    }

    /**
     * Main generation function called from Flutter.
     * @param {string} paramsStr - A JSON string with generation parameters.
     */
    function generate(paramsStr) {
        try {
            const params = JSON.parse(paramsStr);
            const { paperType, width, height, options } = params;

            setCanvasSize(width, height);

            // Clear canvas and set background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = options.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, width, height);

            switch (paperType) {
                case 'ruled':
                    drawRuledLines(width, height, options.lineSpacing, options.marginLeft, options.lineColor, options.marginColor);
                    break;
                case 'grid':
                    drawGrid(width, height, options.gridSize, options.color);
                    break;
                case 'dotGrid':
                    drawDotGrid(width, height, options.dotSpacing, options.dotSize, options.color);
                    break;
                case 'graph':
                    drawGraphPaper(width, height, options.gridSize, options.majorEvery, options.minorColor, options.majorColor);
                    break;
                case 'plain':
                    // Just the background color is enough
                    break;
            }
            
            if (options.watermark) {
                drawWatermark(width, height, options.watermark);
            }

            const base64Image = exportCanvasToBase64();
            
            if (window.PaperGeneratorChannel) {
                window.PaperGeneratorChannel.postMessage(base64Image);
            } else {
                console.error("PaperGeneratorChannel is not defined!");
            }
        } catch (e) {
            console.error("Error generating paper:", e);
            // Notify Flutter of the error
            if (window.PaperGeneratorChannel) {
                window.PaperGeneratorChannel.postMessage('ERROR:' + e.toString());
            }
        }
    }
</script>
</body>
</html>
