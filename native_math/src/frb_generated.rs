// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1636446782;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__anova_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    groups: impl CstDecode<Vec<Vec<f64>>>,
    alpha: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anova",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_groups = groups.cst_decode();
            let api_alpha = alpha.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::anova(api_groups, api_alpha).await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__catalan_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "catalan",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::catalan(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__chi_squared_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    observed: impl CstDecode<Vec<f64>>,
    expected: impl CstDecode<Vec<f64>>,
    alpha: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chi_squared_test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_observed = observed.cst_decode();
            let api_expected = expected.cst_decode();
            let api_alpha = alpha.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::chi_squared_test(api_observed, api_expected, api_alpha)
                                .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__combinations_impl(
    n: impl CstDecode<u64>,
    r: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "combinations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            let api_r = r.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::combinations(api_n, api_r))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__complex_convert_impl(
    real: impl CstDecode<f64>,
    imag: impl CstDecode<f64>,
    to_polar: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "complex_convert",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_real = real.cst_decode();
            let api_imag = imag.cst_decode();
            let api_to_polar = to_polar.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::complex_convert(
                    api_real,
                    api_imag,
                    api_to_polar,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__complex_operation_impl(
    a_real: impl CstDecode<f64>,
    a_imag: impl CstDecode<f64>,
    b_real: impl CstDecode<f64>,
    b_imag: impl CstDecode<f64>,
    operation: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "complex_operation",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a_real = a_real.cst_decode();
            let api_a_imag = a_imag.cst_decode();
            let api_b_real = b_real.cst_decode();
            let api_b_imag = b_imag.cst_decode();
            let api_operation = operation.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::complex_operation(
                    api_a_real,
                    api_a_imag,
                    api_b_real,
                    api_b_imag,
                    api_operation,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__compute_limit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    approach_value: impl CstDecode<f64>,
    from_left: impl CstDecode<bool>,
    from_right: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "compute_limit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_approach_value = approach_value.cst_decode();
            let api_from_left = from_left.cst_decode();
            let api_from_right = from_right.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::compute_limit(
                                api_expression,
                                api_variable,
                                api_approach_value,
                                api_from_left,
                                api_from_right,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__compute_statistics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "compute_statistics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::compute_statistics(api_data).await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__confidence_interval_mean_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    confidence_level: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "confidence_interval_mean",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_confidence_level = confidence_level.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::confidence_interval_mean(api_data, api_confidence_level)
                                .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__confidence_interval_proportion_impl(
    successes: impl CstDecode<u64>,
    n: impl CstDecode<u64>,
    confidence_level: impl CstDecode<f64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "confidence_interval_proportion",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_successes = successes.cst_decode();
            let api_n = n.cst_decode();
            let api_confidence_level = confidence_level.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::confidence_interval_proportion(
                    api_successes,
                    api_n,
                    api_confidence_level,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__confidence_interval_variance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    confidence_level: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "confidence_interval_variance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_confidence_level = confidence_level.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::confidence_interval_variance(
                                api_data,
                                api_confidence_level,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__convert_number_system_impl(
    value: impl CstDecode<String>,
    from_base: impl CstDecode<u32>,
    to_base: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "convert_number_system",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_value = value.cst_decode();
            let api_from_base = from_base.cst_decode();
            let api_to_base = to_base.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::convert_number_system(
                    api_value,
                    api_from_base,
                    api_to_base,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__convert_to_all_units_impl(
    value: impl CstDecode<f64>,
    from_unit: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "convert_to_all_units",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_value = value.cst_decode();
            let api_from_unit = from_unit.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::convert_to_all_units(
                    api_value,
                    api_from_unit,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__convert_unit_impl(
    value: impl CstDecode<f64>,
    from_unit: impl CstDecode<String>,
    to_unit: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "convert_unit",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_value = value.cst_decode();
            let api_from_unit = from_unit.cst_decode();
            let api_to_unit = to_unit.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::convert_unit(
                    api_value,
                    api_from_unit,
                    api_to_unit,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__correlation_covariance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    x: impl CstDecode<Vec<f64>>,
    y: impl CstDecode<Vec<f64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "correlation_covariance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_x = x.cst_decode();
            let api_y = y.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::correlation_covariance(api_x, api_y).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__derivative_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    x_values: impl CstDecode<Vec<f64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "derivative_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_x_values = x_values.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::derivative_graph(
                                api_expression,
                                api_variable,
                                api_x_values,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__differentiate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    point: impl CstDecode<f64>,
    order: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "differentiate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_point = point.cst_decode();
            let api_order = order.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::differentiate(
                                api_expression,
                                api_variable,
                                api_point,
                                api_order,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__distribution_compute_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    distribution_type: impl CstDecode<String>,
    params: impl CstDecode<Vec<f64>>,
    x: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "distribution_compute",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_distribution_type = distribution_type.cst_decode();
            let api_params = params.cst_decode();
            let api_x = x.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::distribution_compute(
                                api_distribution_type,
                                api_params,
                                api_x,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__double_integral_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    x_var: impl CstDecode<String>,
    y_var: impl CstDecode<String>,
    x_min: impl CstDecode<f64>,
    x_max: impl CstDecode<f64>,
    y_min: impl CstDecode<f64>,
    y_max: impl CstDecode<f64>,
    num_intervals: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "double_integral",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_x_var = x_var.cst_decode();
            let api_y_var = y_var.cst_decode();
            let api_x_min = x_min.cst_decode();
            let api_x_max = x_max.cst_decode();
            let api_y_min = y_min.cst_decode();
            let api_y_max = y_max.cst_decode();
            let api_num_intervals = num_intervals.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::double_integral(
                                api_expression,
                                api_x_var,
                                api_y_var,
                                api_x_min,
                                api_x_max,
                                api_y_min,
                                api_y_max,
                                api_num_intervals,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__euler_totient_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "euler_totient",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::euler_totient(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__evaluate_expression_impl(
    expression: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "evaluate_expression",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_expression = expression.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::evaluate_expression(api_expression))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__evaluate_formula_impl(
    formula: impl CstDecode<String>,
    variables: impl CstDecode<Vec<String>>,
    values: impl CstDecode<Vec<f64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "evaluate_formula",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_formula = formula.cst_decode();
            let api_variables = variables.cst_decode();
            let api_values = values.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::evaluate_formula(
                    api_formula,
                    api_variables,
                    api_values,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__evaluate_graph_points_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    x_values: impl CstDecode<Vec<f64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "evaluate_graph_points",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_x_values = x_values.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::evaluate_graph_points(
                                api_expression,
                                api_variable,
                                api_x_values,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__factorial_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "factorial",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::factorial(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__fibonacci_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fibonacci",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::fibonacci(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__find_extrema_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    x_min: impl CstDecode<f64>,
    x_max: impl CstDecode<f64>,
    num_samples: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_extrema",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_x_min = x_min.cst_decode();
            let api_x_max = x_max.cst_decode();
            let api_num_samples = num_samples.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::find_extrema(
                                api_expression,
                                api_variable,
                                api_x_min,
                                api_x_max,
                                api_num_samples,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__find_graph_roots_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    x_min: impl CstDecode<f64>,
    x_max: impl CstDecode<f64>,
    num_samples: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_graph_roots",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_x_min = x_min.cst_decode();
            let api_x_max = x_max.cst_decode();
            let api_num_samples = num_samples.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::find_graph_roots(
                                api_expression,
                                api_variable,
                                api_x_min,
                                api_x_max,
                                api_num_samples,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__find_roots_in_interval_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    start: impl CstDecode<f64>,
    end: impl CstDecode<f64>,
    num_samples: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "find_roots_in_interval",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_start = start.cst_decode();
            let api_end = end.cst_decode();
            let api_num_samples = num_samples.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::find_roots_in_interval(
                                api_expression,
                                api_variable,
                                api_start,
                                api_end,
                                api_num_samples,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__gcd_impl(
    a: impl CstDecode<u64>,
    b: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gcd",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::gcd(api_a, api_b))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__generate_x_range_impl(
    start: impl CstDecode<f64>,
    end: impl CstDecode<f64>,
    num_points: impl CstDecode<usize>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_x_range",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_start = start.cst_decode();
            let api_end = end.cst_decode();
            let api_num_points = num_points.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::generate_x_range(
                    api_start,
                    api_end,
                    api_num_points,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_constant_impl(
    name: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_constant",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::get_constant(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_unit_categories_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_unit_categories",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::get_unit_categories())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_units_for_category_impl(
    category: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_units_for_category",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_category = category.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_units_for_category(api_category))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__gradient_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variables: impl CstDecode<Vec<String>>,
    point: impl CstDecode<Vec<(String, f64)>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gradient",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variables = variables.cst_decode();
            let api_point = point.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::gradient(api_expression, api_variables, api_point).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__init_app_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__integral_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    x_values: impl CstDecode<Vec<f64>>,
    initial_value: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "integral_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_x_values = x_values.cst_decode();
            let api_initial_value = initial_value.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::integral_graph(
                                api_expression,
                                api_variable,
                                api_x_values,
                                api_initial_value,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__integrate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    lower: impl CstDecode<f64>,
    upper: impl CstDecode<f64>,
    num_intervals: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "integrate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_lower = lower.cst_decode();
            let api_upper = upper.cst_decode();
            let api_num_intervals = num_intervals.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::integrate(
                                api_expression,
                                api_variable,
                                api_lower,
                                api_upper,
                                api_num_intervals,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__is_perfect_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_perfect",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::is_perfect(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_prime_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_prime",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::is_prime(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__lcm_impl(
    a: impl CstDecode<u64>,
    b: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lcm",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::lcm(api_a, api_b))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__line_integral_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    x_param: impl CstDecode<String>,
    y_param: impl CstDecode<String>,
    t_var: impl CstDecode<String>,
    t_min: impl CstDecode<f64>,
    t_max: impl CstDecode<f64>,
    num_intervals: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "line_integral",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_x_param = x_param.cst_decode();
            let api_y_param = y_param.cst_decode();
            let api_t_var = t_var.cst_decode();
            let api_t_min = t_min.cst_decode();
            let api_t_max = t_max.cst_decode();
            let api_num_intervals = num_intervals.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::line_integral(
                                api_expression,
                                api_x_param,
                                api_y_param,
                                api_t_var,
                                api_t_min,
                                api_t_max,
                                api_num_intervals,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__linear_regression_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    x_data: impl CstDecode<Vec<f64>>,
    y_data: impl CstDecode<Vec<f64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "linear_regression",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_x_data = x_data.cst_decode();
            let api_y_data = y_data.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::linear_regression(api_x_data, api_y_data).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__list_divisors_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_divisors",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::list_divisors(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__matrix_decomposition_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    rows: impl CstDecode<usize>,
    cols: impl CstDecode<usize>,
    decomposition_type: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "matrix_decomposition",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_rows = rows.cst_decode();
            let api_cols = cols.cst_decode();
            let api_decomposition_type = decomposition_type.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::matrix_decomposition(
                                api_data,
                                api_rows,
                                api_cols,
                                api_decomposition_type,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__matrix_operation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    a_data: impl CstDecode<Vec<f64>>,
    a_rows: impl CstDecode<usize>,
    a_cols: impl CstDecode<usize>,
    b_data: impl CstDecode<Option<Vec<f64>>>,
    b_rows: impl CstDecode<Option<usize>>,
    b_cols: impl CstDecode<Option<usize>>,
    operation: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "matrix_operation",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_a_data = a_data.cst_decode();
            let api_a_rows = a_rows.cst_decode();
            let api_a_cols = a_cols.cst_decode();
            let api_b_data = b_data.cst_decode();
            let api_b_rows = b_rows.cst_decode();
            let api_b_cols = b_cols.cst_decode();
            let api_operation = operation.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::matrix_operation(
                                api_a_data,
                                api_a_rows,
                                api_a_cols,
                                api_b_data,
                                api_b_rows,
                                api_b_cols,
                                api_operation,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__matrix_properties_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    rows: impl CstDecode<usize>,
    cols: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "matrix_properties",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_rows = rows.cst_decode();
            let api_cols = cols.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::matrix_properties(api_data, api_rows, api_cols).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__matrix_rref_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    rows: impl CstDecode<usize>,
    cols: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "matrix_rref",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_rows = rows.cst_decode();
            let api_cols = cols.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::matrix_rref(api_data, api_rows, api_cols).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mixed_partial_derivative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    var1: impl CstDecode<String>,
    var2: impl CstDecode<String>,
    point: impl CstDecode<Vec<(String, f64)>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mixed_partial_derivative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_var1 = var1.cst_decode();
            let api_var2 = var2.cst_decode();
            let api_point = point.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::mixed_partial_derivative(
                                api_expression,
                                api_var1,
                                api_var2,
                                api_point,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__mod_add_impl(
    a: impl CstDecode<u64>,
    b: impl CstDecode<u64>,
    m: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mod_add",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            let api_m = m.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mod_add(api_a, api_b, api_m))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mod_divide_impl(
    a: impl CstDecode<u64>,
    b: impl CstDecode<u64>,
    m: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mod_divide",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            let api_m = m.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mod_divide(api_a, api_b, api_m))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mod_inverse_impl(
    a: impl CstDecode<u64>,
    m: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mod_inverse",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_m = m.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mod_inverse(api_a, api_m))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mod_multiply_impl(
    a: impl CstDecode<u64>,
    b: impl CstDecode<u64>,
    m: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mod_multiply",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            let api_m = m.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mod_multiply(api_a, api_b, api_m))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mod_pow_impl(
    base: impl CstDecode<u64>,
    exp: impl CstDecode<u64>,
    modulus: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mod_pow",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_base = base.cst_decode();
            let api_exp = exp.cst_decode();
            let api_modulus = modulus.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::mod_pow(api_base, api_exp, api_modulus))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__mod_sub_impl(
    a: impl CstDecode<u64>,
    b: impl CstDecode<u64>,
    m: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mod_sub",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_a = a.cst_decode();
            let api_b = b.cst_decode();
            let api_m = m.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::mod_sub(api_a, api_b, api_m))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__parse_formula_impl(
    formula: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_formula",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_formula = formula.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::parse_formula(api_formula))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__partial_derivative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    point: impl CstDecode<Vec<(String, f64)>>,
    order: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "partial_derivative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_point = point.cst_decode();
            let api_order = order.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::partial_derivative(
                                api_expression,
                                api_variable,
                                api_point,
                                api_order,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__permutations_impl(
    n: impl CstDecode<u64>,
    r: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "permutations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            let api_r = r.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::permutations(api_n, api_r))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__polynomial_regression_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    x_data: impl CstDecode<Vec<f64>>,
    y_data: impl CstDecode<Vec<f64>>,
    degree: impl CstDecode<usize>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "polynomial_regression",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_x_data = x_data.cst_decode();
            let api_y_data = y_data.cst_decode();
            let api_degree = degree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::polynomial_regression(api_x_data, api_y_data, api_degree)
                                .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__prime_factors_impl(
    n: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "prime_factors",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_n = n.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::prime_factors(api_n))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sieve_primes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    n: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sieve_primes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_n = n.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(crate::api::sieve_primes(api_n).await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__solve_equation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    initial_guess: impl CstDecode<f64>,
    tolerance: impl CstDecode<f64>,
    max_iterations: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "solve_equation",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_initial_guess = initial_guess.cst_decode();
            let api_tolerance = tolerance.cst_decode();
            let api_max_iterations = max_iterations.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::solve_equation(
                                api_expression,
                                api_variable,
                                api_initial_guess,
                                api_tolerance,
                                api_max_iterations,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__t_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    hypothesized_mean: impl CstDecode<f64>,
    alpha: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "t_test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_hypothesized_mean = hypothesized_mean.cst_decode();
            let api_alpha = alpha.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::t_test(api_data, api_hypothesized_mean, api_alpha).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__taylor_coefficients_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    variable: impl CstDecode<String>,
    around: impl CstDecode<f64>,
    num_terms: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "taylor_coefficients",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_variable = variable.cst_decode();
            let api_around = around.cst_decode();
            let api_num_terms = num_terms.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::taylor_coefficients(
                                api_expression,
                                api_variable,
                                api_around,
                                api_num_terms,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__triple_integral_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    expression: impl CstDecode<String>,
    x_var: impl CstDecode<String>,
    y_var: impl CstDecode<String>,
    z_var: impl CstDecode<String>,
    x_min: impl CstDecode<f64>,
    x_max: impl CstDecode<f64>,
    y_min: impl CstDecode<f64>,
    y_max: impl CstDecode<f64>,
    z_min: impl CstDecode<f64>,
    z_max: impl CstDecode<f64>,
    num_intervals: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "triple_integral",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_expression = expression.cst_decode();
            let api_x_var = x_var.cst_decode();
            let api_y_var = y_var.cst_decode();
            let api_z_var = z_var.cst_decode();
            let api_x_min = x_min.cst_decode();
            let api_x_max = x_max.cst_decode();
            let api_y_min = y_min.cst_decode();
            let api_y_max = y_max.cst_decode();
            let api_z_min = z_min.cst_decode();
            let api_z_max = z_max.cst_decode();
            let api_num_intervals = num_intervals.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::triple_integral(
                                api_expression,
                                api_x_var,
                                api_y_var,
                                api_z_var,
                                api_x_min,
                                api_x_max,
                                api_y_min,
                                api_y_max,
                                api_z_min,
                                api_z_max,
                                api_num_intervals,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__two_sample_t_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data1: impl CstDecode<Vec<f64>>,
    data2: impl CstDecode<Vec<f64>>,
    alpha: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "two_sample_t_test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data1 = data1.cst_decode();
            let api_data2 = data2.cst_decode();
            let api_alpha = alpha.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::two_sample_t_test(api_data1, api_data2, api_alpha).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__two_sample_z_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data1: impl CstDecode<Vec<f64>>,
    data2: impl CstDecode<Vec<f64>>,
    std1: impl CstDecode<f64>,
    std2: impl CstDecode<f64>,
    alpha: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "two_sample_z_test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data1 = data1.cst_decode();
            let api_data2 = data2.cst_decode();
            let api_std1 = std1.cst_decode();
            let api_std2 = std2.cst_decode();
            let api_alpha = alpha.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::two_sample_z_test(
                                api_data1, api_data2, api_std1, api_std2, api_alpha,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__z_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<Vec<f64>>,
    hypothesized_mean: impl CstDecode<f64>,
    population_std: impl CstDecode<f64>,
    alpha: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "z_test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            let api_hypothesized_mean = hypothesized_mean.cst_decode();
            let api_population_std = population_std.cst_decode();
            let api_alpha = alpha.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::z_test(
                                api_data,
                                api_hypothesized_mean,
                                api_population_std,
                                api_alpha,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::calculus::CalculusResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_value = <f64>::sse_decode(deserializer);
        let mut var_symbolic = <Option<String>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::calculus::CalculusResult {
            success: var_success,
            value: var_value,
            symbolic: var_symbolic,
            error: var_error,
        };
    }
}

impl SseDecode for crate::complex::ComplexResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_real = <f64>::sse_decode(deserializer);
        let mut var_imag = <f64>::sse_decode(deserializer);
        let mut var_magnitude = <f64>::sse_decode(deserializer);
        let mut var_angleRad = <f64>::sse_decode(deserializer);
        let mut var_angleDeg = <f64>::sse_decode(deserializer);
        let mut var_formattedRect = <String>::sse_decode(deserializer);
        let mut var_formattedPolar = <String>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::complex::ComplexResult {
            success: var_success,
            real: var_real,
            imag: var_imag,
            magnitude: var_magnitude,
            angle_rad: var_angleRad,
            angle_deg: var_angleDeg,
            formatted_rect: var_formattedRect,
            formatted_polar: var_formattedPolar,
            error: var_error,
        };
    }
}

impl SseDecode for crate::statistics::ConfidenceIntervalResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_lower = <f64>::sse_decode(deserializer);
        let mut var_upper = <f64>::sse_decode(deserializer);
        let mut var_center = <f64>::sse_decode(deserializer);
        let mut var_marginOfError = <f64>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::statistics::ConfidenceIntervalResult {
            success: var_success,
            lower: var_lower,
            upper: var_upper,
            center: var_center,
            margin_of_error: var_marginOfError,
            error: var_error,
        };
    }
}

impl SseDecode for crate::statistics::CorrelationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_correlation = <f64>::sse_decode(deserializer);
        let mut var_covariance = <f64>::sse_decode(deserializer);
        let mut var_pValue = <f64>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::statistics::CorrelationResult {
            success: var_success,
            correlation: var_correlation,
            covariance: var_covariance,
            p_value: var_pValue,
            error: var_error,
        };
    }
}

impl SseDecode for crate::discrete::DiscreteResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_bigValue = <Option<String>>::sse_decode(deserializer);
        let mut var_values = <Vec<u64>>::sse_decode(deserializer);
        let mut var_boolResult = <Option<bool>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::discrete::DiscreteResult {
            success: var_success,
            value: var_value,
            big_value: var_bigValue,
            values: var_values,
            bool_result: var_boolResult,
            error: var_error,
        };
    }
}

impl SseDecode for crate::statistics::DistributionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_pdf = <f64>::sse_decode(deserializer);
        let mut var_cdf = <f64>::sse_decode(deserializer);
        let mut var_mean = <f64>::sse_decode(deserializer);
        let mut var_variance = <f64>::sse_decode(deserializer);
        let mut var_stdDev = <f64>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::statistics::DistributionResult {
            success: var_success,
            pdf: var_pdf,
            cdf: var_cdf,
            mean: var_mean,
            variance: var_variance,
            std_dev: var_stdDev,
            error: var_error,
        };
    }
}

impl SseDecode for crate::basic::ExpressionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_value = <f64>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        let mut var_formatted = <String>::sse_decode(deserializer);
        return crate::basic::ExpressionResult {
            success: var_success,
            value: var_value,
            error: var_error,
            formatted: var_formatted,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::graphing::GraphPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_x = <f64>::sse_decode(deserializer);
        let mut var_y = <f64>::sse_decode(deserializer);
        let mut var_valid = <bool>::sse_decode(deserializer);
        return crate::graphing::GraphPoint {
            x: var_x,
            y: var_y,
            valid: var_valid,
        };
    }
}

impl SseDecode for crate::graphing::GraphResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_points = <Vec<crate::graphing::GraphPoint>>::sse_decode(deserializer);
        let mut var_xMin = <f64>::sse_decode(deserializer);
        let mut var_xMax = <f64>::sse_decode(deserializer);
        let mut var_yMin = <f64>::sse_decode(deserializer);
        let mut var_yMax = <f64>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::graphing::GraphResult {
            success: var_success,
            points: var_points,
            x_min: var_xMin,
            x_max: var_xMax,
            y_min: var_yMin,
            y_max: var_yMax,
            error: var_error,
        };
    }
}

impl SseDecode for crate::statistics::HypothesisTestResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_testStatistic = <f64>::sse_decode(deserializer);
        let mut var_pValue = <f64>::sse_decode(deserializer);
        let mut var_criticalValue = <f64>::sse_decode(deserializer);
        let mut var_rejectNull = <bool>::sse_decode(deserializer);
        let mut var_confidenceInterval = <(f64, f64)>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::statistics::HypothesisTestResult {
            success: var_success,
            test_statistic: var_testStatistic,
            p_value: var_pValue,
            critical_value: var_criticalValue,
            reject_null: var_rejectNull,
            confidence_interval: var_confidenceInterval,
            error: var_error,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::graphing::GraphPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::graphing::GraphPoint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<f64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<f64>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::matrix::MatrixResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::matrix::MatrixResult>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(f64, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(f64, f64)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, f64)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::units::UnitResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::units::UnitResult>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::matrix::MatrixDecomposition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_decompositionType = <String>::sse_decode(deserializer);
        let mut var_matrices = <Vec<crate::matrix::MatrixResult>>::sse_decode(deserializer);
        let mut var_labels = <Vec<String>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::matrix::MatrixDecomposition {
            success: var_success,
            decomposition_type: var_decompositionType,
            matrices: var_matrices,
            labels: var_labels,
            error: var_error,
        };
    }
}

impl SseDecode for crate::matrix::MatrixResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_data = <Vec<f64>>::sse_decode(deserializer);
        let mut var_rows = <usize>::sse_decode(deserializer);
        let mut var_cols = <usize>::sse_decode(deserializer);
        let mut var_scalar = <Option<f64>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::matrix::MatrixResult {
            success: var_success,
            data: var_data,
            rows: var_rows,
            cols: var_cols,
            scalar: var_scalar,
            error: var_error,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<f64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<f64>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for (f64, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <f64>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (Vec<(f64, f64)>, Vec<(f64, f64)>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<(f64, f64)>>::sse_decode(deserializer);
        let mut var_field1 = <Vec<(f64, f64)>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::statistics::RegressionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_coefficients = <Vec<f64>>::sse_decode(deserializer);
        let mut var_rSquared = <f64>::sse_decode(deserializer);
        let mut var_residuals = <Vec<f64>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::statistics::RegressionResult {
            success: var_success,
            coefficients: var_coefficients,
            r_squared: var_rSquared,
            residuals: var_residuals,
            error: var_error,
        };
    }
}

impl SseDecode for crate::calculus::SolveResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_roots = <Vec<f64>>::sse_decode(deserializer);
        let mut var_iterations = <usize>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::calculus::SolveResult {
            success: var_success,
            roots: var_roots,
            iterations: var_iterations,
            error: var_error,
        };
    }
}

impl SseDecode for crate::statistics::StatisticsResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_values = <Vec<(String, f64)>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::statistics::StatisticsResult {
            success: var_success,
            values: var_values,
            error: var_error,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::units::UnitResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_value = <f64>::sse_decode(deserializer);
        let mut var_fromUnit = <String>::sse_decode(deserializer);
        let mut var_toUnit = <String>::sse_decode(deserializer);
        let mut var_formula = <String>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::units::UnitResult {
            success: var_success,
            value: var_value,
            from_unit: var_fromUnit,
            to_unit: var_toUnit,
            formula: var_formula,
            error: var_error,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::calculus::CalculusResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.symbolic.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::calculus::CalculusResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::calculus::CalculusResult>
    for crate::calculus::CalculusResult
{
    fn into_into_dart(self) -> crate::calculus::CalculusResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::complex::ComplexResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.real.into_into_dart().into_dart(),
            self.imag.into_into_dart().into_dart(),
            self.magnitude.into_into_dart().into_dart(),
            self.angle_rad.into_into_dart().into_dart(),
            self.angle_deg.into_into_dart().into_dart(),
            self.formatted_rect.into_into_dart().into_dart(),
            self.formatted_polar.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::complex::ComplexResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::complex::ComplexResult>
    for crate::complex::ComplexResult
{
    fn into_into_dart(self) -> crate::complex::ComplexResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::statistics::ConfidenceIntervalResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.lower.into_into_dart().into_dart(),
            self.upper.into_into_dart().into_dart(),
            self.center.into_into_dart().into_dart(),
            self.margin_of_error.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::statistics::ConfidenceIntervalResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::statistics::ConfidenceIntervalResult>
    for crate::statistics::ConfidenceIntervalResult
{
    fn into_into_dart(self) -> crate::statistics::ConfidenceIntervalResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::statistics::CorrelationResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.correlation.into_into_dart().into_dart(),
            self.covariance.into_into_dart().into_dart(),
            self.p_value.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::statistics::CorrelationResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::statistics::CorrelationResult>
    for crate::statistics::CorrelationResult
{
    fn into_into_dart(self) -> crate::statistics::CorrelationResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::discrete::DiscreteResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.big_value.into_into_dart().into_dart(),
            self.values.into_into_dart().into_dart(),
            self.bool_result.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::discrete::DiscreteResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::discrete::DiscreteResult>
    for crate::discrete::DiscreteResult
{
    fn into_into_dart(self) -> crate::discrete::DiscreteResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::statistics::DistributionResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.pdf.into_into_dart().into_dart(),
            self.cdf.into_into_dart().into_dart(),
            self.mean.into_into_dart().into_dart(),
            self.variance.into_into_dart().into_dart(),
            self.std_dev.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::statistics::DistributionResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::statistics::DistributionResult>
    for crate::statistics::DistributionResult
{
    fn into_into_dart(self) -> crate::statistics::DistributionResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::basic::ExpressionResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
            self.formatted.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::basic::ExpressionResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::basic::ExpressionResult>
    for crate::basic::ExpressionResult
{
    fn into_into_dart(self) -> crate::basic::ExpressionResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::graphing::GraphPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
            self.valid.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::graphing::GraphPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::graphing::GraphPoint>
    for crate::graphing::GraphPoint
{
    fn into_into_dart(self) -> crate::graphing::GraphPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::graphing::GraphResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.points.into_into_dart().into_dart(),
            self.x_min.into_into_dart().into_dart(),
            self.x_max.into_into_dart().into_dart(),
            self.y_min.into_into_dart().into_dart(),
            self.y_max.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::graphing::GraphResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::graphing::GraphResult>
    for crate::graphing::GraphResult
{
    fn into_into_dart(self) -> crate::graphing::GraphResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::statistics::HypothesisTestResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.test_statistic.into_into_dart().into_dart(),
            self.p_value.into_into_dart().into_dart(),
            self.critical_value.into_into_dart().into_dart(),
            self.reject_null.into_into_dart().into_dart(),
            self.confidence_interval.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::statistics::HypothesisTestResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::statistics::HypothesisTestResult>
    for crate::statistics::HypothesisTestResult
{
    fn into_into_dart(self) -> crate::statistics::HypothesisTestResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::matrix::MatrixDecomposition {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.decomposition_type.into_into_dart().into_dart(),
            self.matrices.into_into_dart().into_dart(),
            self.labels.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::matrix::MatrixDecomposition
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::matrix::MatrixDecomposition>
    for crate::matrix::MatrixDecomposition
{
    fn into_into_dart(self) -> crate::matrix::MatrixDecomposition {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::matrix::MatrixResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
            self.rows.into_into_dart().into_dart(),
            self.cols.into_into_dart().into_dart(),
            self.scalar.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::matrix::MatrixResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::matrix::MatrixResult>
    for crate::matrix::MatrixResult
{
    fn into_into_dart(self) -> crate::matrix::MatrixResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::statistics::RegressionResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.coefficients.into_into_dart().into_dart(),
            self.r_squared.into_into_dart().into_dart(),
            self.residuals.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::statistics::RegressionResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::statistics::RegressionResult>
    for crate::statistics::RegressionResult
{
    fn into_into_dart(self) -> crate::statistics::RegressionResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::calculus::SolveResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.roots.into_into_dart().into_dart(),
            self.iterations.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::calculus::SolveResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::calculus::SolveResult>
    for crate::calculus::SolveResult
{
    fn into_into_dart(self) -> crate::calculus::SolveResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::statistics::StatisticsResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.values.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::statistics::StatisticsResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::statistics::StatisticsResult>
    for crate::statistics::StatisticsResult
{
    fn into_into_dart(self) -> crate::statistics::StatisticsResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::units::UnitResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.from_unit.into_into_dart().into_dart(),
            self.to_unit.into_into_dart().into_dart(),
            self.formula.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::units::UnitResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::units::UnitResult> for crate::units::UnitResult {
    fn into_into_dart(self) -> crate::units::UnitResult {
        self
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::calculus::CalculusResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.value, serializer);
        <Option<String>>::sse_encode(self.symbolic, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::complex::ComplexResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.real, serializer);
        <f64>::sse_encode(self.imag, serializer);
        <f64>::sse_encode(self.magnitude, serializer);
        <f64>::sse_encode(self.angle_rad, serializer);
        <f64>::sse_encode(self.angle_deg, serializer);
        <String>::sse_encode(self.formatted_rect, serializer);
        <String>::sse_encode(self.formatted_polar, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::statistics::ConfidenceIntervalResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.lower, serializer);
        <f64>::sse_encode(self.upper, serializer);
        <f64>::sse_encode(self.center, serializer);
        <f64>::sse_encode(self.margin_of_error, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::statistics::CorrelationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.correlation, serializer);
        <f64>::sse_encode(self.covariance, serializer);
        <f64>::sse_encode(self.p_value, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::discrete::DiscreteResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <u64>::sse_encode(self.value, serializer);
        <Option<String>>::sse_encode(self.big_value, serializer);
        <Vec<u64>>::sse_encode(self.values, serializer);
        <Option<bool>>::sse_encode(self.bool_result, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::statistics::DistributionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.pdf, serializer);
        <f64>::sse_encode(self.cdf, serializer);
        <f64>::sse_encode(self.mean, serializer);
        <f64>::sse_encode(self.variance, serializer);
        <f64>::sse_encode(self.std_dev, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::basic::ExpressionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.value, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
        <String>::sse_encode(self.formatted, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::graphing::GraphPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.x, serializer);
        <f64>::sse_encode(self.y, serializer);
        <bool>::sse_encode(self.valid, serializer);
    }
}

impl SseEncode for crate::graphing::GraphResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Vec<crate::graphing::GraphPoint>>::sse_encode(self.points, serializer);
        <f64>::sse_encode(self.x_min, serializer);
        <f64>::sse_encode(self.x_max, serializer);
        <f64>::sse_encode(self.y_min, serializer);
        <f64>::sse_encode(self.y_max, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::statistics::HypothesisTestResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.test_statistic, serializer);
        <f64>::sse_encode(self.p_value, serializer);
        <f64>::sse_encode(self.critical_value, serializer);
        <bool>::sse_encode(self.reject_null, serializer);
        <(f64, f64)>::sse_encode(self.confidence_interval, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::graphing::GraphPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::graphing::GraphPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<f64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<f64>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::matrix::MatrixResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::matrix::MatrixResult>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(f64, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(f64, f64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, f64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::units::UnitResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::units::UnitResult>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::matrix::MatrixDecomposition {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <String>::sse_encode(self.decomposition_type, serializer);
        <Vec<crate::matrix::MatrixResult>>::sse_encode(self.matrices, serializer);
        <Vec<String>>::sse_encode(self.labels, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::matrix::MatrixResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Vec<f64>>::sse_encode(self.data, serializer);
        <usize>::sse_encode(self.rows, serializer);
        <usize>::sse_encode(self.cols, serializer);
        <Option<f64>>::sse_encode(self.scalar, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<f64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<f64>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for (f64, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (Vec<(f64, f64)>, Vec<(f64, f64)>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(f64, f64)>>::sse_encode(self.0, serializer);
        <Vec<(f64, f64)>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::statistics::RegressionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Vec<f64>>::sse_encode(self.coefficients, serializer);
        <f64>::sse_encode(self.r_squared, serializer);
        <Vec<f64>>::sse_encode(self.residuals, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::calculus::SolveResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Vec<f64>>::sse_encode(self.roots, serializer);
        <usize>::sse_encode(self.iterations, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::statistics::StatisticsResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Vec<(String, f64)>>::sse_encode(self.values, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::units::UnitResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <f64>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.from_unit, serializer);
        <String>::sse_encode(self.to_unit, serializer);
        <String>::sse_encode(self.formula, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<bool> for *mut bool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<f64> for *mut f64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<usize> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::calculus::CalculusResult> for wire_cst_calculus_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::calculus::CalculusResult {
            crate::calculus::CalculusResult {
                success: self.success.cst_decode(),
                value: self.value.cst_decode(),
                symbolic: self.symbolic.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::complex::ComplexResult> for wire_cst_complex_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::complex::ComplexResult {
            crate::complex::ComplexResult {
                success: self.success.cst_decode(),
                real: self.real.cst_decode(),
                imag: self.imag.cst_decode(),
                magnitude: self.magnitude.cst_decode(),
                angle_rad: self.angle_rad.cst_decode(),
                angle_deg: self.angle_deg.cst_decode(),
                formatted_rect: self.formatted_rect.cst_decode(),
                formatted_polar: self.formatted_polar.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::ConfidenceIntervalResult>
        for wire_cst_confidence_interval_result
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::ConfidenceIntervalResult {
            crate::statistics::ConfidenceIntervalResult {
                success: self.success.cst_decode(),
                lower: self.lower.cst_decode(),
                upper: self.upper.cst_decode(),
                center: self.center.cst_decode(),
                margin_of_error: self.margin_of_error.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::CorrelationResult> for wire_cst_correlation_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::CorrelationResult {
            crate::statistics::CorrelationResult {
                success: self.success.cst_decode(),
                correlation: self.correlation.cst_decode(),
                covariance: self.covariance.cst_decode(),
                p_value: self.p_value.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::discrete::DiscreteResult> for wire_cst_discrete_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::discrete::DiscreteResult {
            crate::discrete::DiscreteResult {
                success: self.success.cst_decode(),
                value: self.value.cst_decode(),
                big_value: self.big_value.cst_decode(),
                values: self.values.cst_decode(),
                bool_result: self.bool_result.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::DistributionResult> for wire_cst_distribution_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::DistributionResult {
            crate::statistics::DistributionResult {
                success: self.success.cst_decode(),
                pdf: self.pdf.cst_decode(),
                cdf: self.cdf.cst_decode(),
                mean: self.mean.cst_decode(),
                variance: self.variance.cst_decode(),
                std_dev: self.std_dev.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::basic::ExpressionResult> for wire_cst_expression_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::basic::ExpressionResult {
            crate::basic::ExpressionResult {
                success: self.success.cst_decode(),
                value: self.value.cst_decode(),
                error: self.error.cst_decode(),
                formatted: self.formatted.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graphing::GraphPoint> for wire_cst_graph_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graphing::GraphPoint {
            crate::graphing::GraphPoint {
                x: self.x.cst_decode(),
                y: self.y.cst_decode(),
                valid: self.valid.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graphing::GraphResult> for wire_cst_graph_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graphing::GraphResult {
            crate::graphing::GraphResult {
                success: self.success.cst_decode(),
                points: self.points.cst_decode(),
                x_min: self.x_min.cst_decode(),
                x_max: self.x_max.cst_decode(),
                y_min: self.y_min.cst_decode(),
                y_max: self.y_max.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::HypothesisTestResult> for wire_cst_hypothesis_test_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::HypothesisTestResult {
            crate::statistics::HypothesisTestResult {
                success: self.success.cst_decode(),
                test_statistic: self.test_statistic.cst_decode(),
                p_value: self.p_value.cst_decode(),
                critical_value: self.critical_value.cst_decode(),
                reject_null: self.reject_null.cst_decode(),
                confidence_interval: self.confidence_interval.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::graphing::GraphPoint>> for *mut wire_cst_list_graph_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::graphing::GraphPoint> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<f64>>> for *mut wire_cst_list_list_prim_f_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<f64>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::matrix::MatrixResult>> for *mut wire_cst_list_matrix_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::matrix::MatrixResult> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<f64>> for *mut wire_cst_list_prim_f_64_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<f64>> for *mut wire_cst_list_prim_f_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u64>> for *mut wire_cst_list_prim_u_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(f64, f64)>> for *mut wire_cst_list_record_f_64_f_64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(f64, f64)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<(String, f64)>> for *mut wire_cst_list_record_string_f_64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, f64)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::units::UnitResult>> for *mut wire_cst_list_unit_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::units::UnitResult> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::matrix::MatrixDecomposition> for wire_cst_matrix_decomposition {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::matrix::MatrixDecomposition {
            crate::matrix::MatrixDecomposition {
                success: self.success.cst_decode(),
                decomposition_type: self.decomposition_type.cst_decode(),
                matrices: self.matrices.cst_decode(),
                labels: self.labels.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::matrix::MatrixResult> for wire_cst_matrix_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::matrix::MatrixResult {
            crate::matrix::MatrixResult {
                success: self.success.cst_decode(),
                data: self.data.cst_decode(),
                rows: self.rows.cst_decode(),
                cols: self.cols.cst_decode(),
                scalar: self.scalar.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<(f64, f64)> for wire_cst_record_f_64_f_64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (f64, f64) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<(Vec<(f64, f64)>, Vec<(f64, f64)>)>
        for wire_cst_record_list_record_f_64_f_64_list_record_f_64_f_64
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (Vec<(f64, f64)>, Vec<(f64, f64)>) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<(String, f64)> for wire_cst_record_string_f_64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, f64) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<crate::statistics::RegressionResult> for wire_cst_regression_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::RegressionResult {
            crate::statistics::RegressionResult {
                success: self.success.cst_decode(),
                coefficients: self.coefficients.cst_decode(),
                r_squared: self.r_squared.cst_decode(),
                residuals: self.residuals.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::calculus::SolveResult> for wire_cst_solve_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::calculus::SolveResult {
            crate::calculus::SolveResult {
                success: self.success.cst_decode(),
                roots: self.roots.cst_decode(),
                iterations: self.iterations.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::StatisticsResult> for wire_cst_statistics_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::StatisticsResult {
            crate::statistics::StatisticsResult {
                success: self.success.cst_decode(),
                values: self.values.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::units::UnitResult> for wire_cst_unit_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::units::UnitResult {
            crate::units::UnitResult {
                success: self.success.cst_decode(),
                value: self.value.cst_decode(),
                from_unit: self.from_unit.cst_decode(),
                to_unit: self.to_unit.cst_decode(),
                formula: self.formula.cst_decode(),
                error: self.error.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_calculus_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                value: Default::default(),
                symbolic: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_calculus_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_complex_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                real: Default::default(),
                imag: Default::default(),
                magnitude: Default::default(),
                angle_rad: Default::default(),
                angle_deg: Default::default(),
                formatted_rect: core::ptr::null_mut(),
                formatted_polar: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_complex_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_confidence_interval_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                lower: Default::default(),
                upper: Default::default(),
                center: Default::default(),
                margin_of_error: Default::default(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_confidence_interval_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_correlation_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                correlation: Default::default(),
                covariance: Default::default(),
                p_value: Default::default(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_correlation_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_discrete_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                value: Default::default(),
                big_value: core::ptr::null_mut(),
                values: core::ptr::null_mut(),
                bool_result: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_discrete_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_distribution_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                pdf: Default::default(),
                cdf: Default::default(),
                mean: Default::default(),
                variance: Default::default(),
                std_dev: Default::default(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_distribution_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_expression_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                value: Default::default(),
                error: core::ptr::null_mut(),
                formatted: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_expression_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_graph_point {
        fn new_with_null_ptr() -> Self {
            Self {
                x: Default::default(),
                y: Default::default(),
                valid: Default::default(),
            }
        }
    }
    impl Default for wire_cst_graph_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_graph_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                points: core::ptr::null_mut(),
                x_min: Default::default(),
                x_max: Default::default(),
                y_min: Default::default(),
                y_max: Default::default(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_graph_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_hypothesis_test_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                test_statistic: Default::default(),
                p_value: Default::default(),
                critical_value: Default::default(),
                reject_null: Default::default(),
                confidence_interval: Default::default(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_hypothesis_test_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_matrix_decomposition {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                decomposition_type: core::ptr::null_mut(),
                matrices: core::ptr::null_mut(),
                labels: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_matrix_decomposition {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_matrix_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                data: core::ptr::null_mut(),
                rows: Default::default(),
                cols: Default::default(),
                scalar: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_matrix_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_f_64_f_64 {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_f_64_f_64 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_list_record_f_64_f_64_list_record_f_64_f_64 {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_list_record_f_64_f_64_list_record_f_64_f_64 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_string_f_64 {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: Default::default(),
            }
        }
    }
    impl Default for wire_cst_record_string_f_64 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_regression_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                coefficients: core::ptr::null_mut(),
                r_squared: Default::default(),
                residuals: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_regression_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_solve_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                roots: core::ptr::null_mut(),
                iterations: Default::default(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_solve_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_statistics_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                values: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_statistics_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_unit_result {
        fn new_with_null_ptr() -> Self {
            Self {
                success: Default::default(),
                value: Default::default(),
                from_unit: core::ptr::null_mut(),
                to_unit: core::ptr::null_mut(),
                formula: core::ptr::null_mut(),
                error: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_unit_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__anova(
        port_: i64,
        groups: *mut wire_cst_list_list_prim_f_64_strict,
        alpha: f64,
    ) {
        wire__crate__api__anova_impl(port_, groups, alpha)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__catalan(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__catalan_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__chi_squared_test(
        port_: i64,
        observed: *mut wire_cst_list_prim_f_64_loose,
        expected: *mut wire_cst_list_prim_f_64_loose,
        alpha: f64,
    ) {
        wire__crate__api__chi_squared_test_impl(port_, observed, expected, alpha)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__combinations(
        n: u64,
        r: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__combinations_impl(n, r)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__complex_convert(
        real: f64,
        imag: f64,
        to_polar: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__complex_convert_impl(real, imag, to_polar)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__complex_operation(
        a_real: f64,
        a_imag: f64,
        b_real: f64,
        b_imag: f64,
        operation: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__complex_operation_impl(a_real, a_imag, b_real, b_imag, operation)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__compute_limit(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        approach_value: f64,
        from_left: bool,
        from_right: bool,
    ) {
        wire__crate__api__compute_limit_impl(
            port_,
            expression,
            variable,
            approach_value,
            from_left,
            from_right,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__compute_statistics(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
    ) {
        wire__crate__api__compute_statistics_impl(port_, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__confidence_interval_mean(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        confidence_level: f64,
    ) {
        wire__crate__api__confidence_interval_mean_impl(port_, data, confidence_level)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__confidence_interval_proportion(
        successes: u64,
        n: u64,
        confidence_level: f64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__confidence_interval_proportion_impl(successes, n, confidence_level)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__confidence_interval_variance(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        confidence_level: f64,
    ) {
        wire__crate__api__confidence_interval_variance_impl(port_, data, confidence_level)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__convert_number_system(
        value: *mut wire_cst_list_prim_u_8_strict,
        from_base: u32,
        to_base: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__convert_number_system_impl(value, from_base, to_base)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__convert_to_all_units(
        value: f64,
        from_unit: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__convert_to_all_units_impl(value, from_unit)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__convert_unit(
        value: f64,
        from_unit: *mut wire_cst_list_prim_u_8_strict,
        to_unit: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__convert_unit_impl(value, from_unit, to_unit)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__correlation_covariance(
        port_: i64,
        x: *mut wire_cst_list_prim_f_64_loose,
        y: *mut wire_cst_list_prim_f_64_loose,
    ) {
        wire__crate__api__correlation_covariance_impl(port_, x, y)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__derivative_graph(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        x_values: *mut wire_cst_list_prim_f_64_loose,
    ) {
        wire__crate__api__derivative_graph_impl(port_, expression, variable, x_values)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__differentiate(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        point: f64,
        order: u32,
    ) {
        wire__crate__api__differentiate_impl(port_, expression, variable, point, order)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__distribution_compute(
        port_: i64,
        distribution_type: *mut wire_cst_list_prim_u_8_strict,
        params: *mut wire_cst_list_prim_f_64_loose,
        x: f64,
    ) {
        wire__crate__api__distribution_compute_impl(port_, distribution_type, params, x)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__double_integral(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        x_var: *mut wire_cst_list_prim_u_8_strict,
        y_var: *mut wire_cst_list_prim_u_8_strict,
        x_min: f64,
        x_max: f64,
        y_min: f64,
        y_max: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__double_integral_impl(
            port_,
            expression,
            x_var,
            y_var,
            x_min,
            x_max,
            y_min,
            y_max,
            num_intervals,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__euler_totient(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__euler_totient_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__evaluate_expression(
        expression: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__evaluate_expression_impl(expression)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__evaluate_formula(
        formula: *mut wire_cst_list_prim_u_8_strict,
        variables: *mut wire_cst_list_String,
        values: *mut wire_cst_list_prim_f_64_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__evaluate_formula_impl(formula, variables, values)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__evaluate_graph_points(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        x_values: *mut wire_cst_list_prim_f_64_loose,
    ) {
        wire__crate__api__evaluate_graph_points_impl(port_, expression, variable, x_values)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__factorial(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__factorial_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__fibonacci(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__fibonacci_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__find_extrema(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        x_min: f64,
        x_max: f64,
        num_samples: usize,
    ) {
        wire__crate__api__find_extrema_impl(port_, expression, variable, x_min, x_max, num_samples)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__find_graph_roots(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        x_min: f64,
        x_max: f64,
        num_samples: usize,
    ) {
        wire__crate__api__find_graph_roots_impl(
            port_,
            expression,
            variable,
            x_min,
            x_max,
            num_samples,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__find_roots_in_interval(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        start: f64,
        end: f64,
        num_samples: u32,
    ) {
        wire__crate__api__find_roots_in_interval_impl(
            port_,
            expression,
            variable,
            start,
            end,
            num_samples,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__gcd(
        a: u64,
        b: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__gcd_impl(a, b)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__generate_x_range(
        start: f64,
        end: f64,
        num_points: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__generate_x_range_impl(start, end, num_points)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_constant(
        name: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_constant_impl(name)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_unit_categories(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_unit_categories_impl()
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__get_units_for_category(
        category: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_units_for_category_impl(category)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__gradient(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variables: *mut wire_cst_list_String,
        point: *mut wire_cst_list_record_string_f_64,
    ) {
        wire__crate__api__gradient_impl(port_, expression, variables, point)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__init_app(port_: i64) {
        wire__crate__api__init_app_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__integral_graph(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        x_values: *mut wire_cst_list_prim_f_64_loose,
        initial_value: f64,
    ) {
        wire__crate__api__integral_graph_impl(port_, expression, variable, x_values, initial_value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__integrate(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        lower: f64,
        upper: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__integrate_impl(port_, expression, variable, lower, upper, num_intervals)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__is_perfect(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_perfect_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__is_prime(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_prime_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__lcm(
        a: u64,
        b: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__lcm_impl(a, b)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__line_integral(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        x_param: *mut wire_cst_list_prim_u_8_strict,
        y_param: *mut wire_cst_list_prim_u_8_strict,
        t_var: *mut wire_cst_list_prim_u_8_strict,
        t_min: f64,
        t_max: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__line_integral_impl(
            port_,
            expression,
            x_param,
            y_param,
            t_var,
            t_min,
            t_max,
            num_intervals,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__linear_regression(
        port_: i64,
        x_data: *mut wire_cst_list_prim_f_64_loose,
        y_data: *mut wire_cst_list_prim_f_64_loose,
    ) {
        wire__crate__api__linear_regression_impl(port_, x_data, y_data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__list_divisors(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__list_divisors_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__matrix_decomposition(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        rows: usize,
        cols: usize,
        decomposition_type: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__matrix_decomposition_impl(port_, data, rows, cols, decomposition_type)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__matrix_operation(
        port_: i64,
        a_data: *mut wire_cst_list_prim_f_64_loose,
        a_rows: usize,
        a_cols: usize,
        b_data: *mut wire_cst_list_prim_f_64_strict,
        b_rows: *mut usize,
        b_cols: *mut usize,
        operation: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__matrix_operation_impl(
            port_, a_data, a_rows, a_cols, b_data, b_rows, b_cols, operation,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__matrix_properties(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        rows: usize,
        cols: usize,
    ) {
        wire__crate__api__matrix_properties_impl(port_, data, rows, cols)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__matrix_rref(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        rows: usize,
        cols: usize,
    ) {
        wire__crate__api__matrix_rref_impl(port_, data, rows, cols)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mixed_partial_derivative(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        var1: *mut wire_cst_list_prim_u_8_strict,
        var2: *mut wire_cst_list_prim_u_8_strict,
        point: *mut wire_cst_list_record_string_f_64,
    ) {
        wire__crate__api__mixed_partial_derivative_impl(port_, expression, var1, var2, point)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mod_add(
        a: u64,
        b: u64,
        m: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_add_impl(a, b, m)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mod_divide(
        a: u64,
        b: u64,
        m: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_divide_impl(a, b, m)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mod_inverse(
        a: u64,
        m: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_inverse_impl(a, m)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mod_multiply(
        a: u64,
        b: u64,
        m: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_multiply_impl(a, b, m)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mod_pow(
        base: u64,
        exp: u64,
        modulus: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_pow_impl(base, exp, modulus)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__mod_sub(
        a: u64,
        b: u64,
        m: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_sub_impl(a, b, m)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__parse_formula(
        formula: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__parse_formula_impl(formula)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__partial_derivative(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        point: *mut wire_cst_list_record_string_f_64,
        order: u32,
    ) {
        wire__crate__api__partial_derivative_impl(port_, expression, variable, point, order)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__permutations(
        n: u64,
        r: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__permutations_impl(n, r)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__polynomial_regression(
        port_: i64,
        x_data: *mut wire_cst_list_prim_f_64_loose,
        y_data: *mut wire_cst_list_prim_f_64_loose,
        degree: usize,
    ) {
        wire__crate__api__polynomial_regression_impl(port_, x_data, y_data, degree)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__prime_factors(
        n: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__prime_factors_impl(n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__sieve_primes(port_: i64, n: u64) {
        wire__crate__api__sieve_primes_impl(port_, n)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__solve_equation(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        initial_guess: f64,
        tolerance: f64,
        max_iterations: u32,
    ) {
        wire__crate__api__solve_equation_impl(
            port_,
            expression,
            variable,
            initial_guess,
            tolerance,
            max_iterations,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__t_test(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        hypothesized_mean: f64,
        alpha: f64,
    ) {
        wire__crate__api__t_test_impl(port_, data, hypothesized_mean, alpha)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__taylor_coefficients(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        variable: *mut wire_cst_list_prim_u_8_strict,
        around: f64,
        num_terms: u32,
    ) {
        wire__crate__api__taylor_coefficients_impl(port_, expression, variable, around, num_terms)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__triple_integral(
        port_: i64,
        expression: *mut wire_cst_list_prim_u_8_strict,
        x_var: *mut wire_cst_list_prim_u_8_strict,
        y_var: *mut wire_cst_list_prim_u_8_strict,
        z_var: *mut wire_cst_list_prim_u_8_strict,
        x_min: f64,
        x_max: f64,
        y_min: f64,
        y_max: f64,
        z_min: f64,
        z_max: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__triple_integral_impl(
            port_,
            expression,
            x_var,
            y_var,
            z_var,
            x_min,
            x_max,
            y_min,
            y_max,
            z_min,
            z_max,
            num_intervals,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__two_sample_t_test(
        port_: i64,
        data1: *mut wire_cst_list_prim_f_64_loose,
        data2: *mut wire_cst_list_prim_f_64_loose,
        alpha: f64,
    ) {
        wire__crate__api__two_sample_t_test_impl(port_, data1, data2, alpha)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__two_sample_z_test(
        port_: i64,
        data1: *mut wire_cst_list_prim_f_64_loose,
        data2: *mut wire_cst_list_prim_f_64_loose,
        std1: f64,
        std2: f64,
        alpha: f64,
    ) {
        wire__crate__api__two_sample_z_test_impl(port_, data1, data2, std1, std2, alpha)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_wire__crate__api__z_test(
        port_: i64,
        data: *mut wire_cst_list_prim_f_64_loose,
        hypothesized_mean: f64,
        population_std: f64,
        alpha: f64,
    ) {
        wire__crate__api__z_test_impl(port_, data, hypothesized_mean, population_std, alpha)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_bool(value: bool) -> *mut bool {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_f_64(value: f64) -> *mut f64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_box_autoadd_usize(value: usize) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_String(len: i32) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_graph_point(
        len: i32,
    ) -> *mut wire_cst_list_graph_point {
        let wrap = wire_cst_list_graph_point {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_graph_point>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_list_prim_f_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_f_64_strict {
        let wrap = wire_cst_list_list_prim_f_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_f_64_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_matrix_result(
        len: i32,
    ) -> *mut wire_cst_list_matrix_result {
        let wrap = wire_cst_list_matrix_result {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_matrix_result>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_f_64_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_f_64_loose {
        let ans = wire_cst_list_prim_f_64_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_f_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_f_64_strict {
        let ans = wire_cst_list_prim_f_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_u_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_64_strict {
        let ans = wire_cst_list_prim_u_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_record_f_64_f_64(
        len: i32,
    ) -> *mut wire_cst_list_record_f_64_f_64 {
        let wrap = wire_cst_list_record_f_64_f_64 {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_f_64_f_64>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_record_string_f_64(
        len: i32,
    ) -> *mut wire_cst_list_record_string_f_64 {
        let wrap = wire_cst_list_record_string_f_64 {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_f_64>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kivixa_cst_new_list_unit_result(
        len: i32,
    ) -> *mut wire_cst_list_unit_result {
        let wrap = wire_cst_list_unit_result {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_unit_result>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_calculus_result {
        success: bool,
        value: f64,
        symbolic: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_complex_result {
        success: bool,
        real: f64,
        imag: f64,
        magnitude: f64,
        angle_rad: f64,
        angle_deg: f64,
        formatted_rect: *mut wire_cst_list_prim_u_8_strict,
        formatted_polar: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_confidence_interval_result {
        success: bool,
        lower: f64,
        upper: f64,
        center: f64,
        margin_of_error: f64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_correlation_result {
        success: bool,
        correlation: f64,
        covariance: f64,
        p_value: f64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_discrete_result {
        success: bool,
        value: u64,
        big_value: *mut wire_cst_list_prim_u_8_strict,
        values: *mut wire_cst_list_prim_u_64_strict,
        bool_result: *mut bool,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_distribution_result {
        success: bool,
        pdf: f64,
        cdf: f64,
        mean: f64,
        variance: f64,
        std_dev: f64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_expression_result {
        success: bool,
        value: f64,
        error: *mut wire_cst_list_prim_u_8_strict,
        formatted: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_graph_point {
        x: f64,
        y: f64,
        valid: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_graph_result {
        success: bool,
        points: *mut wire_cst_list_graph_point,
        x_min: f64,
        x_max: f64,
        y_min: f64,
        y_max: f64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_hypothesis_test_result {
        success: bool,
        test_statistic: f64,
        p_value: f64,
        critical_value: f64,
        reject_null: bool,
        confidence_interval: wire_cst_record_f_64_f_64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_graph_point {
        ptr: *mut wire_cst_graph_point,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_f_64_strict {
        ptr: *mut *mut wire_cst_list_prim_f_64_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_matrix_result {
        ptr: *mut wire_cst_matrix_result,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_f_64_loose {
        ptr: *mut f64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_f_64_strict {
        ptr: *mut f64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_64_strict {
        ptr: *mut u64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_f_64_f_64 {
        ptr: *mut wire_cst_record_f_64_f_64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_f_64 {
        ptr: *mut wire_cst_record_string_f_64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_unit_result {
        ptr: *mut wire_cst_unit_result,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_matrix_decomposition {
        success: bool,
        decomposition_type: *mut wire_cst_list_prim_u_8_strict,
        matrices: *mut wire_cst_list_matrix_result,
        labels: *mut wire_cst_list_String,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_matrix_result {
        success: bool,
        data: *mut wire_cst_list_prim_f_64_strict,
        rows: usize,
        cols: usize,
        scalar: *mut f64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_f_64_f_64 {
        field0: f64,
        field1: f64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_list_record_f_64_f_64_list_record_f_64_f_64 {
        field0: *mut wire_cst_list_record_f_64_f_64,
        field1: *mut wire_cst_list_record_f_64_f_64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_f_64 {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: f64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_regression_result {
        success: bool,
        coefficients: *mut wire_cst_list_prim_f_64_strict,
        r_squared: f64,
        residuals: *mut wire_cst_list_prim_f_64_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_solve_result {
        success: bool,
        roots: *mut wire_cst_list_prim_f_64_strict,
        iterations: usize,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_statistics_result {
        success: bool,
        values: *mut wire_cst_list_record_string_f_64,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_unit_result {
        success: bool,
        value: f64,
        from_unit: *mut wire_cst_list_prim_u_8_strict,
        to_unit: *mut wire_cst_list_prim_u_8_strict,
        formula: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<crate::calculus::CalculusResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::calculus::CalculusResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::calculus::CalculusResult {
                success: self_.get(0).cst_decode(),
                value: self_.get(1).cst_decode(),
                symbolic: self_.get(2).cst_decode(),
                error: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::complex::ComplexResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::complex::ComplexResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                9,
                "Expected 9 elements, got {}",
                self_.length()
            );
            crate::complex::ComplexResult {
                success: self_.get(0).cst_decode(),
                real: self_.get(1).cst_decode(),
                imag: self_.get(2).cst_decode(),
                magnitude: self_.get(3).cst_decode(),
                angle_rad: self_.get(4).cst_decode(),
                angle_deg: self_.get(5).cst_decode(),
                formatted_rect: self_.get(6).cst_decode(),
                formatted_polar: self_.get(7).cst_decode(),
                error: self_.get(8).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::ConfidenceIntervalResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::ConfidenceIntervalResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::statistics::ConfidenceIntervalResult {
                success: self_.get(0).cst_decode(),
                lower: self_.get(1).cst_decode(),
                upper: self_.get(2).cst_decode(),
                center: self_.get(3).cst_decode(),
                margin_of_error: self_.get(4).cst_decode(),
                error: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::CorrelationResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::CorrelationResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::statistics::CorrelationResult {
                success: self_.get(0).cst_decode(),
                correlation: self_.get(1).cst_decode(),
                covariance: self_.get(2).cst_decode(),
                p_value: self_.get(3).cst_decode(),
                error: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::discrete::DiscreteResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::discrete::DiscreteResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::discrete::DiscreteResult {
                success: self_.get(0).cst_decode(),
                value: self_.get(1).cst_decode(),
                big_value: self_.get(2).cst_decode(),
                values: self_.get(3).cst_decode(),
                bool_result: self_.get(4).cst_decode(),
                error: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::DistributionResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::DistributionResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::statistics::DistributionResult {
                success: self_.get(0).cst_decode(),
                pdf: self_.get(1).cst_decode(),
                cdf: self_.get(2).cst_decode(),
                mean: self_.get(3).cst_decode(),
                variance: self_.get(4).cst_decode(),
                std_dev: self_.get(5).cst_decode(),
                error: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::basic::ExpressionResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::basic::ExpressionResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::basic::ExpressionResult {
                success: self_.get(0).cst_decode(),
                value: self_.get(1).cst_decode(),
                error: self_.get(2).cst_decode(),
                formatted: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graphing::GraphPoint>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graphing::GraphPoint {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::graphing::GraphPoint {
                x: self_.get(0).cst_decode(),
                y: self_.get(1).cst_decode(),
                valid: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::graphing::GraphResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::graphing::GraphResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::graphing::GraphResult {
                success: self_.get(0).cst_decode(),
                points: self_.get(1).cst_decode(),
                x_min: self_.get(2).cst_decode(),
                x_max: self_.get(3).cst_decode(),
                y_min: self_.get(4).cst_decode(),
                y_max: self_.get(5).cst_decode(),
                error: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::HypothesisTestResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::HypothesisTestResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::statistics::HypothesisTestResult {
                success: self_.get(0).cst_decode(),
                test_statistic: self_.get(1).cst_decode(),
                p_value: self_.get(2).cst_decode(),
                critical_value: self_.get(3).cst_decode(),
                reject_null: self_.get(4).cst_decode(),
                confidence_interval: self_.get(5).cst_decode(),
                error: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<String>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::graphing::GraphPoint>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::graphing::GraphPoint> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<Vec<f64>>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<f64>> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::matrix::MatrixResult>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::matrix::MatrixResult> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<f64>> for Box<[f64]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f64> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<u64>> for Box<[u64]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<(f64, f64)>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(f64, f64)> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<(String, f64)>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, f64)> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::units::UnitResult>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::units::UnitResult> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<crate::matrix::MatrixDecomposition>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::matrix::MatrixDecomposition {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::matrix::MatrixDecomposition {
                success: self_.get(0).cst_decode(),
                decomposition_type: self_.get(1).cst_decode(),
                matrices: self_.get(2).cst_decode(),
                labels: self_.get(3).cst_decode(),
                error: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::matrix::MatrixResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::matrix::MatrixResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::matrix::MatrixResult {
                success: self_.get(0).cst_decode(),
                data: self_.get(1).cst_decode(),
                rows: self_.get(2).cst_decode(),
                cols: self_.get(3).cst_decode(),
                scalar: self_.get(4).cst_decode(),
                error: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<Option<String>> for Option<String> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<String> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<Option<Vec<f64>>> for Option<Box<[f64]>> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<Vec<f64>> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<(f64, f64)> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (f64, f64) {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            (self_.get(0).cst_decode(), self_.get(1).cst_decode())
        }
    }
    impl CstDecode<(Vec<(f64, f64)>, Vec<(f64, f64)>)>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (Vec<(f64, f64)>, Vec<(f64, f64)>) {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            (self_.get(0).cst_decode(), self_.get(1).cst_decode())
        }
    }
    impl CstDecode<(String, f64)> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, f64) {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            (self_.get(0).cst_decode(), self_.get(1).cst_decode())
        }
    }
    impl CstDecode<crate::statistics::RegressionResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::RegressionResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            crate::statistics::RegressionResult {
                success: self_.get(0).cst_decode(),
                coefficients: self_.get(1).cst_decode(),
                r_squared: self_.get(2).cst_decode(),
                residuals: self_.get(3).cst_decode(),
                error: self_.get(4).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::calculus::SolveResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::calculus::SolveResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::calculus::SolveResult {
                success: self_.get(0).cst_decode(),
                roots: self_.get(1).cst_decode(),
                iterations: self_.get(2).cst_decode(),
                error: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::statistics::StatisticsResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::statistics::StatisticsResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::statistics::StatisticsResult {
                success: self_.get(0).cst_decode(),
                values: self_.get(1).cst_decode(),
                error: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::units::UnitResult>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::units::UnitResult {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::units::UnitResult {
                success: self_.get(0).cst_decode(),
                value: self_.get(1).cst_decode(),
                from_unit: self_.get(2).cst_decode(),
                to_unit: self_.get(3).cst_decode(),
                formula: self_.get(4).cst_decode(),
                error: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<f64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f64 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<Vec<f64>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<f64> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Float64Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<Vec<u64>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            let buf = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::BigUint64Array>()
                .unwrap();
            let buf = flutter_rust_bridge::for_generated::js_sys::Uint8Array::new(&buf.buffer());
            flutter_rust_bridge::for_generated::slice_from_byte_buffer(buf.to_vec()).into()
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__anova(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        groups: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        alpha: f64,
    ) {
        wire__crate__api__anova_impl(port_, groups, alpha)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__catalan(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__catalan_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chi_squared_test(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        observed: Box<[f64]>,
        expected: Box<[f64]>,
        alpha: f64,
    ) {
        wire__crate__api__chi_squared_test_impl(port_, observed, expected, alpha)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__combinations(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        r: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__combinations_impl(n, r)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__complex_convert(
        real: f64,
        imag: f64,
        to_polar: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__complex_convert_impl(real, imag, to_polar)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__complex_operation(
        a_real: f64,
        a_imag: f64,
        b_real: f64,
        b_imag: f64,
        operation: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__complex_operation_impl(a_real, a_imag, b_real, b_imag, operation)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__compute_limit(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        approach_value: f64,
        from_left: bool,
        from_right: bool,
    ) {
        wire__crate__api__compute_limit_impl(
            port_,
            expression,
            variable,
            approach_value,
            from_left,
            from_right,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__compute_statistics(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
    ) {
        wire__crate__api__compute_statistics_impl(port_, data)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__confidence_interval_mean(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        confidence_level: f64,
    ) {
        wire__crate__api__confidence_interval_mean_impl(port_, data, confidence_level)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__confidence_interval_proportion(
        successes: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        confidence_level: f64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__confidence_interval_proportion_impl(successes, n, confidence_level)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__confidence_interval_variance(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        confidence_level: f64,
    ) {
        wire__crate__api__confidence_interval_variance_impl(port_, data, confidence_level)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__convert_number_system(
        value: String,
        from_base: u32,
        to_base: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__convert_number_system_impl(value, from_base, to_base)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__convert_to_all_units(
        value: f64,
        from_unit: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__convert_to_all_units_impl(value, from_unit)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__convert_unit(
        value: f64,
        from_unit: String,
        to_unit: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__convert_unit_impl(value, from_unit, to_unit)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__correlation_covariance(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        x: Box<[f64]>,
        y: Box<[f64]>,
    ) {
        wire__crate__api__correlation_covariance_impl(port_, x, y)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__derivative_graph(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        x_values: Box<[f64]>,
    ) {
        wire__crate__api__derivative_graph_impl(port_, expression, variable, x_values)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__differentiate(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        point: f64,
        order: u32,
    ) {
        wire__crate__api__differentiate_impl(port_, expression, variable, point, order)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__distribution_compute(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        distribution_type: String,
        params: Box<[f64]>,
        x: f64,
    ) {
        wire__crate__api__distribution_compute_impl(port_, distribution_type, params, x)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__double_integral(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        x_var: String,
        y_var: String,
        x_min: f64,
        x_max: f64,
        y_min: f64,
        y_max: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__double_integral_impl(
            port_,
            expression,
            x_var,
            y_var,
            x_min,
            x_max,
            y_min,
            y_max,
            num_intervals,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__euler_totient(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__euler_totient_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__evaluate_expression(
        expression: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__evaluate_expression_impl(expression)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__evaluate_formula(
        formula: String,
        variables: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        values: Box<[f64]>,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__evaluate_formula_impl(formula, variables, values)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__evaluate_graph_points(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        x_values: Box<[f64]>,
    ) {
        wire__crate__api__evaluate_graph_points_impl(port_, expression, variable, x_values)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__factorial(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__factorial_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__fibonacci(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__fibonacci_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__find_extrema(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        x_min: f64,
        x_max: f64,
        num_samples: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__find_extrema_impl(port_, expression, variable, x_min, x_max, num_samples)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__find_graph_roots(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        x_min: f64,
        x_max: f64,
        num_samples: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__find_graph_roots_impl(
            port_,
            expression,
            variable,
            x_min,
            x_max,
            num_samples,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__find_roots_in_interval(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        start: f64,
        end: f64,
        num_samples: u32,
    ) {
        wire__crate__api__find_roots_in_interval_impl(
            port_,
            expression,
            variable,
            start,
            end,
            num_samples,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__gcd(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__gcd_impl(a, b)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__generate_x_range(
        start: f64,
        end: f64,
        num_points: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__generate_x_range_impl(start, end, num_points)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_constant(
        name: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_constant_impl(name)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_unit_categories(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_unit_categories_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__get_units_for_category(
        category: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__get_units_for_category_impl(category)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__gradient(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variables: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        point: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__gradient_impl(port_, expression, variables, point)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__init_app(port_: flutter_rust_bridge::for_generated::MessagePort) {
        wire__crate__api__init_app_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__integral_graph(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        x_values: Box<[f64]>,
        initial_value: f64,
    ) {
        wire__crate__api__integral_graph_impl(port_, expression, variable, x_values, initial_value)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__integrate(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        lower: f64,
        upper: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__integrate_impl(port_, expression, variable, lower, upper, num_intervals)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_perfect(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_perfect_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__is_prime(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__is_prime_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lcm(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__lcm_impl(a, b)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__line_integral(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        x_param: String,
        y_param: String,
        t_var: String,
        t_min: f64,
        t_max: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__line_integral_impl(
            port_,
            expression,
            x_param,
            y_param,
            t_var,
            t_min,
            t_max,
            num_intervals,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__linear_regression(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        x_data: Box<[f64]>,
        y_data: Box<[f64]>,
    ) {
        wire__crate__api__linear_regression_impl(port_, x_data, y_data)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__list_divisors(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__list_divisors_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__matrix_decomposition(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        rows: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        cols: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        decomposition_type: String,
    ) {
        wire__crate__api__matrix_decomposition_impl(port_, data, rows, cols, decomposition_type)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__matrix_operation(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        a_data: Box<[f64]>,
        a_rows: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        a_cols: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b_data: Option<Box<[f64]>>,
        b_rows: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b_cols: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        operation: String,
    ) {
        wire__crate__api__matrix_operation_impl(
            port_, a_data, a_rows, a_cols, b_data, b_rows, b_cols, operation,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__matrix_properties(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        rows: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        cols: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__matrix_properties_impl(port_, data, rows, cols)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__matrix_rref(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        rows: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        cols: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__matrix_rref_impl(port_, data, rows, cols)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mixed_partial_derivative(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        var1: String,
        var2: String,
        point: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__mixed_partial_derivative_impl(port_, expression, var1, var2, point)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mod_add(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        m: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_add_impl(a, b, m)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mod_divide(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        m: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_divide_impl(a, b, m)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mod_inverse(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        m: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_inverse_impl(a, m)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mod_multiply(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        m: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_multiply_impl(a, b, m)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mod_pow(
        base: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        exp: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        modulus: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_pow_impl(base, exp, modulus)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__mod_sub(
        a: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        b: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        m: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__mod_sub_impl(a, b, m)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__parse_formula(
        formula: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__parse_formula_impl(formula)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__partial_derivative(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        point: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        order: u32,
    ) {
        wire__crate__api__partial_derivative_impl(port_, expression, variable, point, order)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__permutations(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        r: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__permutations_impl(n, r)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__polynomial_regression(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        x_data: Box<[f64]>,
        y_data: Box<[f64]>,
        degree: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__polynomial_regression_impl(port_, x_data, y_data, degree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__prime_factors(
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__prime_factors_impl(n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sieve_primes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        n: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sieve_primes_impl(port_, n)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__solve_equation(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        initial_guess: f64,
        tolerance: f64,
        max_iterations: u32,
    ) {
        wire__crate__api__solve_equation_impl(
            port_,
            expression,
            variable,
            initial_guess,
            tolerance,
            max_iterations,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__t_test(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        hypothesized_mean: f64,
        alpha: f64,
    ) {
        wire__crate__api__t_test_impl(port_, data, hypothesized_mean, alpha)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__taylor_coefficients(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        variable: String,
        around: f64,
        num_terms: u32,
    ) {
        wire__crate__api__taylor_coefficients_impl(port_, expression, variable, around, num_terms)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__triple_integral(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        expression: String,
        x_var: String,
        y_var: String,
        z_var: String,
        x_min: f64,
        x_max: f64,
        y_min: f64,
        y_max: f64,
        z_min: f64,
        z_max: f64,
        num_intervals: u32,
    ) {
        wire__crate__api__triple_integral_impl(
            port_,
            expression,
            x_var,
            y_var,
            z_var,
            x_min,
            x_max,
            y_min,
            y_max,
            z_min,
            z_max,
            num_intervals,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__two_sample_t_test(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data1: Box<[f64]>,
        data2: Box<[f64]>,
        alpha: f64,
    ) {
        wire__crate__api__two_sample_t_test_impl(port_, data1, data2, alpha)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__two_sample_z_test(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data1: Box<[f64]>,
        data2: Box<[f64]>,
        std1: f64,
        std2: f64,
        alpha: f64,
    ) {
        wire__crate__api__two_sample_z_test_impl(port_, data1, data2, std1, std2, alpha)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__z_test(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        data: Box<[f64]>,
        hypothesized_mean: f64,
        population_std: f64,
        alpha: f64,
    ) {
        wire__crate__api__z_test_impl(port_, data, hypothesized_mean, population_std, alpha)
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
